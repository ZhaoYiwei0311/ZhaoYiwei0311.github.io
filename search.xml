<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Day01 Array Part01</title>
    <url>/2023/04/20/Day01-Array-Part01/</url>
    <content><![CDATA[<h2 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704 Binary Search"></a><a href="https://leetcode.cn/problems/binary-search/">704 Binary Search</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p>
<p>You must write an algorithm with O(log n) runtime complexity.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Left-Close-Right-Close"><a href="#1-Left-Close-Right-Close" class="headerlink" title="1. Left Close Right Close"></a>1. Left Close Right Close</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Left Close Right Close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// eg:[1, 1] is a legal loop, so use &quot;&lt;=&quot; here</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">         <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">             right = index - <span class="number">1</span>; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">             left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> index;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Left-Close-Right-Open"><a href="#2-Left-Close-Right-Open" class="headerlink" title="2. Left Close Right Open"></a>2. Left Close Right Open</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Left Close Right Open</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// Now right is open, so do not use (nums.length - 1) for start</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// eg:[1, 1) is not a legal loop, so use &quot;&lt;&quot; here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">            right = index; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27 Remove Element"></a><a href="https://leetcode.cn/problems/remove-element/">27 Remove Element</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p> Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.</p>
<p> Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:</p>
<ul>
<li><p>change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.</p>
</li>
<li><p>Return <code>k</code>.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent"><a href="#1-Violent" class="headerlink" title="1.Violent"></a>1.Violent</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Violent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// We have found the element to be deleted, so we need to start a new loop to move forward the elements after the found element</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// Because all the elements after i have been moved forward, it is necessary to minus i to get a new start</span></span><br><span class="line">            size--; <span class="comment">// the size of nums should also be declined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Two-Pointer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// fast index is aimed to go through the old nums</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// slow index is aimed to update out new nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123; <span class="comment">// the element is not the one to be deleted</span></span><br><span class="line">                nums[slow++] = nums[fast++]; <span class="comment">// so fast and slow both move forward, meanwhile nums[slow] is replaced by nums[fast]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// the element is the one to be deleted</span></span><br><span class="line">                fast++; <span class="comment">// so only fast moves forward to go through the nums, while slow just waits for the next loop in which the element shall not be deleted</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">// slow is the size of out new nums</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35 Search Insert Position"></a>35 <a href="https://leetcode.cn/problems/search-insert-position/">Search Insert Position</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p> Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search"><a href="#1-Binary-Search" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binary Search</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// go to left side</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// go to right side</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34 Find First and Last Position of Element in Sorted Array"></a>34 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p>
<p> If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search-1"><a href="#1-Binary-Search-1" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Binary Search</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">1</span>) &#123; <span class="comment">// Defense first</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// move to left part</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// move to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// one index has been found</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// We will try to get its left end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= nums.length - <span class="number">1</span>; i++) &#123; <span class="comment">// We will try to get its right end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">1</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary_Search</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
      </tags>
  </entry>
  <entry>
    <title>Day02 Array Part02</title>
    <url>/2023/04/20/Day02-Array-Part02/</url>
    <content><![CDATA[<h2 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent-Quick-Sort"><a href="#1-Violent-Quick-Sort" class="headerlink" title="1.Violent + Quick_Sort"></a>1.Violent + Quick_Sort</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Violent + Quick_Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// Square First</span></span><br><span class="line">        nums[i] = (<span class="type">int</span>)Math.pow(nums[i], <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// get the position of partition</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="comment">// divide and conquer for the left part</span></span><br><span class="line">        quickSort(arr, left, position - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// divide and conquer for the right part</span></span><br><span class="line">        quickSort(arr, position + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.choose the last element as the pivot to be compared</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">    <span class="comment">// 2.define the pointer that is in front of the pivot, here goes to the leftest</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="comment">// 3.iterate the array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="comment">// if arr[i] is not bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then swap the position itself with both the index and the pointer moving afterwards</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            swap(arr, i, pointer++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if arr[i] is bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then we will just move the index backwards,</span></span><br><span class="line">        <span class="comment">// leaving the pointer unchanged</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.the array has been iterated, and we will finally swap the position of pointer and right</span></span><br><span class="line">    swap(arr, pointer, right);</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">    arr[left] = arr[right];</span><br><span class="line">    arr[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><p>​	In the example of [-4,-1,0,3,10], which contains all three cases of negative number, zero and positive number, we can see easily find out that the biggest number squared will always appear on either left or right side. </p>
<p>This gives us a hint to try to use Two-Pointer Strategy which starts from both sides and by comparison we can just get the targeted squared array within complexity of O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// we are going to iterate the array in a reversed order, so the index should be set the last position</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(nums[left]) &gt;= Math.abs(nums[right])) &#123; <span class="comment">// left absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[left], <span class="number">2</span>));</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// right absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[right], <span class="number">2</span>));</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two-Pointer"></a>1.Two-Pointer</h4><p>​	Still with a left index and right index indicating the bounds of subarray we want</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= nums.length - <span class="number">1</span>) &#123; <span class="comment">// as long as the left index does not get to the end of array, the loop will continue</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target ) &#123; <span class="comment">// sum is smaller than our target, so we have to move right index afterwards</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; nums.length - <span class="number">1</span>) &#123; <span class="comment">// but there might be a case when our right index has already been out of bounds, where we have to stop the loop</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[right++]; <span class="comment">// in normal cases, right index move backwards as well as our sum gets bigger</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// sum is now not bigger than the target, so it is time to move left index afterwards to make the subarray smaller</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">                ans = right - left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, right - left);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[left++]; <span class="comment">// after the left index moves afterwards, the sum will get smaller</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Sliding-Window"><a href="#2-Sliding-Window" class="headerlink" title="2.Sliding-Window"></a>2.Sliding-Window</h4><p>The Sliding-Window here is an enhanced version of Two-Pointer above.</p>
<p>The key point is to use index end as the right side of subarray, while at the meantime when the sum is not smaller than the target, we are going to move the index start to narrow the subarray.</p>
<p>The process of narrowing is included within a while loop below the outer for loop.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sliding_Window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we will need a start index to indicate the left side of subarray</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length; end++) &#123; <span class="comment">// i here indicates the right side, AKA the end of subarray</span></span><br><span class="line">        sum += nums[end];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">// we must use while rather than if here because only by using while can we get the minimum size of subarray</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = end - start + <span class="number">1</span>; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[start++]; <span class="comment">// sum will be smaller after start index moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>​	It is the issue of boarder that we must emphasize on while dealing with this question.</p>
<p>We can stick to one principle, say “Left Close Right Open” in order not to get confused while writing codes.</p>
<p>There are also other points to be treated seriously.</p>
<ol>
<li><p>n might be even or odd, and we have to deal with it separately because of the existence of the center point.</p>
</li>
<li><p>After each All-round loop, the next start point would be changed, and we must know the exact offset. </p>
</li>
<li><p>We must know the unchanged point of every smaller loop that just covers one side of the matrix. In the horizontal movement, it is j that changes, while in the verical one, it is i.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pay attention to the boarder, we will stick to left close right open</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// number to be filled</span></span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// if n == 4, then we will have 2 loops; if n == 5, we will have 3 loops</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we start from (0, 0)</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// up: left to right</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from left to right, i remains the same, while j will change</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,0), (0,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,0), (0,1), (0,2)</span></span><br><span class="line">            ans[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// right: up to down</span></span><br><span class="line">        <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,2), (1,2)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,3), (1,3), (2,3)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// down: right to left</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from right to left, i remains the same, while j will change. And i has been set to the bottom row since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,2), (2,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,3), (3,2), (3,1)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left: down to ip</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,0), (1,0)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,0), (2,0), (1,0)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++; <span class="comment">// now that one outer layer is finished, it is time to increment the start point</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n % <span class="number">2</span>) != <span class="number">0</span>) &#123; <span class="comment">// in the case where n is an odd number, we have to deal with the center point alone</span></span><br><span class="line">        ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
      </tags>
  </entry>
  <entry>
    <title>Day03 Linked List Part01</title>
    <url>/2023/04/21/Day03-Linked-List-Part01/</url>
    <content><![CDATA[<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. Remove Linked List Elements</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the new head.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.Head node is a problem because it does not have a pre node, therefore it must be dealt with alone.</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        <span class="comment">// for defense, head must not be null</span></span><br><span class="line">        <span class="comment">// we use while instead of if here because there might be the case when head = [1,1,1] and val = 1. In such case, all head nodes should be deleted and if does not suffice</span></span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.Now that we have eliminated the threat from head node, it is time to delete nodes afterwards</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; <span class="comment">// it is essential to set a temporary index that points to head</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1           2           3           4</span></span><br><span class="line">    <span class="comment">//      cur         cur.n       cur.n.n</span></span><br><span class="line">    <span class="comment">//  suppose val = 2 and we can see that cur.n is to be deleted</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// we have to get the next of cur, so cur must not be null;</span></span><br><span class="line">        <span class="comment">// we also have to get the val of cur.next, so cur.next must not be null</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next.val == val) &#123; <span class="comment">// we have found the node to be deleted, it is cur.next</span></span><br><span class="line">            cur.next = cur.next.next; <span class="comment">// cur should jump twice and change its next to the cur.next.next, in which cur.next would be skipped</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// it is not the node to be deleted, cur moves afterwards</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head"><a href="#2-Dummy-Head" class="headerlink" title="2.Dummy_Head"></a>2.Dummy_Head</h4><p>While facing linked list related questions, it is always a good idea to consider defining dummy head to avoid dealing with the case concerned with head node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy_Head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// set a dummy head to avoid dealing specially with head node;</span></span><br><span class="line">    <span class="comment">// two pointer is still necessary</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy; <span class="comment">// one starts from dummy</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;  <span class="comment">// one starts from head</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123; <span class="comment">// we have found the node that meets our requirement, it is time to delete</span></span><br><span class="line">            pre.next = cur.next; <span class="comment">// the next node after pre should be the one after cur</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur; <span class="comment">// the node is not the one to be deleted, so pre node moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next; <span class="comment">// in both cases, the cur should move afterwards</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// we must return dummy.next because there might be the case when we would delete head node.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. Design Linked List</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</p>
<p>A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer&#x2F;reference to the next node.</p>
<p>If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>
<p>Implement the MyLinkedList class:</p>
<ul>
<li><p><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</p>
</li>
<li><p>int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.</p>
</li>
<li><p>void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</p>
</li>
<li><p>void addAtTail(int val) Append a node of value val as the last element of the linked list.</p>
</li>
<li><p>void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.</p>
</li>
<li><p>void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Dummy-Head"><a href="#1-Dummy-Head" class="headerlink" title="1.Dummy_Head"></a>1.Dummy_Head</h4><p>This question is a good one to  practice manipulating linked list. </p>
<p>We still need to rely on dummy head in order to simplify the treatment of head node.</p>
<p>Besides, the size of the list is also a key field to be utilized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// sequence is quite important</span></span><br><span class="line">        <span class="comment">//          0           2</span></span><br><span class="line">        <span class="comment">//          cur         cur.next</span></span><br><span class="line">        <span class="comment">// suppose we are going to add 1 as head</span></span><br><span class="line">        <span class="comment">//          0           1           2</span></span><br><span class="line">        <span class="comment">//          cur                     cur.next</span></span><br><span class="line">        <span class="comment">// 1.the next of 1 Node must be connected to cur.next first</span></span><br><span class="line">        <span class="comment">// 2.the cur.next then would be connected to 1 Node</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// move to the tail, if boarder bothers again, take the example of one node again</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, <span class="literal">null</span>);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head-But-More-Concise"><a href="#2-Dummy-Head-But-More-Concise" class="headerlink" title="2. Dummy_Head_But_More_Concise"></a>2. Dummy_Head_But_More_Concise</h4><p>Make addAtHead and addAtTail more concise by combining these two methods with addAtIndex</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. Reverse Linked List</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<h3 id="Soulution"><a href="#Soulution" class="headerlink" title="Soulution"></a>Soulution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>Two pointer, actually three pointer works quite well in this question.</p>
<p>Still sequence is the issue that matters</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// actually we need three pointers in this question and they are pre, cur and cur</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//          pre             cur         temp</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                          pre         cur         temp</span></span><br><span class="line">    <span class="comment">// in the end, it should be like this</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                                                              pre         cur</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// the most previous node should point to null, just as symmetrically, the next of end node points to null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// define our helper node to trace cur.next, otherwise cur loses its way afterwards</span></span><br><span class="line">        <span class="comment">// sequence is also important here</span></span><br><span class="line">        <span class="comment">// 1.cur should point to pre</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 2.pre should become cur</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 3.cur should be replaced with temp</span></span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// seen from the example, pre is the node to be returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion"><a href="#2-Recursion" class="headerlink" title="2. Recursion"></a>2. Recursion</h4><p>Based on the two pointer solution above, we can get an easier but harder to understand solution which utilizes recursion</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// pre should be null and cur should be head</span></span><br><span class="line">    <span class="keyword">return</span> recursion(head, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">recursion</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123; <span class="comment">// the end of recursion</span></span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// still it is pre to be returned</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// helper node is still needed to trace cur.next</span></span><br><span class="line">    cur.next = pre; <span class="comment">// reversed here</span></span><br><span class="line">    <span class="keyword">return</span> recursion(temp, cur); <span class="comment">// the nodes here have changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Linked_List</tag>
        <tag>Dummy_Head</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
</search>
