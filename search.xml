<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Day02 Array Part02</title>
    <url>/2023/04/20/Day02-Array-Part02/</url>
    <content><![CDATA[<h2 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent-Quick-Sort"><a href="#1-Violent-Quick-Sort" class="headerlink" title="1.Violent + Quick_Sort"></a>1.Violent + Quick_Sort</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Violent + Quick_Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// Square First</span></span><br><span class="line">        nums[i] = (<span class="type">int</span>)Math.pow(nums[i], <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// get the position of partition</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="comment">// divide and conquer for the left part</span></span><br><span class="line">        quickSort(arr, left, position - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// divide and conquer for the right part</span></span><br><span class="line">        quickSort(arr, position + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.choose the last element as the pivot to be compared</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">    <span class="comment">// 2.define the pointer that is in front of the pivot, here goes to the leftest</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="comment">// 3.iterate the array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="comment">// if arr[i] is not bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then swap the position itself with both the index and the pointer moving afterwards</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            swap(arr, i, pointer++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if arr[i] is bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then we will just move the index backwards,</span></span><br><span class="line">        <span class="comment">// leaving the pointer unchanged</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.the array has been iterated, and we will finally swap the position of pointer and right</span></span><br><span class="line">    swap(arr, pointer, right);</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">    arr[left] = arr[right];</span><br><span class="line">    arr[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><p>​	In the example of [-4,-1,0,3,10], which contains all three cases of negative number, zero and positive number, we can see easily find out that the biggest number squared will always appear on either left or right side. </p>
<p>This gives us a hint to try to use Two-Pointer Strategy which starts from both sides and by comparison we can just get the targeted squared array within complexity of O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// we are going to iterate the array in a reversed order, so the index should be set the last position</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(nums[left]) &gt;= Math.abs(nums[right])) &#123; <span class="comment">// left absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[left], <span class="number">2</span>));</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// right absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[right], <span class="number">2</span>));</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two-Pointer"></a>1.Two-Pointer</h4><p>​	Still with a left index and right index indicating the bounds of subarray we want</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= nums.length - <span class="number">1</span>) &#123; <span class="comment">// as long as the left index does not get to the end of array, the loop will continue</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target ) &#123; <span class="comment">// sum is smaller than our target, so we have to move right index afterwards</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; nums.length - <span class="number">1</span>) &#123; <span class="comment">// but there might be a case when our right index has already been out of bounds, where we have to stop the loop</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[right++]; <span class="comment">// in normal cases, right index move backwards as well as our sum gets bigger</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// sum is now not bigger than the target, so it is time to move left index afterwards to make the subarray smaller</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">                ans = right - left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, right - left);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[left++]; <span class="comment">// after the left index moves afterwards, the sum will get smaller</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Sliding-Window"><a href="#2-Sliding-Window" class="headerlink" title="2.Sliding-Window"></a>2.Sliding-Window</h4><p>The Sliding-Window here is an enhanced version of Two-Pointer above.</p>
<p>The key point is to use index end as the right side of subarray, while at the meantime when the sum is not smaller than the target, we are going to move the index start to narrow the subarray.</p>
<p>The process of narrowing is included within a while loop below the outer for loop.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sliding_Window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we will need a start index to indicate the left side of subarray</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length; end++) &#123; <span class="comment">// i here indicates the right side, AKA the end of subarray</span></span><br><span class="line">        sum += nums[end];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">// we must use while rather than if here because only by using while can we get the minimum size of subarray</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = end - start + <span class="number">1</span>; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[start++]; <span class="comment">// sum will be smaller after start index moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>​	It is the issue of boarder that we must emphasize on while dealing with this question.</p>
<p>We can stick to one principle, say “Left Close Right Open” in order not to get confused while writing codes.</p>
<p>There are also other points to be treated seriously.</p>
<ol>
<li><p>n might be even or odd, and we have to deal with it separately because of the existence of the center point.</p>
</li>
<li><p>After each All-round loop, the next start point would be changed, and we must know the exact offset. </p>
</li>
<li><p>We must know the unchanged point of every smaller loop that just covers one side of the matrix. In the horizontal movement, it is j that changes, while in the verical one, it is i.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pay attention to the boarder, we will stick to left close right open</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// number to be filled</span></span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// if n == 4, then we will have 2 loops; if n == 5, we will have 3 loops</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we start from (0, 0)</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// up: left to right</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from left to right, i remains the same, while j will change</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,0), (0,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,0), (0,1), (0,2)</span></span><br><span class="line">            ans[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// right: up to down</span></span><br><span class="line">        <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,2), (1,2)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,3), (1,3), (2,3)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// down: right to left</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from right to left, i remains the same, while j will change. And i has been set to the bottom row since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,2), (2,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,3), (3,2), (3,1)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left: down to ip</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,0), (1,0)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,0), (2,0), (1,0)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++; <span class="comment">// now that one outer layer is finished, it is time to increment the start point</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n % <span class="number">2</span>) != <span class="number">0</span>) &#123; <span class="comment">// in the case where n is an odd number, we have to deal with the center point alone</span></span><br><span class="line">        ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
      </tags>
  </entry>
  <entry>
    <title>Day01 Array Part01</title>
    <url>/2023/04/20/Day01-Array-Part01/</url>
    <content><![CDATA[<h2 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704 Binary Search"></a><a href="https://leetcode.cn/problems/binary-search/">704 Binary Search</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p>
<p>You must write an algorithm with O(log n) runtime complexity.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Left-Close-Right-Close"><a href="#1-Left-Close-Right-Close" class="headerlink" title="1. Left Close Right Close"></a>1. Left Close Right Close</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Left Close Right Close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// eg:[1, 1] is a legal loop, so use &quot;&lt;=&quot; here</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">         <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">             right = index - <span class="number">1</span>; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">             left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> index;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Left-Close-Right-Open"><a href="#2-Left-Close-Right-Open" class="headerlink" title="2. Left Close Right Open"></a>2. Left Close Right Open</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Left Close Right Open</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// Now right is open, so do not use (nums.length - 1) for start</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// eg:[1, 1) is not a legal loop, so use &quot;&lt;&quot; here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">            right = index; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27 Remove Element"></a><a href="https://leetcode.cn/problems/remove-element/">27 Remove Element</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p> Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.</p>
<p> Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:</p>
<ul>
<li><p>change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.</p>
</li>
<li><p>Return <code>k</code>.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent"><a href="#1-Violent" class="headerlink" title="1.Violent"></a>1.Violent</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Violent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// We have found the element to be deleted, so we need to start a new loop to move forward the elements after the found element</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// Because all the elements after i have been moved forward, it is necessary to minus i to get a new start</span></span><br><span class="line">            size--; <span class="comment">// the size of nums should also be declined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Two-Pointer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// fast index is aimed to go through the old nums</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// slow index is aimed to update out new nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123; <span class="comment">// the element is not the one to be deleted</span></span><br><span class="line">                nums[slow++] = nums[fast++]; <span class="comment">// so fast and slow both move forward, meanwhile nums[slow] is replaced by nums[fast]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// the element is the one to be deleted</span></span><br><span class="line">                fast++; <span class="comment">// so only fast moves forward to go through the nums, while slow just waits for the next loop in which the element shall not be deleted</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">// slow is the size of out new nums</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35 Search Insert Position"></a>35 <a href="https://leetcode.cn/problems/search-insert-position/">Search Insert Position</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p> Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search"><a href="#1-Binary-Search" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binary Search</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// go to left side</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// go to right side</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34 Find First and Last Position of Element in Sorted Array"></a>34 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p>
<p> If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search-1"><a href="#1-Binary-Search-1" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Binary Search</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">1</span>) &#123; <span class="comment">// Defense first</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// move to left part</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// move to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// one index has been found</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// We will try to get its left end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= nums.length - <span class="number">1</span>; i++) &#123; <span class="comment">// We will try to get its right end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">1</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
        <tag>Binary_Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Day03 Linked List Part01</title>
    <url>/2023/04/21/Day03-Linked-List-Part01/</url>
    <content><![CDATA[<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. Remove Linked List Elements</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the new head.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.Head node is a problem because it does not have a pre node, therefore it must be dealt with alone.</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        <span class="comment">// for defense, head must not be null</span></span><br><span class="line">        <span class="comment">// we use while instead of if here because there might be the case when head = [1,1,1] and val = 1. In such case, all head nodes should be deleted and if does not suffice</span></span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.Now that we have eliminated the threat from head node, it is time to delete nodes afterwards</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; <span class="comment">// it is essential to set a temporary index that points to head</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1           2           3           4</span></span><br><span class="line">    <span class="comment">//      cur         cur.n       cur.n.n</span></span><br><span class="line">    <span class="comment">//  suppose val = 2 and we can see that cur.n is to be deleted</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// we have to get the next of cur, so cur must not be null;</span></span><br><span class="line">        <span class="comment">// we also have to get the val of cur.next, so cur.next must not be null</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next.val == val) &#123; <span class="comment">// we have found the node to be deleted, it is cur.next</span></span><br><span class="line">            cur.next = cur.next.next; <span class="comment">// cur should jump twice and change its next to the cur.next.next, in which cur.next would be skipped</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// it is not the node to be deleted, cur moves afterwards</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head"><a href="#2-Dummy-Head" class="headerlink" title="2.Dummy_Head"></a>2.Dummy_Head</h4><p>While facing linked list related questions, it is always a good idea to consider defining dummy head to avoid dealing with the case concerned with head node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy_Head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// set a dummy head to avoid dealing specially with head node;</span></span><br><span class="line">    <span class="comment">// two pointer is still necessary</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy; <span class="comment">// one starts from dummy</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;  <span class="comment">// one starts from head</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123; <span class="comment">// we have found the node that meets our requirement, it is time to delete</span></span><br><span class="line">            pre.next = cur.next; <span class="comment">// the next node after pre should be the one after cur</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur; <span class="comment">// the node is not the one to be deleted, so pre node moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next; <span class="comment">// in both cases, the cur should move afterwards</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// we must return dummy.next because there might be the case when we would delete head node.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. Design Linked List</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</p>
<p>A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer&#x2F;reference to the next node.</p>
<p>If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>
<p>Implement the MyLinkedList class:</p>
<ul>
<li><p><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</p>
</li>
<li><p>int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.</p>
</li>
<li><p>void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</p>
</li>
<li><p>void addAtTail(int val) Append a node of value val as the last element of the linked list.</p>
</li>
<li><p>void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.</p>
</li>
<li><p>void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Dummy-Head"><a href="#1-Dummy-Head" class="headerlink" title="1.Dummy_Head"></a>1.Dummy_Head</h4><p>This question is a good one to  practice manipulating linked list. </p>
<p>We still need to rely on dummy head in order to simplify the treatment of head node.</p>
<p>Besides, the size of the list is also a key field to be utilized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// sequence is quite important</span></span><br><span class="line">        <span class="comment">//          0           2</span></span><br><span class="line">        <span class="comment">//          cur         cur.next</span></span><br><span class="line">        <span class="comment">// suppose we are going to add 1 as head</span></span><br><span class="line">        <span class="comment">//          0           1           2</span></span><br><span class="line">        <span class="comment">//          cur                     cur.next</span></span><br><span class="line">        <span class="comment">// 1.the next of 1 Node must be connected to cur.next first</span></span><br><span class="line">        <span class="comment">// 2.the cur.next then would be connected to 1 Node</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// move to the tail, if boarder bothers again, take the example of one node again</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, <span class="literal">null</span>);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head-But-More-Concise"><a href="#2-Dummy-Head-But-More-Concise" class="headerlink" title="2. Dummy_Head_But_More_Concise"></a>2. Dummy_Head_But_More_Concise</h4><p>Make addAtHead and addAtTail more concise by combining these two methods with addAtIndex</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. Reverse Linked List</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<h3 id="Soulution"><a href="#Soulution" class="headerlink" title="Soulution"></a>Soulution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>Two pointer, actually three pointer works quite well in this question.</p>
<p>Still sequence is the issue that matters</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// actually we need three pointers in this question and they are pre, cur and cur</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//          pre             cur         temp</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                          pre         cur         temp</span></span><br><span class="line">    <span class="comment">// in the end, it should be like this</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                                                              pre         cur</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// the most previous node should point to null, just as symmetrically, the next of end node points to null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// define our helper node to trace cur.next, otherwise cur loses its way afterwards</span></span><br><span class="line">        <span class="comment">// sequence is also important here</span></span><br><span class="line">        <span class="comment">// 1.cur should point to pre</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 2.pre should become cur</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 3.cur should be replaced with temp</span></span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// seen from the example, pre is the node to be returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion"><a href="#2-Recursion" class="headerlink" title="2. Recursion"></a>2. Recursion</h4><p>Based on the two pointer solution above, we can get an easier but harder to understand solution which utilizes recursion</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// pre should be null and cur should be head</span></span><br><span class="line">    <span class="keyword">return</span> recursion(head, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">recursion</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123; <span class="comment">// the end of recursion</span></span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// still it is pre to be returned</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// helper node is still needed to trace cur.next</span></span><br><span class="line">    cur.next = pre; <span class="comment">// reversed here</span></span><br><span class="line">    <span class="keyword">return</span> recursion(temp, cur); <span class="comment">// the nodes here have changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Linked_List</tag>
        <tag>Dummy_Head</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>Day04 Linked List Part02</title>
    <url>/2023/04/23/Day04-Linked-List-Part02/</url>
    <content><![CDATA[<h2 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Dummy-Head"><a href="#1-Dummy-Head" class="headerlink" title="1.Dummy_Head"></a>1.Dummy_Head</h4><p>Dummy head is quite useful since it simplifies the manipulation of the very first head node.</p>
<p>Also, the sequence of next declaration and the utilization of  helper node are key points in this question</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy Head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// A dummy head is still needed, and its next is the head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">    <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">    <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">    <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Here we do not need to judge if cur is null because we have set the dummy as cur deliberately</span></span><br><span class="line">        <span class="comment">// In order to manipulate 1 and 2 node, we must get cur.next and cur.next.next</span></span><br><span class="line">        <span class="comment">// , which is the reason why they must not be null if the loop continues</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Once we have swapped 1 and 2, it is not possible to get 3 through 2,</span></span><br><span class="line">        <span class="comment">// so we need a helper here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp3</span> <span class="operator">=</span> cur.next.next.next;</span><br><span class="line">        <span class="comment">// As the same, once we connect 0 with 2, it is also not possible to get 1,</span></span><br><span class="line">        <span class="comment">// so we need another helper here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start the swap and sequence is important</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       t1      c.n</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n.n   c.n     t3</span></span><br><span class="line">        <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">        <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">        <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        cur.next.next = temp1;</span><br><span class="line">        cur.next.next.next = temp3;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// It is still dummy&#x27;s next to be returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Dummy-Head"><a href="#1-Two-Pointer-Dummy-Head" class="headerlink" title="1.Two_Pointer + Dummy_Head"></a>1.Two_Pointer + Dummy_Head</h4><p>Two pointer can be use used to get the Nth node from end in one loop.</p>
<p>Suppose we are going to get the 2nd node from end, which is 4 in the example</p>
<ol>
<li>We are going to move fast pointer first</li>
<li>At step 3, when fast pointer has moved 2 steps afterwards, we are going to set the slow pointer. From now on, we will move both pointers simultaneously.</li>
<li>Fast pointer points to null at step 6 and our iteration stops. We can see that slow pointer now points to the node we want</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
</tr>
</tbody></table>
<p>Therefore, two pointer is  a useful skill to get the Nth node from end in one loop.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy Head + Two Pointer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// </span></span><br><span class="line">    <span class="comment">// Suppose n = 2, which means we are going to delete 3 Node</span></span><br><span class="line">    <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">    <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">    <span class="comment">// We must make sure that cur points to the previous node 2 so that we can manipulate node 3</span></span><br><span class="line">    <span class="comment">// This means the slow pointer adopted from the two-pointer skill to get the Nth node from end in one loop should point to the node before, so here should be some adjustment.</span></span><br><span class="line">    <span class="comment">// We can adjust the fast pointer to let it move one more step before moving both pointers</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123; <span class="comment">// We let fast pointer move (n + 1) steps alone</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123; <span class="comment">// We move both pointers until fast points to null</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now it should be like this</span></span><br><span class="line">    <span class="comment">//      0       1       2       3       4       null</span></span><br><span class="line">    <span class="comment">//                      s                       f</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// still return dummy.next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="02-07-Intersection-of-Two-Linked-Lists-LCCI"><a href="#02-07-Intersection-of-Two-Linked-Lists-LCCI" class="headerlink" title="02.07. Intersection of Two Linked Lists LCCI"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">02.07. Intersection of Two Linked Lists LCCI</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter­secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>The key point of this question is to understand the basic principle that judgment of intersection only starts once two lists have the relatively same length from end. We can deduce that by drawling two lists within right alignment.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// Suppose two lists below</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">// B    2       4       5</span></span><br><span class="line">    <span class="comment">// Apparently, Node 4 is the one to be returned, but how?</span></span><br><span class="line">    <span class="comment">// There is a rule that if there is an intersection, the two lists will always meet in the end</span></span><br><span class="line">    <span class="comment">// and the length of sub lists after intersection is the same</span></span><br><span class="line">    <span class="comment">// We can try to show both lists in right alignment</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">// We can know that Node 1 to Node 2 from A list is useless,</span></span><br><span class="line">    <span class="comment">// because intersection can only start when two sub lists are of the same length.</span></span><br><span class="line">    <span class="comment">// So we can skip them these we know the length difference of lists, which is 2</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">//                      cA</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">//                      cB</span></span><br><span class="line">    <span class="comment">// We make two pointers then at the relatively same point from end</span></span><br><span class="line">    <span class="comment">// then we can start move both pointers simultaneously until we find the intersected node</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">//                              cA</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">//                              cB</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="comment">// We must know the length difference</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (curB != <span class="literal">null</span>) &#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        curB = curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get the length difference</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(lenA - lenB);</span><br><span class="line">    <span class="comment">// reset</span></span><br><span class="line">    curA = headA;</span><br><span class="line">    curB = headB;</span><br><span class="line">    <span class="comment">// By default, list A should be the one longer, and we can skip some nodes in it,</span></span><br><span class="line">    <span class="comment">// but this is not always the case, so there is a swap to make sure our assume work</span></span><br><span class="line">    <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">        curA = headB;</span><br><span class="line">        curB = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (diff-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">            <span class="keyword">return</span> curA;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">        curB = curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p>
<p>Do not modify the linked list.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-1"><a href="#1-Two-Pointer-1" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>Two points for this question</p>
<ol>
<li><p>How can we know if there is a cycle in the list?</p>
<p>We can know that by moving two pointers, one moves two steps once and the other one one step once.</p>
<p>If there is no cycle, the faster one will point to null in advance.</p>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">s|f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
</tr>
</tbody></table>
<p>If there is a cycle, the two pointers will meet.</p>
<p>Suppose the node after 3 is node 1.</p>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">s|f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center">f</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center">s</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s|f</td>
</tr>
</tbody></table>
</li>
<li><p>How can we know the entrance of cycle?</p>
<p><a href="https://postimg.cc/R6MwyMy0"><img src="https://i.postimg.cc/Y9F840xQ/Day04-Linked-List-Part02-01.jpg" alt="Day04-Linked-List-Part02-01.jpg"></a></p>
<p>Suppose x as the distance from start to entrance.</p>
<p>Suppose y as the distance from entrance to the point where both pointers meet, actually it is the distance slow pointer has move after it enters the circle.</p>
<p>Suppose z as the distance from the point met to entrance.</p>
<p>What clues can we get then?</p>
<ol>
<li><p>The whole distance of slow is x + y</p>
</li>
<li><p>The whole distance of cycle is y + z</p>
</li>
<li><p>The fast can have already moved n cycles, so the distance of fast is x + y + n * (y + z)</p>
</li>
<li><p>The speed of slow is 1 and the speed of fast is 2, so there is an equation: </p>
<p>​		2 * (x + y) &#x3D; x + y + n * (y + z)</p>
<p>​		x  &#x3D; n * (y + z) - z</p>
</li>
<li><p>n is always &gt;&#x3D; 1 and is not quite important, so we can just combine it with some (n - 1) factor</p>
<p>​		x  &#x3D; (n - 1) * (y + z) + z</p>
</li>
<li><p>Since n is not important, we can actually suppose it be 1 and what we get is</p>
<p>​		x  &#x3D; z</p>
<p>which means we can conclude that distance from start to entrance &#x3D;&#x3D; the distance from the point met to entrance</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// Since there might be a cycle now, we can not rely on dummy head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123; <span class="comment">// we must make sure that fast.next is also not null because there is no dummy head to simplify the manipulation of the very first head node.</span></span><br><span class="line">        <span class="comment">// If it is the case of [1], we will meet null pointer when we move fast for two steps</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123; <span class="comment">// two pointers have met</span></span><br><span class="line">            <span class="comment">// reset slow to head</span></span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="comment">// and move both pointers one step every time</span></span><br><span class="line">            <span class="comment">// they will meet at entrance</span></span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Linked_List</tag>
        <tag>Dummy_Head</tag>
      </tags>
  </entry>
  <entry>
    <title>Day06 Hash Table Part01</title>
    <url>/2023/04/24/Day06-Hash-Table-Part01/</url>
    <content><![CDATA[<h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. Valid Anagram</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</p>
<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table"><a href="#1-Hash-Table" class="headerlink" title="1. Hash_Table"></a>1. Hash_Table</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123; <span class="comment">// If length is different, that will definitely be false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] table = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]; <span class="comment">// We do not need to create an alphabetical table.</span></span><br><span class="line">                               <span class="comment">// A simulation array would be okay.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        table[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++; <span class="comment">// for s add</span></span><br><span class="line">        table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--; <span class="comment">// for t minus</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i] != <span class="number">0</span>) &#123; <span class="comment">// if the value is not 0, it will not be anagram</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// Unlike alphabets, we do not know the exact value in the arrays.</span></span><br><span class="line">    <span class="comment">// So we use set instead of array made by ourselves.</span></span><br><span class="line">    HashSet&lt;Integer&gt; containerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; resultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123; <span class="comment">// get all unique value from nums1</span></span><br><span class="line">        containerSet.add(nums1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123; <span class="comment">// compare nums2 with containerSet and find intersection</span></span><br><span class="line">        <span class="keyword">if</span> (containerSet.contains(nums2[i])) &#123;</span><br><span class="line">            resultSet.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[resultSet.size()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : resultSet) &#123;</span><br><span class="line">        ans[index++] = integer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.cn/problems/happy-number/">202. Happy Number</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Write an algorithm to determine if a number n is happy.</p>
<p>A happy number is a number defined by the following process:</p>
<ul>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or <strong>it loops endlessly in a cycle</strong> which does not include 1.</li>
<li>Those numbers for which this process ends in 1 are happy.</li>
</ul>
<p>Return true if n is a happy number, and false if not.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Set-1"><a href="#1-Set-1" class="headerlink" title="1. Set"></a>1. Set</h4><p>The hardest part might be the algorithm to get the next number.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// It says that there will be an endless loop if n is not happy.</span></span><br><span class="line">    <span class="comment">// So we can use a set to store numbers that have appeared.</span></span><br><span class="line">    <span class="comment">// Once repetition occurs, return false.</span></span><br><span class="line">    HashSet&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    record.add(n); <span class="comment">// put n into record</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextNumber</span> <span class="operator">=</span> getNextNumber(n);</span><br><span class="line">    <span class="keyword">while</span> (nextNumber != <span class="number">1</span>) &#123;</span><br><span class="line">        nextNumber = getNextNumber(nextNumber); <span class="comment">// get the next number</span></span><br><span class="line">        <span class="keyword">if</span> (!record.contains(nextNumber)) &#123; <span class="comment">// if the next number is a new number, we continue</span></span><br><span class="line">            record.add(nextNumber);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// if the next number has appeared, we return false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="comment">// always get the rightmost digit</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line">        sum += digit * digit;</span><br><span class="line">        num = num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table-1"><a href="#1-Hash-Table-1" class="headerlink" title="1.Hash_Table"></a>1.Hash_Table</h4><p>We use Hash if there is a requirement to record the element that has appeared. </p>
<p>We use map because we want to both record the number that has already appeared and the index of it.</p>
<p>Set is not sufficient because it cannot do the latter.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// use map to record target - nums[i]</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// See if there exists a number in the map that equals to nums[i]</span></span><br><span class="line">        <span class="comment">// That is because that we put in the map is target - nums[i]</span></span><br><span class="line">        <span class="keyword">if</span> (map.get(nums[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">            ans[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// What we put is target - nums[i]</span></span><br><span class="line">        <span class="comment">// What we compare in the iteration is target - nums[i] and nums[i]</span></span><br><span class="line">        <span class="comment">// Also sequence is important here to avoid repetition</span></span><br><span class="line">        <span class="comment">//  1.first compare</span></span><br><span class="line">        <span class="comment">//  2.then put</span></span><br><span class="line">        <span class="comment">// if sequence gets wrong, the answer would be [0,0] in the case where nums [3,2,4]</span></span><br><span class="line">        <span class="comment">//  and target = 6 because we failed to avoid repetition</span></span><br><span class="line">        map.put(target - nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash_Table</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title>Day07 Hash Table Part02</title>
    <url>/2023/04/25/Day07-Hash-Table-Part02/</url>
    <content><![CDATA[<h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 4Sum II</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:</p>
<ul>
<li>0 &lt;&#x3D; i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0<span id="more"></span></li>
</ul>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table-Divide-And-Conquer"><a href="#1-Hash-Table-Divide-And-Conquer" class="headerlink" title="1.Hash_Table + Divide_And_Conquer"></a>1.Hash_Table + Divide_And_Conquer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table + Divide And Conquer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">    <span class="comment">// We do not to care about repetition because all numbers have different indexes</span></span><br><span class="line">    <span class="comment">//  and combination with different position still count.</span></span><br><span class="line">    <span class="comment">// We can divide four arrays into two groups and convert the question into TwoSum1 question</span></span><br><span class="line">    <span class="comment">//  which utilizes hash table.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="comment">// we store sums from the first two arrays into map</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map1And2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">            temp = i + j;</span><br><span class="line">            <span class="keyword">if</span> (map1And2.containsKey(temp)) &#123;</span><br><span class="line">                map1And2.put(temp, map1And2.get(temp) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map1And2.put(temp, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for the rest two arrays, we compare the sum with what we got in the map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums3) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">            temp = i + j;</span><br><span class="line">            <span class="keyword">if</span> (map1And2.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                <span class="comment">// we can directly add the value because just as said before,</span></span><br><span class="line">                <span class="comment">// we do not to worry about repetition since combination</span></span><br><span class="line">                <span class="comment">// with different positions still count</span></span><br><span class="line">                ans += map1And2.get(<span class="number">0</span> - temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.cn/problems/ransom-note/">383. Ransom Note</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.</p>
<p>Each letter in magazine can only be used once in ransomNote.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table"><a href="#1-Hash-Table" class="headerlink" title="1.Hash_Table"></a>1.Hash_Table</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="comment">// All are lowercase English letters, so an array rather than map would suffice</span></span><br><span class="line">    <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123; <span class="comment">// count all characters from magazine</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">character</span> <span class="operator">=</span> magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        record[character]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">character</span> <span class="operator">=</span> ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        record[character]--; <span class="comment">// minus corresponding character</span></span><br><span class="line">        <span class="keyword">if</span> (record[character] &lt; <span class="number">0</span>) &#123; <span class="comment">// if corresponding count is negative, then return false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><a href="https://leetcode.cn/problems/3sum/">15. 3Sum</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i !&#x3D; j, i !&#x3D; k, and j !&#x3D; k, and nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Quick-Sort"><a href="#1-Two-Pointer-Quick-Sort" class="headerlink" title="1.Two_Pointer + Quick_Sort"></a>1.Two_Pointer + Quick_Sort</h4><p>This question does not require returning index, so we can do a quick sort and find the answer by two pointer.</p>
<p>The biggest difficulty is to avoid duplication and we can do that by paying attention to the condition of iteration </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Quick Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// We can use two pointer in this question because we do not need to return index</span></span><br><span class="line">    <span class="comment">// Suppose nums = &#123;-1, 0, 1, 2, -1, 4&#125;</span></span><br><span class="line">    <span class="comment">// We must do a quick sort this nums if we want to adopt two pointer</span></span><br><span class="line">    <span class="comment">// So it will become</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">// Then we do an iteration that starts from -1</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i</span></span><br><span class="line">    <span class="comment">// And we will import two pointers</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i       l                               r</span></span><br><span class="line">    <span class="comment">// it seems now three summed are bigger than 0, therefore we can move r</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i       l                       r</span></span><br><span class="line">    <span class="comment">// bingo, we get one answer &#123;-1, -1, 2&#125; and we shall continue by moving both pointers</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i               l       r</span></span><br><span class="line">    <span class="comment">// bingo another one. If we keep moving both pointers, l would be bigger than r</span></span><br><span class="line">    <span class="comment">// which means it is time to continue iteration</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//              i       l                       r</span></span><br><span class="line">    <span class="comment">// too big until it goes to</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//              i       l       r</span></span><br><span class="line">    <span class="comment">// but there comes the issue of duplication, so we must exclude this kind of case</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// must sort first</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// if nums[i] is already bigger than 0, we can break the whole iteration and return ans</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we must exclude duplicated A.</span></span><br><span class="line">        <span class="comment">// Two codes here</span></span><br><span class="line">        <span class="comment">// 1.nums[i] == nums[i + 1]</span></span><br><span class="line">        <span class="comment">// 2.nums[i] == nums[i - 1]</span></span><br><span class="line">        <span class="comment">// Suppose [-1, -1, 2] and i = 0 right now</span></span><br><span class="line">        <span class="comment">// code 1 is not okay because we will skip it since nums[i] == nums[i + 1]</span></span><br><span class="line">        <span class="comment">// code 2 is okay because there is no element before first -1, so this one counts</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// Here I use two helpers, but actually it is not that necessary</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tempLeftValue</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempRightValue</span> <span class="operator">=</span> nums[right];</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + tempLeftValue + tempRightValue;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(Arrays.asList(nums[i], tempLeftValue, tempRightValue));</span><br><span class="line">                <span class="comment">// exclude duplicated B</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left + <span class="number">1</span>] == tempLeftValue) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// // exclude duplicated C</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right - <span class="number">1</span>] == tempRightValue) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a><a href="https://leetcode.cn/problems/4sum/">18. 4Sum</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:</p>
<ul>
<li><p>0 &lt;&#x3D; a, b, c, d &lt; n</p>
</li>
<li><p>a, b, c, and d are distinct.</p>
</li>
<li><p>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</p>
</li>
</ul>
<p>You may return the answer in any order.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Quick-Sort-1"><a href="#1-Two-Pointer-Quick-Sort-1" class="headerlink" title="1.Two_Pointer + Quick_Sort"></a>1.Two_Pointer + Quick_Sort</h4><p>It is quite similar to 15.3Sum.</p>
<p>First sort and then apply two pointers.</p>
<p>We can extend this method to even n digits and will result in a declination of complexity from O(N^N) to O(N^(N - 1))</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Quick Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// Like ThreeSum15, we can use two pointer</span></span><br><span class="line">    <span class="comment">// And the first step is also sort</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return if it is already too big</span></span><br><span class="line">        <span class="comment">// remember it must be positive</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>  &amp;&amp; nums[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// exclude duplicate A</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// exclude duplicated B</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="comment">// there might be overflow, so make it long</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">// exclude duplicated C</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="comment">// exclude duplicated D</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Hash_Table</tag>
      </tags>
  </entry>
  <entry>
    <title>Day08 String Part01</title>
    <url>/2023/04/26/Day08-String-Part01/</url>
    <content><![CDATA[<h2 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a><a href="https://leetcode.cn/problems/reverse-string/">344. Reverse String</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Write a function that reverses a string. The input string is given as an array of characters s.</p>
<p>You must do this by modifying the input array in-place with O(1) extra memory.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. Reverse String II</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.</p>
<p>If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><p>Actually the hardest part is to understand the question.</p>
<p>If understood, the question becomes quite easy. We just need to pay attention to the steps.</p>
<p>Besides, it is also a more efficient skill to convert string into a char array first and then do the reverse through this array.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// converting s into an array will make it more efficient</span></span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// The step is 2 * k</span></span><br><span class="line">        <span class="comment">// We get a start and an end</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">2</span> * k * times;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; s.length() -<span class="number">1</span> &amp;&amp; end &gt;= s.length() - <span class="number">1</span>) &#123; <span class="comment">// if the rest is less than k</span></span><br><span class="line">            reverse(arr, start, arr.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt;= s.length() - <span class="number">1</span>) &#123; <span class="comment">// if the start is already out of bounds</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// normal case</span></span><br><span class="line">            reverse(arr, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Better-Logic-With-For-Loop"><a href="#2-Better-Logic-With-For-Loop" class="headerlink" title="2.Better Logic With For Loop"></a>2.Better Logic With For Loop</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="comment">// The step is 2 * k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="comment">// normal case</span></span><br><span class="line">        <span class="keyword">if</span> (i + k &lt;= arr.length) &#123;</span><br><span class="line">            reverse(arr, i, i + k -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// end case</span></span><br><span class="line">        reverse(arr, i, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Offer-05-Replace-Space"><a href="#Offer-05-Replace-Space" class="headerlink" title="Offer 05. Replace Space"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">Offer 05. Replace Space</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given String s. Replace all space in s with “%20”;</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal-1"><a href="#1-Normal-1" class="headerlink" title="1. Normal"></a>1. Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// Introduce a pointer and do the iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pointer &lt;= s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(pointer) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(s.charAt(pointer));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Two-Pointer"><a href="#Two-Pointer" class="headerlink" title="Two_Pointer"></a>Two_Pointer</h4><p>It is an extreme solution while dealing with continuous data structure by adopting two pointer to do the filling and covering.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// We go extreme and just need an array of precise size after counting space first</span></span><br><span class="line">    <span class="comment">// Then we adopt two pointer to fill the array</span></span><br><span class="line">    <span class="comment">// The key pointer here is that while filling, we go from end to start</span></span><br><span class="line">    <span class="comment">//  so that covering is acceptable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123; <span class="comment">// defense</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count space and expand the array in the future</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// we will spare three char for replacement</span></span><br><span class="line">            sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if there is no space, just return</span></span><br><span class="line">    <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// we define two pointers</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// s will be expanded and right will start form the new end;</span></span><br><span class="line">    s += sb.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// when we meet space</span></span><br><span class="line">        <span class="keyword">if</span> (chars[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            chars[right] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chars[right] = chars[left];</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></h4><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given an input string s, reverse the order of the words.</p>
<p>A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.</p>
<p>Return a string of the words in reverse order concatenated by a single space.</p>
<p>Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Divide-And-Conquer"><a href="#1-Two-Pointer-Divide-And-Conquer" class="headerlink" title="1.Two_Pointer + Divide_And_Conquer"></a>1.Two_Pointer + Divide_And_Conquer</h4><p>This is a complicated question. The hardest point is to think of the method that firstly reverse all the string and then reverse each word, but that just works.</p>
<p>Another hardship is to think of an efficient way to eliminate all extra spaces. Two pointer works in this situation.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * Two Pointer</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// Suppose s = &quot;We are   happy &quot;</span></span><br><span class="line">    <span class="comment">// 1.First we eliminate all extra space</span></span><br><span class="line">    <span class="comment">//      s = &quot;We are happy&quot;</span></span><br><span class="line">    <span class="comment">// 2.Then we can reverse all the string</span></span><br><span class="line">    <span class="comment">//      s = &quot;yppah era eW&quot;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we reverse each word</span></span><br><span class="line">    <span class="comment">//      s = &quot;happy are We&quot;</span></span><br><span class="line">    <span class="comment">// The second part to reverse all the string is the hardest to think of</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] chars = removeExtraSpace(s);</span><br><span class="line">    reverseString(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> reverseEachWord(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Divide And Conquer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] removeExtraSpace(String s) &#123;</span><br><span class="line">    <span class="comment">// We adopt start and end to eliminate space from both ends</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// eliminate space at head</span></span><br><span class="line">    <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eliminate space at tail</span></span><br><span class="line">    <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We do an iteration of s and append what we need</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// Pay attention to the latter condition which is harder to think of</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(s.charAt(start));</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().toCharArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[start];</span><br><span class="line">        chars[start] = chars[end];</span><br><span class="line">        chars[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; chars.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[end] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">// pay attention to the time when end reaches end.</span></span><br><span class="line">            <span class="comment">// We will reverse the word in this loop otherwise the last word would be missed</span></span><br><span class="line">            <span class="keyword">if</span> (end == chars.length) &#123;</span><br><span class="line">                reverseString(chars, start, end - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[end] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            reverseString(chars, start, end - <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">            start = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Offer-58-II-Reverse-Left-Words"><a href="#Offer-58-II-Reverse-Left-Words" class="headerlink" title="Offer 58 - II. Reverse Left Words"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">Offer 58 - II. Reverse Left Words</a></h2><h3 id="Intro-4"><a href="#Intro-4" class="headerlink" title="Intro"></a>Intro</h3><p>Left reverse of string means moving the first kth character to the tail of string.</p>
<p>For example, string s &#x3D; “abcdefg” and k &#x3D; 2. By left rotating we get “cdefgab”</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Divide-And-Conquer"><a href="#1-Divide-And-Conquer" class="headerlink" title="1.Divide_And_Conquer"></a>1.Divide_And_Conquer</h4><p>Similar to the previous one, we can also adopt “First All Then Part” philosophy.</p>
<p>Take string s &#x3D; “abcdefg” and k &#x3D; 2 as an example.</p>
<ol>
<li>We firstly reverse all and get <ul>
<li>g f e d c b a</li>
</ul>
</li>
<li>We then reverse the last kth character and get<ul>
<li>g f e d c a b</li>
</ul>
</li>
<li>We finally reverse the first (s.length - k)th character and get<ul>
<li>c d e f g a b</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Divide And Conquer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// We stick to &quot;First All Then Part&quot; philosophy</span></span><br><span class="line">    <span class="comment">// suppose s = &quot;abcdefg&quot; and n = 2</span></span><br><span class="line">    <span class="comment">// 1. We firstly reverse all and get</span></span><br><span class="line">    <span class="comment">//      g f e d c b a</span></span><br><span class="line">    <span class="comment">// 2. We then reverse the last kth charater and get</span></span><br><span class="line">    <span class="comment">//      g f e d c a b</span></span><br><span class="line">    <span class="comment">// 3. We finally reverse the fisrt (s.lenghth - k)th character and get</span></span><br><span class="line">    <span class="comment">//      c d e f g a b</span></span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 1. reverse all</span></span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. reverse the last kth</span></span><br><span class="line">    reverse(chars, chars.length -  n , chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. reverse  the first (s.length - k)th</span></span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[start];</span><br><span class="line">        chars[start] = chars[end];</span><br><span class="line">        chars[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>String</tag>
        <tag>Divide_And_Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>Day10 Stack And Queue Part01</title>
    <url>/2023/04/28/Day10-Stack-And-Queue-Part01/</url>
    <content><![CDATA[<h2 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).</p>
<p>Implement the MyQueue class:</p>
<ul>
<li><p>void push(int x) Pushes element x to the back of the queue.</p>
</li>
<li><p>int pop() Removes the element from the front of the queue and returns it.</p>
</li>
<li><p>int peek() Returns the element at the front of the queue.</p>
</li>
<li><p>boolean empty() Returns true if the queue is empty, false otherwise.</p>
</li>
</ul>
<p>Notes:</p>
<ul>
<li><p>You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid.</p>
</li>
<li><p>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</p>
</li>
</ul>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Suppose we have got 1 2 3 element</span></span><br><span class="line">    <span class="comment">// 1.If it is put, we directly put element in stackIn</span></span><br><span class="line">    <span class="comment">//      stackIn     3 2 1</span></span><br><span class="line">    <span class="comment">//      stackOut    null</span></span><br><span class="line">    <span class="comment">// 2.If we want to pop, there will be two cases</span></span><br><span class="line">    <span class="comment">//      2.1.stackOut is null</span></span><br><span class="line">    <span class="comment">//              stackIn     3 2 1</span></span><br><span class="line">    <span class="comment">//              stackOut    null</span></span><br><span class="line">    <span class="comment">//          2.1.1.We transfer all elements in stackIn to stackOut</span></span><br><span class="line">    <span class="comment">//              stackIn     null</span></span><br><span class="line">    <span class="comment">//              stackOut    1 2 3</span></span><br><span class="line">    <span class="comment">//          2.1.2.We pop element from stackOut and get 1</span></span><br><span class="line">    <span class="comment">//              stackIn     null</span></span><br><span class="line">    <span class="comment">//              stackOut    2 3</span></span><br><span class="line">    <span class="comment">//      2.2.stack out is not null</span></span><br><span class="line">    <span class="comment">//              stackIn     6 5 4</span></span><br><span class="line">    <span class="comment">//              stackOut    2 3</span></span><br><span class="line">    <span class="comment">//          2.2.1.We directly pop element from stackOut and get 2</span></span><br><span class="line">    <span class="comment">//              stackIn     null</span></span><br><span class="line">    <span class="comment">//              stackOut    3</span></span><br><span class="line">    <span class="comment">// 3.If we want to peek, it is similar to pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        fillStackOutIfStackOutIsEmpty();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        fillStackOutIfStackOutIsEmpty();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Because we use this function twice, we make it a function</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillStackOutIfStackOutIsEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).</p>
<p>Implement the MyStack class:</p>
<p>- </p>
<p>  void push(int x) Pushes element x to the top of the stack.</p>
<p>- </p>
<p>  int pop() Removes the element on the top of the stack and returns it.</p>
<p>  -int top() Returns the element on the top of the stack.</p>
<p>  -boolean empty() Returns true if the stack is empty, false otherwise.</p>
<p>Notes:</p>
<p>- </p>
<p>  You must use only standard operations of a queue, which means that only push to back, peek&#x2F;pop from front, size and is empty operations are valid.</p>
<p>- </p>
<p>  Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Queues"><a href="#1-Two-Queues" class="headerlink" title="1.Two_Queues"></a>1.Two_Queues</h4><p>This algorithm uses two queues and queue2 is used for just back up.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue2 is actually a backup queue</span></span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue1.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">popped</span> <span class="operator">=</span> popTheLastElementFromQueue1AndPutOthersInQueue2();</span><br><span class="line">        returnQueue2ToQueue1();</span><br><span class="line">        <span class="keyword">return</span> popped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">topped</span> <span class="operator">=</span> popTheLastElementFromQueue1AndPutOthersInQueue2();</span><br><span class="line">        queue2.offer(topped);</span><br><span class="line">        returnQueue2ToQueue1();</span><br><span class="line">        <span class="keyword">return</span> topped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">returnQueue2ToQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue2.isEmpty()) &#123;</span><br><span class="line">            queue1.offer(queue2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">popTheLastElementFromQueue1AndPutOthersInQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            ans = queue1.poll();</span><br><span class="line">            <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">                queue2.offer(ans);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-One-Queue"><a href="#2-One-Queue" class="headerlink" title="2.One_Queue"></a>2.One_Queue</h4><p>We pop elements and put it back until we come to the the last element.</p>
<p>The question then comes to how we can know if it is the last element.</p>
<p>We can do so by declaring a size field.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * One Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> popTheLastElementAndPutOtherElementsInQueue();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> popTheLastElementAndPutOtherElementsInQueue();</span><br><span class="line">        size--;</span><br><span class="line">        push(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">popTheLastElementAndPutOtherElementsInQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (tempSize != <span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">            tempSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Day09 String Part02</title>
    <url>/2023/04/27/Day09-String-Part02/</url>
    <content><![CDATA[<h2 id="28-Find-the-Index-of-the-First-Occurrence-in-a-String"><a href="#28-Find-the-Index-of-the-First-Occurrence-in-a-String" class="headerlink" title="28. Find the Index of the First Occurrence in a String"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. Find the Index of the First Occurrence in a String</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Sliding-Window"><a href="#1-Sliding-Window" class="headerlink" title="1.Sliding_Window"></a>1.Sliding_Window</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sliding Window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() &gt; haystack.length()) &#123; <span class="comment">// defense</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// declare two points to make sliding window</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">    <span class="keyword">for</span> (; left &lt; haystack.length(); left++) &#123;</span><br><span class="line">        right = left;</span><br><span class="line">        <span class="comment">// pay attention to the boarder issue, especially the latter one</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &lt; needle.length() &amp;&amp; right &lt; haystack.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">needleChar</span> <span class="operator">=</span> needle.charAt(right - left);</span><br><span class="line">            <span class="type">char</span> <span class="variable">haystackChar</span> <span class="operator">=</span> haystack.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (needleChar == haystackChar) &#123;</span><br><span class="line">                <span class="comment">// When the length reaches needle&#x27;s length, we will return</span></span><br><span class="line">                <span class="keyword">if</span> (right - left == needle.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// move right to make the window</span></span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-KMP"><a href="#2-KMP" class="headerlink" title="2.KMP"></a>2.KMP</h4><p>This is the first time we touch KMP.</p>
<p>The principle behind is quite hard for me to understand.</p>
<p>What I know for now is the existence of the next array that records the biggest public prefix, which is useful to trace the very first element that does not pair with the needle.</p>
<p>Therefore, I will put the code here but honestly speaking, I do not master this algorithm.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">    getNextArray(next, needle);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i))</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (needle.charAt(j) == haystack.charAt(i))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length())</span><br><span class="line">            <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNextArray</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">    <span class="comment">// next array is the array that records the biggest public prefix</span></span><br><span class="line">    <span class="comment">// suppose string s = &quot;abcbabef&quot;</span></span><br><span class="line">    <span class="comment">// its next array would be</span></span><br><span class="line">    <span class="comment">//      0	0	0	0	1	2	0	0</span></span><br><span class="line">    <span class="comment">// suppose string s = &quot;aabaaf&quot;</span></span><br><span class="line">    <span class="comment">// its next array would be</span></span><br><span class="line">    <span class="comment">//      0   1   0   1   2   0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Sliding_Window</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Day13 Stack And Queue Part03</title>
    <url>/2023/05/01/Day13-Stack-And-Queue-Part03/</url>
    <content><![CDATA[<h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return the max sliding window.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Monotonic-Queue"><a href="#1-Monotonic-Queue" class="headerlink" title="1.Monotonic_Queue"></a>1.Monotonic_Queue</h4><p>We can adopt monotonic queue to maintain only the necessary element, namely, the element that might be the maximum number in the self-designed two-sided queue.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Monotonic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// We can adopt monotonic queue to solve this question</span></span><br><span class="line">    <span class="comment">// Suppose nums = &#123;1,3,-1,-3,5,3,6,7&#125;, k = 3</span></span><br><span class="line">    <span class="comment">//      1   3   -1  -3  5   3   6   6</span></span><br><span class="line">    <span class="comment">// 0    l       r</span></span><br><span class="line">    <span class="comment">// 0 1: 1</span></span><br><span class="line">    <span class="comment">// 0 1: We push left element</span></span><br><span class="line">    <span class="comment">// 0 2: 3</span></span><br><span class="line">    <span class="comment">// 0 2: Since 3 is bigger than 1, we can just pop 1 because it is pointless to maintain it</span></span><br><span class="line">    <span class="comment">// 0 3: 3   -1</span></span><br><span class="line">    <span class="comment">// 0 3: We push -1 because it is smaller than 3</span></span><br><span class="line">    <span class="comment">//      1   3   -1  -3  5   3   6   6</span></span><br><span class="line">    <span class="comment">// 1        l       r</span></span><br><span class="line">    <span class="comment">// 1 1: 3   -1  -3</span></span><br><span class="line">    <span class="comment">// 1 1: We must pop 1 if following the requirement but actually 1 has already been popped</span></span><br><span class="line">    <span class="comment">// and the element 1 that should have been popped is not the current max value, so no</span></span><br><span class="line">    <span class="comment">// other action except push -3 that is smaller than 3 should be carried out</span></span><br><span class="line">    <span class="comment">//      1   3   -1  -3  5   3   6   6</span></span><br><span class="line">    <span class="comment">// 2            l       r</span></span><br><span class="line">    <span class="comment">// 2 1: -1  -3</span></span><br><span class="line">    <span class="comment">// 2 1: We must pop 3 according to the requirement, and it is just the biggest element, so</span></span><br><span class="line">    <span class="comment">// it would be popped from our queue</span></span><br><span class="line">    <span class="comment">// 2 2: -1  -3  5</span></span><br><span class="line">    <span class="comment">// 2 2: We push 5 into the queue</span></span><br><span class="line">    <span class="comment">// 2 3: 5</span></span><br><span class="line">    <span class="comment">// 2 3: Since 5 is the biggest element, all elements before it would be popped.</span></span><br><span class="line">    <span class="comment">// This is how our queue works</span></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left + k - <span class="number">1</span>&lt; nums.length; left++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            myQueue.pop(nums[left - <span class="number">1</span>]);</span><br><span class="line">            myQueue.push(nums[right]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                myQueue.push(nums[left + i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> myQueue.getMax();</span><br><span class="line">        ans[left] = maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">// Deque is a two-sided queue which is the only solution while pushing</span></span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We must keep it monotonic, so while pushing, we would remove all elements that are</span></span><br><span class="line">    <span class="comment">// smaller than the to-be pushed one from, quite importantly speaking, from tail</span></span><br><span class="line">    <span class="comment">// For example</span></span><br><span class="line">    <span class="comment">//      3   -1</span></span><br><span class="line">    <span class="comment">// And 2 is to be pushed</span></span><br><span class="line">    <span class="comment">// We must remove -1, so the result would be</span></span><br><span class="line">    <span class="comment">//      3   2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.getLast() &lt; x) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only when the to-be popped element equal the first element will we pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.getFirst() == x) &#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Min-Heap"><a href="#1-Min-Heap" class="headerlink" title="1. Min Heap"></a>1. Min Heap</h4><p>We can rely on the data structure, min heap, to solve this question because this kind of structure is quite good at collecting the extreme number among a lot of numbers through its top, where the extreme number, the smallest one if it is min heap and the biggest one if it is max heap is stored.</p>
<p><a href="https://postimg.cc/gLKtxdCb"><img src="https://i.postimg.cc/tJKKm4DJ/Day12-Stack-And-Queue-Part03-01.jpg" alt="Day12-Stack-And-Queue-Part03-01.jpg"></a><br>    min heap</p>
<p>One question which arises is why we use min heap rather than max heap in this question. That is because the min heap stores the element with the lowest frequency on its top and we can pop the top element if the heap’s size surpasses k, which is the size of to-be-returned array, leaving elements with the highest frequency at last.</p>
<p>Another question is how we can realize min heap in java. The answer is priority queue, but we must realize its comparator in this question.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Min Heap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 1.We first iterate nums and get the hashmap that records frequency of each element</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">            map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.We rely on min heap in this question and the realization of it in java is</span></span><br><span class="line">    <span class="comment">//  priority queue</span></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// It should be a min heap, which means the smallest one should be on the top</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getValue() - o2.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.We then iterate map and put element in the priorityQueue</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        priorityQueue.offer(entry);</span><br><span class="line">        <span class="comment">// If the size of priorityQueue is bigger than k, it means we should remove the top element,</span></span><br><span class="line">        <span class="comment">// which is the current number with the lowest frequency</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &gt; k) &#123;</span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.We finally fill the array</span></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="comment">// 5.Although the question does not ask for return the array in desc order, we can do so</span></span><br><span class="line">    <span class="comment">// by iterating from end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ans[i] = priorityQueue.poll().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Monotonic</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Day11 Stack And Queue Part02</title>
    <url>/2023/04/29/Day11-Stack-And-Queue-Part02/</url>
    <content><![CDATA[<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. Valid Parentheses</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li><p>Open brackets must be closed by the same type of brackets.</p>
</li>
<li><p>Open brackets must be closed in the correct order.</p>
</li>
<li><p>Every close bracket has a corresponding open bracket of the same type.</p>
</li>
</ol>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Stack"><a href="#1-Stack" class="headerlink" title="1.Stack"></a>1.Stack</h4><p>Use stack to solve this question</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// Deque is better than Stack</span></span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// push if it is left</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != s.charAt(i)) &#123;</span><br><span class="line">            <span class="comment">// This is the case when it is right element</span></span><br><span class="line">            <span class="comment">// But either the stack is already empty or element on the top is not the right one</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is the case when everything is fine</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// In the last case where the iteration is over but stack is not empty, return false</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.</p>
<p>We repeatedly make duplicate removals on s until we no longer can.</p>
<p>Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Stack-1"><a href="#1-Stack-1" class="headerlink" title="1.Stack"></a>1.Stack</h4><p>Use stack to solve this question</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != c) &#123;</span><br><span class="line">            <span class="comment">// Two cases when we can push element</span></span><br><span class="line">            <span class="comment">// 1. stack is empty</span></span><br><span class="line">            <span class="comment">// 2. the element on the top is not c</span></span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// In the case when element ont the top is c</span></span><br><span class="line">            <span class="comment">// we pop</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// pay attention to the sequence since it is stack</span></span><br><span class="line">        str = stack.pop() + str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two_Pointer"></a>2.Two_Pointer</h4><p>We can use two pointer to simulate stack.</p>
<p>The point is to replace chars[slow] with chars[fast]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// We can use two pointer to simulate stack</span></span><br><span class="line">    <span class="comment">//      a   a   b   b   c</span></span><br><span class="line">    <span class="comment">// 0    s/f</span></span><br><span class="line">    <span class="comment">// 1        s/f</span></span><br><span class="line">    <span class="comment">// 2    s       f</span></span><br><span class="line">    <span class="comment">// 3        s       f</span></span><br><span class="line">    <span class="comment">// 4    s               f</span></span><br><span class="line">    <span class="comment">// char[s] would be replaced with char[fast]</span></span><br><span class="line">    <span class="comment">// what is finally returned would be 0 - slow</span></span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// replace chars[slow] with chars[fast]</span></span><br><span class="line">        chars[slow] = chars[fast];</span><br><span class="line">        <span class="comment">// judge if it is adjacent</span></span><br><span class="line">        <span class="keyword">if</span> (slow &gt; <span class="number">0</span> &amp;&amp; chars[slow] == chars[slow - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// it is adjacent, so slow moves back</span></span><br><span class="line">            slow--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// it is not adjacent, so slow moves forward</span></span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, slow);</span><br><span class="line">&#125; 	</span><br></pre></td></tr></table></figure>

<h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.</p>
<p>Evaluate the expression. Return an integer that represents the value of the expression.</p>
<p>Note that:</p>
<ul>
<li><p>The valid operators are ‘+’, ‘-‘, ‘*’, and ‘&#x2F;‘.</p>
</li>
<li><p>Each operand may be an integer or another expression.</p>
</li>
<li><p>The division between two integers always truncates toward zero.</p>
</li>
<li><p>There will not be any division by zero.</p>
</li>
<li><p>The input represents a valid arithmetic expression in a reverse polish notation.</p>
</li>
<li><p>The answer and all the intermediate calculations can be represented in a 32-bit integer.</p>
</li>
</ul>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Stack-2"><a href="#1-Stack-2" class="headerlink" title="1.Stack"></a>1.Stack</h4><p>Reverse Polish Notation is a reflection of how computer works</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    <span class="comment">// Use Deque&lt;Integer&gt; rather than Deque&lt;String&gt;</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(-stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(stack.pop() * stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">divider</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">divided</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            stack.push(divided / divider);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(Integer.valueOf(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Day14 Binary Tree Part01</title>
    <url>/2023/05/02/Day14-Binary-Tree-Part01/</url>
    <content><![CDATA[<h2 id="Binary-Tree-Concept"><a href="#Binary-Tree-Concept" class="headerlink" title="Binary Tree Concept"></a>Binary Tree Concept</h2><h3 id="1-Perfect-Binary-Tree-amp-Complete-Binary-Tree"><a href="#1-Perfect-Binary-Tree-amp-Complete-Binary-Tree" class="headerlink" title="1.Perfect Binary Tree &amp; Complete Binary Tree"></a>1.Perfect Binary Tree &amp; Complete Binary Tree</h3><h4 id="1-1-Perfect-Binary-Tree"><a href="#1-1-Perfect-Binary-Tree" class="headerlink" title="1.1.Perfect Binary Tree"></a>1.1.Perfect Binary Tree</h4><p>The degree of its nodes is either 2 or 0(for nodes that are at bottom)</p>
<p><a href="https://postimg.cc/3k9bpbTH"><img src="https://i.postimg.cc/7LyvFptb/Day-14-Binary-Tree-Part01-01.jpg" alt="Day-14-Binary-Tree-Part01-01.jpg"></a></p>
<span id="more"></span>

<h4 id="1-2-Complete-Binary-Tree"><a href="#1-2-Complete-Binary-Tree" class="headerlink" title="1.2.Complete Binary Tree"></a>1.2.Complete Binary Tree</h4><p>Except for the bottom layer, all other layers should be filled with nodes in maximum number. And as for the bottom layer, nodes can only be filled in the order from left to right. If there is a node at bottom with its left-sided node empty, this tree would not be complete binary tree.</p>
<p><a href="https://postimg.cc/rRm5BgH5"><img src="https://i.postimg.cc/T1jQW4qN/Day-14-Binary-Tree-Part01-02.jpg" alt="Day-14-Binary-Tree-Part01-02.jpg"></a></p>
<h3 id="2-Binary-Search-Tree"><a href="#2-Binary-Search-Tree" class="headerlink" title="2.Binary Search Tree"></a>2.Binary Search Tree</h3><h4 id="2-1-Binary-Search-Tree"><a href="#2-1-Binary-Search-Tree" class="headerlink" title="2.1.Binary Search Tree"></a>2.1.Binary Search Tree</h4><p>Binary search tree is a tree with order.</p>
<ul>
<li>If one node has left subtree, then all nodes from this subtree is smaller than this node.</li>
<li>If one node has right subtree, then all nodes from this subtree is bigger than this node.</li>
<li>The left subtree and the right subtree of one node is also binary search tree.</li>
</ul>
<p> &#x2F;** * Min Heap *&#x2F;public int[] topKFrequent(int[] nums, int k) {    &#x2F;&#x2F; 1.We first iterate nums and get the hashmap that records frequency of each element    HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();    for (int i &#x3D; 0; i &lt; nums.length; i++) {        if (map.containsKey(nums[i])) {            map.put(nums[i], map.get(nums[i]) + 1);        } else {            map.put(nums[i], 1);        }    }    &#x2F;&#x2F; 2.We rely on min heap in this question and the realization of it in java is    &#x2F;&#x2F;  priority queue    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {        @Override        &#x2F;&#x2F; It should be a min heap, which means the smallest one should be on the top        public int compare(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2) {            return o1.getValue() - o2.getValue();        }    });    &#x2F;&#x2F; 3.We then iterate map and put element in the priorityQueue    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {        priorityQueue.offer(entry);        &#x2F;&#x2F; If the size of priorityQueue is bigger than k, it means we should remove the top element,        &#x2F;&#x2F; which is the current number with the lowest frequency        if (priorityQueue.size() &gt; k) {            priorityQueue.poll();        }    }    &#x2F;&#x2F; 4.We finally fill the array    int[] ans &#x3D; new int[k];    &#x2F;&#x2F; 5.Although the question does not ask for return the array in desc order, we can do so    &#x2F;&#x2F; by iterating from end    for (int i &#x3D; k - 1; i &gt;&#x3D; 0; i–) {        ans[i] &#x3D; priorityQueue.poll().getKey();    }    return ans;}java</p>
<h4 id="2-2-AVL-Tree"><a href="#2-2-AVL-Tree" class="headerlink" title="2.2.AVL Tree"></a>2.2.AVL Tree</h4><p>AVL tree is a special search tree.</p>
<ul>
<li>It can be an empty tree</li>
<li>Or if is not empty, the absolute height difference of the left subtree and the right one from the root should not surpass 1.</li>
<li>Both its left and right subtree are AVL trees.</li>
</ul>
<p><a href="https://postimg.cc/4mZF2hsP"><img src="https://i.postimg.cc/vH6FBWKJ/Day-14-Binary-Tree-Part01-04.jpg" alt="Day-14-Binary-Tree-Part01-04.jpg"></a></p>
<h3 id="3-The-Implementation-of-Binary-Tree"><a href="#3-The-Implementation-of-Binary-Tree" class="headerlink" title="3.The Implementation of Binary Tree"></a>3.The Implementation of Binary Tree</h3><h4 id="3-1-Linked-List"><a href="#3-1-Linked-List" class="headerlink" title="3.1.Linked List"></a>3.1.Linked List</h4><p>We can implement binary tree through linked list that has fields of left son node and right son node, which is easy to understand.</p>
<h4 id="3-2-Array"><a href="#3-2-Array" class="headerlink" title="3.2.Array"></a>3.2.Array</h4><p>We can also use array to implement binary tree.</p>
<p>If the index of the node is i, then its left son has the index of (i * 2 + 1) and its right son (i * 2 + 2)</p>
<p><a href="https://postimg.cc/5QMYSJc7"><img src="https://i.postimg.cc/C5RGYMcg/Day-14-Binary-Tree-Part01-05.jpg" alt="Day-14-Binary-Tree-Part01-05.jpg"></a></p>
<h3 id="4-The-Iteration-of-Binary-Tree"><a href="#4-The-Iteration-of-Binary-Tree" class="headerlink" title="4.The Iteration of Binary Tree"></a>4.The Iteration of Binary Tree</h3><h4 id="4-1-DFS"><a href="#4-1-DFS" class="headerlink" title="4.1.DFS"></a>4.1.DFS</h4><p>Understand all three methods by the position of root.</p>
<h5 id="4-1-1-PreOrder"><a href="#4-1-1-PreOrder" class="headerlink" title="4.1.1.PreOrder"></a>4.1.1.PreOrder</h5><p>Root at head</p>
<p><a href="https://postimg.cc/2LhzTLdh"><img src="https://i.postimg.cc/fygJzxJ2/Day-14-Binary-Tree-Part01-06.jpg" alt="Day-14-Binary-Tree-Part01-06.jpg"></a></p>
<h5 id="4-1-2-InOrder"><a href="#4-1-2-InOrder" class="headerlink" title="4.1.2.InOrder"></a>4.1.2.InOrder</h5><p>Root at middle</p>
<p><a href="https://postimg.cc/mtWZkVRw"><img src="https://i.postimg.cc/pXpm016g/Day-14-Binary-Tree-Part01-07.jpg" alt="Day-14-Binary-Tree-Part01-07.jpg"></a></p>
<h5 id="4-1-3PostOrder"><a href="#4-1-3PostOrder" class="headerlink" title="4.1.3PostOrder"></a>4.1.3PostOrder</h5><p>Root at end</p>
<p><a href="https://postimg.cc/xqzT9Br8"><img src="https://i.postimg.cc/v8P1td3r/Day-14-Binary-Tree-Part01-08.jpg" alt="Day-14-Binary-Tree-Part01-08.jpg"></a></p>
<h4 id="4-2-BFS"><a href="#4-2-BFS" class="headerlink" title="4.2.BFS"></a>4.2.BFS</h4><p>By layer</p>
<h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the preorder traversal of its nodes’ values.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion"><a href="#1-Recursion" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>We can follow three rules while writing recursion</p>
<ol>
<li>Confirm the params and returned value of recursion function</li>
<li>Confirm the end condition, otherwise there might be stack overflow</li>
<li>Confirm the logic of single layer of recursion</li>
</ol>
<p>As for preorder traversal, we can realize three rules</p>
<ol>
<li><p>The params should be the current node and the container that stores the result</p>
<ul>
<li>void preorder(Treenode root, List<Integer> list)</li>
</ul>
</li>
<li><p>The end condition should be when the current root is null, which means it is time to return</p>
<ul>
<li>if (root &#x3D;&#x3D; null) {return}</li>
</ul>
</li>
<li><p>The logic of single layer is to firstly store the root, then do recursion of its left, and at last do recursion of its right</p>
<ul>
<li>list.add(root.value);</li>
<li>preorder(root.left, list);</li>
<li>preorder(root.right, list);</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    preorder(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preorder(root.left, list);</span><br><span class="line">    preorder(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Stack"><a href="#2-Stack" class="headerlink" title="2.Stack"></a>2.Stack</h4><p>We can also use a stack to do the iteration rather than recursion</p>
<p>For example, if a tree is </p>
<p>​		5</p>
<p>​	4	6</p>
<p>1	2</p>
<p>We use a stack to iterate</p>
<ol>
<li>stack: 5 <ul>
<li>then 5 is popped and added to list</li>
<li>list: 5</li>
</ul>
</li>
<li>stack: 6<ul>
<li>We first put the right son of 5 because it is stack and what is pushed first gets popped last</li>
</ul>
</li>
<li>stack: 6 4<ul>
<li>We then put the left son of 5</li>
</ul>
</li>
<li>stack: 6<ul>
<li>4 gets popped out and added to list</li>
<li>list: 5 4</li>
</ul>
</li>
<li>stack: 6 2<ul>
<li>The right son of 4 gets pushed in</li>
</ul>
</li>
<li>stack: 6 2 1<ul>
<li>The left son of 4 gets pushed in</li>
</ul>
</li>
<li>stack: 6 2<ul>
<li>1 gets popped out and added to list</li>
<li>list: 5 4 1</li>
</ul>
</li>
<li>stack: 6<ul>
<li>2 gets popped out and added to list</li>
<li>list: 5 4 1 2</li>
</ul>
</li>
<li>stack: <ul>
<li>6 gets popped out and added to list</li>
<li>list: 5 4 1 2 6</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// Put the root in stack so that iteration can begin</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// We must pay attention to the order of pushing</span></span><br><span class="line">        <span class="comment">// Since it is preorder, the order would be to root, root.left and root.right</span></span><br><span class="line">        <span class="comment">// But for stack, the popped out element would be the last element pushed</span></span><br><span class="line">        <span class="comment">// So the push order should be opposite to the preorder order, which means</span></span><br><span class="line">        <span class="comment">// we should push right first, then left</span></span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. Binary Tree Postorder Traversal</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the postorder traversal of its nodes’ values.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-1"><a href="#1-Recursion-1" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>As for postorder traversal, we can realize three rules</p>
<ol>
<li><p>The params should be the current node and the container that stores the result</p>
<ul>
<li>void preorder(Treenode root, List<Integer> list)</li>
</ul>
</li>
<li><p>The end condition should be when the current root is null, which means it is time to return</p>
<ul>
<li>if (root &#x3D;&#x3D; null) {return}</li>
</ul>
</li>
<li><p>The logic of single layer is to firstly do recursion of its left, then do recursion of its right, and at last store root’s value</p>
<ul>
<li><p>preorder(root.left, list);</p>
</li>
<li><p>preorder(root.right, list);</p>
</li>
<li><p>list.add(root.value);</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    postorder(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root.left, list);</span><br><span class="line">    postorder(root.right, list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Stack-1"><a href="#2-Stack-1" class="headerlink" title="2.Stack"></a>2.Stack</h4><p>Postorder can be modified from preorder since the order of postorder, which is left, right, root, can be achieved by firstly swapping the order of left and right from preorder followed by reversing the result list.</p>
<p>For example, if a tree is </p>
<p>​		5</p>
<p>​	4	6</p>
<p>1	2</p>
<p>We use a stack to iterate</p>
<ol>
<li><p>stack: 5 </p>
<ul>
<li>then 5 is popped and added to list</li>
<li>list: 5</li>
</ul>
</li>
<li><p>stack: 4</p>
<ul>
<li>We first put the left son of 5 because it is stack and what is pushed first gets popped last</li>
</ul>
</li>
<li><p>stack: 4 6</p>
<ul>
<li>We then put the right son of 5</li>
</ul>
</li>
<li><p>stack: 4</p>
<ul>
<li>6 gets popped out and added to list</li>
<li>list: 5 6</li>
</ul>
</li>
<li><p>stack: 1</p>
<ul>
<li>4 gets popped and added to list</li>
<li>The left son of 4 gets pushed in</li>
<li>list: 5 6 4</li>
</ul>
</li>
<li><p>stack: 1 2</p>
<ul>
<li>The right son of 4 gets pushed in</li>
</ul>
</li>
<li><p>stack: 1</p>
<ul>
<li>2 gets popped out and added to list</li>
<li>list: 5 6 4 2</li>
</ul>
</li>
<li><p>stack: </p>
<ul>
<li>1 gets popped out and added to list</li>
<li>list: 5 6 4 2 1</li>
</ul>
</li>
<li><p>We finally reverse the list and get what we want</p>
<ul>
<li>list: 1 2 4 6 5</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// Put the root in stack so that iteration can begin</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// We must pay attention to the order of pushing</span></span><br><span class="line">        <span class="comment">// Since it is postorder, the order would be to root.left, root.right and root</span></span><br><span class="line">        <span class="comment">// But for stack, the popped out element would be the last element pushed</span></span><br><span class="line">        <span class="comment">// So the push order should be opposite to the preorder order, which means</span></span><br><span class="line">        <span class="comment">// we should push left first, then right</span></span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Since postorder is modified from preorder, we have to reverse the list at last.</span></span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the inorder traversal of its nodes’ values.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-2"><a href="#1-Recursion-2" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>As for inorder traversal, we can realize three rules</p>
<ol>
<li><p>The params should be the current node and the container that stores the result</p>
<ul>
<li>void preorder(Treenode root, List<Integer> list)</li>
</ul>
</li>
<li><p>The end condition should be when the current root is null, which means it is time to return</p>
<ul>
<li>if (root &#x3D;&#x3D; null) {return}</li>
</ul>
</li>
<li><p>The logic of single layer is to firstly do recursion of its left, then store root’s value, and at last do recursion of its right</p>
<ul>
<li><p>preorder(root.left, list);</p>
</li>
<li><p>list.add(root.value);</p>
</li>
<li><p>preorder(root.right, list);</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    inorder(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inorder(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Stack-2"><a href="#2-Stack-2" class="headerlink" title="2.Stack"></a>2.Stack</h4><p>Using stack to iterate tree in inorder is more difficult than previous two orders because the order of visiting each node and the order of dealing with each node is different. When we visit the root, we cannot add it in the result list until we visit the left node at bottom. To solve this problem, we can introduce a cursor that points to the node we visit.</p>
<p>For example, if a tree is </p>
<p>​		5</p>
<p>​	4	6</p>
<p>1	2</p>
<p>We use a stack and cursor to iterate</p>
<ol>
<li>stack: null<ul>
<li>cur &#x3D; 5</li>
</ul>
</li>
<li>stack: 5<ul>
<li>cur &#x3D; 5.left &#x3D; 4</li>
</ul>
</li>
<li>stack: 5 4<ul>
<li>cur &#x3D; 4.left &#x3D; 1</li>
</ul>
</li>
<li>stack: 5 4 1<ul>
<li>cur &#x3D; 1.left &#x3D; null</li>
</ul>
</li>
<li>stack: 5 4<ul>
<li>cur &#x3D; 1.right &#x3D; null</li>
<li>list: 1</li>
</ul>
</li>
<li>stack: 5<ul>
<li>cur &#x3D; 4.right &#x3D; 2</li>
<li>list: 1 4</li>
</ul>
</li>
<li>stack: 5 2<ul>
<li>cur &#x3D; 2.left &#x3D; null</li>
</ul>
</li>
<li>stack: 5<ul>
<li>cur &#x3D; 2.right &#x3D; null</li>
<li>list: 1 4 2</li>
</ul>
</li>
<li>stack: <ul>
<li>cur &#x3D; 5.right &#x3D; 6</li>
<li>list: 1 4 2 5</li>
</ul>
</li>
<li>stack: 6<ul>
<li>cur &#x3D; 6.left &#x3D; null</li>
</ul>
</li>
<li>stack:<ul>
<li>cur &#x3D; 6.right &#x3D; null</li>
<li>list: 1 4 2 5 6</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We need a cursor to track the node</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Stack</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day16 Binary Tree Part03</title>
    <url>/2023/05/04/Day16-Binary-Tree-Part03/</url>
    <content><![CDATA[<h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>It was written in day 15.</p>
<p>Check it out: <a href="https://zhaoyiwei0311.github.io/2023/05/03/Day15-Binary-Tree-Part02/">104. Maximum Depth of Binary Tree</a></p>
<h4 id="2-Recursion"><a href="#2-Recursion" class="headerlink" title="2.Recursion"></a>2.Recursion</h4><p>There is a difference between <strong>height</strong> and <strong>depth</strong>.</p>
<p>For height, it is counted from bottom to top, which means postorder is a good choice if we want to the height, since it starts from bottom and get returned to the node above, which is exactly the sequence of calculating height.</p>
<p>And as for depth, it is counted from top to bottom. So preorder would be an alternative since it starts from top and transfer the recursion to nodes below, which corresponds to the order of calculating depth.</p>
<p>For this question, we use postorder to track from bottom to top, which means we will actually return the height rather than depth. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// We use postorder and track from bottom to top</span></span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      int maxDepth(TreeNode root)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end condition</span></span><br><span class="line">    <span class="comment">//   We return when we get to null and the returned value should be 0</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, We confirm the logic</span></span><br><span class="line">    <span class="comment">//   Because it is postorder, we must follow the order of left, right and middle</span></span><br><span class="line">    <span class="comment">//      int leftHeight = maxDepth(root.left);</span></span><br><span class="line">    <span class="comment">//      int rightHeight = maxDepth(root.right);</span></span><br><span class="line">    <span class="comment">//      return Math.max(leftHeight, rightHeight);</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> maxDepth(root.left) + <span class="number">1</span>; <span class="comment">// left</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> maxDepth(root.right) + <span class="number">1</span>; <span class="comment">// right</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight); <span class="comment">// middle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given a n-ary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder"><a href="#1-Recursion-Postorder" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>Similar to the previous question.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      int maxDepth(Node root)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">//      if (root.children.size() == 0</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm logic</span></span><br><span class="line">    <span class="comment">// We do an iteration of loop and get the maxDepth just as it were a binary tree</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] childrenArr = <span class="keyword">new</span> <span class="title class_">int</span>[root.children.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.children.size(); i++) &#123;</span><br><span class="line">        childrenArr[i] = maxDepth(root.children.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> childrenArr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childrenArr.length; i++) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, childrenArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxHeight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><p>Much easier to understand</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; popped.children.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (popped.children.get(i) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(popped.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        maxDepth++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder-1"><a href="#1-Recursion-Postorder-1" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>It is far harder than maximum depth because leaf is quite a big trouble getting people easily confused with the concept of height.</p>
<p>For example, in the case below, we may get a wrong answer 1 rather than 3 because we do not really understand what leaf stands for. </p>
<p><a href="https://postimg.cc/CztnFpHt"><img src="https://i.postimg.cc/MpZ7mWcW/Day-16-Binary-Tree-Part03-01.jpg" alt="Day-16-Binary-Tree-Part03-01.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** The logic of this question is much harder than maximum depth because</span></span><br><span class="line"><span class="comment">     *  of the concept of leaf</span></span><br><span class="line"><span class="comment">     *  In the case of</span></span><br><span class="line"><span class="comment">     *              1</span></span><br><span class="line"><span class="comment">     *                  2</span></span><br><span class="line"><span class="comment">     *              3       4</span></span><br><span class="line"><span class="comment">     *          5</span></span><br><span class="line"><span class="comment">     *  The minimum depth should stop at 4</span></span><br><span class="line"><span class="comment">     *  But it is easy to get the answer 1</span></span><br><span class="line"><span class="comment">     *  because we may fail to take the null condition of both left and right sons</span></span><br><span class="line"><span class="comment">     *  into account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">    <span class="comment">// We must separately deal with the null situation</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// in this case, there are still leaves at right</span></span><br><span class="line">        <span class="keyword">return</span> leftDepth + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// in this case, there are still leaves at left</span></span><br><span class="line">        <span class="keyword">return</span> rightDepth + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// in this case, both sides have leaves</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(rightDepth, leftDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Layer-Traversal"><a href="#2-Layer-Traversal" class="headerlink" title="2.Layer Traversal"></a>2.Layer Traversal</h4><p>Layer search is still easier to understand.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// Similarly, the nearest leaf is when two sons are null</span></span><br><span class="line">            <span class="keyword">if</span> (popped != <span class="literal">null</span> &amp;&amp; (popped.left == <span class="literal">null</span> &amp;&amp; popped.right == <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pay attention to the null pointer exception</span></span><br><span class="line">            <span class="keyword">if</span> (popped != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        minDepth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a complete binary tree, return the number of the nodes in the tree.</p>
<p>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.</p>
<p>Design an algorithm that runs in less than O(n) time complexity.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal-Recursion-Postorder"><a href="#1-Normal-Recursion-Postorder" class="headerlink" title="1.Normal + Recursion + Postorder"></a>1.Normal + Recursion + Postorder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      int countNodes(TreeNode root)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end condition</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm logic</span></span><br><span class="line">    <span class="comment">//      int left = countNodes(root.left);</span></span><br><span class="line">    <span class="comment">//      int right = countNodes(root.right);</span></span><br><span class="line">    <span class="comment">//      return left + right + 1</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countNodes(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countNodes(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Layer-Traversal-1"><a href="#2-Layer-Traversal-1" class="headerlink" title="2. Layer Traversal"></a>2. Layer Traversal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        count += size;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Feature-Recursion-Postorder"><a href="#3-Feature-Recursion-Postorder" class="headerlink" title="3.Feature + Recursion + Postorder"></a>3.Feature + Recursion + Postorder</h4><p>We must understand what the complete binary tree is and learn the feature of it. <a href="https://zhaoyiwei0311.github.io/2023/05/02/Day14-Binary-Tree-Part01/">Complete Binary Tree</a></p>
<p>There are only two kinds of complete tree.</p>
<ol>
<li><a href="https://zhaoyiwei0311.github.io/2023/05/02/Day14-Binary-Tree-Part01/">Perfect Binary Tree</a> which is full.</li>
<li>Each layer except the bottom is filled full.</li>
</ol>
<p>For the first case, we just need to get its layer n and calculate (2 ^ n -1), which is the answer.</p>
<p>For the second case, we can rely on recursion and adopt the thought of conquering and divide to find the smallest perfect tree.</p>
<p><a href="https://postimg.cc/HJPq66T5"><img src="https://i.postimg.cc/QtXjxzP6/Day-16-Binary-Tree-Part03-02.jpg" alt="Day-16-Binary-Tree-Part03-02.jpg"></a></p>
<p>Another question arouses that how can we judge whether a tree is a perfect tree.</p>
<p>The answer is we can go deep through both leftmost and rightmost side and count their layers. If layer are same, then it is a perfect tree, otherwise, it is not.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Feature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.First confirm returned value and params</span></span><br><span class="line"><span class="comment">     *      int countNodes(TreeNode root)</span></span><br><span class="line"><span class="comment">     * 2.Then confirm end conditions</span></span><br><span class="line"><span class="comment">     *      if (root == null) &#123;return 0&#125;</span></span><br><span class="line"><span class="comment">     * 3.Finally, confirm logic</span></span><br><span class="line"><span class="comment">     *      3.1.We first need to confirm whether the tree in current recursion is a</span></span><br><span class="line"><span class="comment">     *          perfect tree</span></span><br><span class="line"><span class="comment">     *      3.2.If it is a perfect tree, then just calculate</span></span><br><span class="line"><span class="comment">     *      3.3.If it is not, then do the recursion by adopting divide and conquer thought</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftLayer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightLayer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftLayer++;</span><br><span class="line">        left = left.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightLayer++;</span><br><span class="line">        right = right.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftLayer == rightLayer) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(Math.pow(<span class="number">2</span>, leftLayer) - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.right) + countNodes(root.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Divide_And_Conquer</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day17 Binary Tree Part04</title>
    <url>/2023/05/05/Day17-Binary-Tree-Part04/</url>
    <content><![CDATA[<h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a binary tree, determine if it is <strong>height-balanced</strong>.</p>
<p>Height-balanced means the absolute height difference between left and right subtrees should not surpass 1.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder"><a href="#1-Recursion-Postorder" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>We will have to know the height of each subtree and compare them to get the height difference. In this case, we must use postorder since it can integrate the result form below and transfer the result to upper nodes.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> postorder(root);</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  We use postorder to track the height of subtree</span></span><br><span class="line">    <span class="comment">//      int postorder(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (node == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm logic</span></span><br><span class="line">    <span class="comment">//  if the height difference surpasses 1, then return -1</span></span><br><span class="line">    <span class="comment">//  else return bigger height + 1</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> postorder(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> postorder(node.right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span> || Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. Binary Tree Paths</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return all root-to-leaf paths in any order.</p>
<p>A leaf is a node with no children.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Preorder-Backtrack"><a href="#1-Recursion-Preorder-Backtrack" class="headerlink" title="1.Recursion + Preorder + Backtrack"></a>1.Recursion + Preorder + Backtrack</h4><p>This questions asks for backtrack.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Since string is hard to deal with, we can introduce an arraylist instead for help</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Integer&gt; container = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Preorder + Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.First We must confirm returned value and params</span></span><br><span class="line"><span class="comment">     *  We use outside variables, so it is</span></span><br><span class="line"><span class="comment">     *      void preorder(TreeNode node)</span></span><br><span class="line"><span class="comment">     * 2.Then we must confirm end conditions</span></span><br><span class="line"><span class="comment">     *  if node is null, we will absolutely return</span></span><br><span class="line"><span class="comment">     *  Besides, if node has no children, which means it is a leaf node, we will also</span></span><br><span class="line"><span class="comment">     *  return after manipulating list and container</span></span><br><span class="line"><span class="comment">     *      if (node == null) &#123;return&#125;</span></span><br><span class="line"><span class="comment">     *      if (node.left == null &amp;&amp; node.right == null) &#123;</span></span><br><span class="line"><span class="comment">     *          list.add(convertContainerElementsToFormattedString());</span></span><br><span class="line"><span class="comment">     *          container.remove(container.size() - 1);</span></span><br><span class="line"><span class="comment">     *          return;</span></span><br><span class="line"><span class="comment">     *      &#125;</span></span><br><span class="line"><span class="comment">     * 3.Finally, we must confirm logic</span></span><br><span class="line"><span class="comment">     *  For this question, we are using backtrack, which means we must</span></span><br><span class="line"><span class="comment">     *  pop the last element out</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    container.add(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123; <span class="comment">//leaf node, time to handle list and container</span></span><br><span class="line">        list.add(convertContainerElementsToFormattedString());</span><br><span class="line">        container.remove(container.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(node.left);</span><br><span class="line">    preorder(node.right);</span><br><span class="line">    <span class="comment">// In the end, we will pop the last element from container</span></span><br><span class="line">    container.remove(container.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">convertContainerElementsToFormattedString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; container.size(); i++) &#123;</span><br><span class="line">        stringBuilder.append(container.get(i));</span><br><span class="line">        <span class="keyword">if</span> (i != container.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the sum of all left leaves.</p>
<p>A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder-1"><a href="#1-Recursion-Postorder-1" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>The point in this question is how we can judge whether a node is left leaf. We can only do that by judging its father. If the father node has a non-null left son and its non-null left son has no sons, then we can say it is the father of a left leaf. As for the father’s right son, it does not matter at all. We must understand that well because at the very beginning, I met up with the case of </p>
<p>{1}, which should return 0 </p>
<p>While I mistaken the returned value for 1. The reason is that I did not judge the left leaf from its father but from itself.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//      int sumOfLeftLeaves(TreeNode root)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm the end conditions</span></span><br><span class="line">    <span class="comment">//  As usual, we return 0 if root is null</span></span><br><span class="line">    <span class="comment">//  Besides, we return 0 if root is a leaf node.</span></span><br><span class="line">    <span class="comment">//  Then a question arises that when are we able to add value</span></span><br><span class="line">    <span class="comment">//  and the answer is when we see the father of a left leaf node,</span></span><br><span class="line">    <span class="comment">//  which will be dealt with at logic part</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">//      if (root.left == null &amp;&amp; root.right == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm the logic</span></span><br><span class="line">    <span class="comment">//  It is postorder, so the order would be left, right and middle</span></span><br><span class="line">    <span class="comment">//  The special point is when the node we are dealing with is the father</span></span><br><span class="line">    <span class="comment">//  of a left leaf. In such case, we will cover the left with the node&#x27;s</span></span><br><span class="line">    <span class="comment">//  left son&#x27;s value and this answers the previous question on how we can add sum.</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">    <span class="comment">// This is the special point when we meet the father of a left leaf,</span></span><br><span class="line">    <span class="comment">// which we will replace left with its son&#x27;s value</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        left = root.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">    sum = left + right;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Level Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// If we meet the father of a left leaf</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span> &amp;&amp; popped.left.left == <span class="literal">null</span> &amp;&amp; popped.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += popped.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>Day18 Binary Tree Part05</title>
    <url>/2023/05/07/Day18-Binary-Tree-Part05/</url>
    <content><![CDATA[<h2 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the leftmost value in the last row of the tree.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Since recursion is hard to detect whether it is the bottom level or not, level traversal might be an easier alternative.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Layer Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">// index == size means we find the leftmost element in this level  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">                <span class="comment">// we replace ans with the leftmost element at new level</span></span><br><span class="line">                ans = popped.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion-Backtrack"><a href="#2-Recursion-Backtrack" class="headerlink" title="2.Recursion + Backtrack"></a>2.Recursion + Backtrack</h4><p>Recursion is harder to understand.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We need two global variables. One to record the current max depth,</span></span><br><span class="line"><span class="comment">// and the other the current ans</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Preorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traversal(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There are two important problems in this question</span></span><br><span class="line"><span class="comment">//  1.The way to know the bottom level.</span></span><br><span class="line"><span class="comment">//  2.The way to know if the node is the leftmost node at bottom.</span></span><br><span class="line"><span class="comment">// For the first problem, we can compare the depth of current level</span></span><br><span class="line"><span class="comment">// traversed with the max depth</span></span><br><span class="line"><span class="comment">// For the second problem, if there are simultaneously two nodes at bottom,</span></span><br><span class="line"><span class="comment">// we can get the right answer by traversing left one first and update the</span></span><br><span class="line"><span class="comment">// max depth as well as ans, then while traversing right side, the current depth</span></span><br><span class="line"><span class="comment">// cannot surpass max depth, the right node would be ignored</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      void traversal(TreeNode node, int depth)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (node == null) &#123;return;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We will use backtrack in this question because depth must be decremented</span></span><br><span class="line">    <span class="comment">//  when returning to upper level</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We get a leaf node and can compare depth now</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If it is the leftmost node, then at that time max depth will still be</span></span><br><span class="line">        <span class="comment">// smaller than depth. But if it is the rightmost node, then the updated</span></span><br><span class="line">        <span class="comment">// max depth will equal to the depth, which blocks further steps</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">            ans = node.val;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">    traversal(node.left, depth);</span><br><span class="line">    traversal(node.right, depth);</span><br><span class="line">    <span class="comment">// We need backtrack</span></span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.cn/problems/path-sum/">112. Path Sum</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p>
<p>A leaf is a node with no children.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Backtrack"><a href="#1-Recursion-Backtrack" class="headerlink" title="1.Recursion + Backtrack"></a>1.Recursion + Backtrack</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      boolean hasPathSum(TreeNode root, int targetSum)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  Two cases would be considered</span></span><br><span class="line">    <span class="comment">//  One is when root is null, which is needless to mention, </span></span><br><span class="line">    <span class="comment">//  The other one is when we find the value of leaf node equals</span></span><br><span class="line">    <span class="comment">//  to the target sum</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We get booleans from both tight and left</span></span><br><span class="line">    <span class="comment">//  and once there is a true, we can return true, otherwise return</span></span><br><span class="line">    <span class="comment">//  false</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == targetSum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetSum = targetSum - root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left, targetSum);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right, targetSum);</span><br><span class="line">    <span class="keyword">return</span> left || right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. Path Sum II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.</p>
<p>A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Backtrack-1"><a href="#1-Recursion-Backtrack-1" class="headerlink" title="1.Recursion + Backtrack"></a>1.Recursion + Backtrack</h4><p>We need to know all the routes, so the traversal function does not to return any specific value but void. This is quite different from the previous one that need to return a Boolean.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Global variables </span></span><br><span class="line"><span class="comment">// One for final answer and the other for temporarily recording path</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    traversal(root, targetSum);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We are tracking all routes, so we do not need to return any specific value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      void traversal(TreeNode node, int targetSum)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  As usual, return if node is null</span></span><br><span class="line">    <span class="comment">//  Besides, when the leaf node happens to be the targetSum, we</span></span><br><span class="line">    <span class="comment">//  will also return as well as put path into list</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We add node to the path and then do traversal to its left and</span></span><br><span class="line">    <span class="comment">//  right node. Finally, we will have to move the node from path</span></span><br><span class="line">    <span class="comment">//  since it is backtrack.</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val == targetSum &amp;&amp; node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="comment">// Remember arraylist is an referenced object</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.add(node.val);</span><br><span class="line">    targetSum = targetSum - node.val;</span><br><span class="line">    traversal(node.left, targetSum);</span><br><span class="line">    traversal(node.right, targetSum);</span><br><span class="line">    <span class="comment">// backtrack that removes the last node entering path</span></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;&#x3D; inorder.length &lt;&#x3D; 3000</li>
<li>postorder.length &#x3D;&#x3D; inorder.length</li>
<li>-3000 &lt;&#x3D; inorder[i], postorder[i] &lt;&#x3D; 3000</li>
<li>inorder and postorder consist of unique values.</li>
<li>Each value of postorder also appears in inorder.</li>
<li>inorder is guaranteed to be the inorder traversal of the tree.</li>
<li>postorder is guaranteed to be the postorder traversal of the tree</li>
</ul>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion"><a href="#1-Recursion" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>The last element of postorder array is the node in the middle, then we can go back to inorder array and divide arrays into two parts, left array and right array, by the middle node we have found. After that, we do recursion in both left array and right array, which is quite like what we do in fast sort. There are, in conclusion, 6 steps that can meet the requirement.</p>
<p><strong>Constraints:</strong></p>
<ol>
<li>if postorder is 0, then it is a null node</li>
<li>find the last element in postorder array which is the middle node</li>
<li>find the cutting point in inorder array by the middle node we have just found</li>
<li>cut inorder array into left side and right side</li>
<li>cut postorder array into left side and right side</li>
<li>do recursion in left side and right side</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// It is more efficient to check the index of node in inorder</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> traversal(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  Returned value is of course TreeNode</span></span><br><span class="line">    <span class="comment">//  And as for param, we will divide into two parts, one is start and end index in inorder array</span></span><br><span class="line">    <span class="comment">//  the other is start and end index in postorder array</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  We stick to left close right close principle, so when end index of inorder - start index of</span></span><br><span class="line">    <span class="comment">//  inorder is negative, we return null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We get the node from tail of postorder array, which is for certain because of the order of</span></span><br><span class="line">    <span class="comment">//  postorder. </span></span><br><span class="line">    <span class="comment">//  Then we get the node&#x27;s index of inorder array through map, which helps us divide</span></span><br><span class="line">    <span class="comment">//  the array into two parts and get the size of each part.</span></span><br><span class="line">    <span class="comment">//  At last, we do recursion. </span></span><br><span class="line">    <span class="keyword">if</span> (inEnd - inStart &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postEnd]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndexInInorder</span> <span class="operator">=</span> map.get(node.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> nodeIndexInInorder - inStart;</span><br><span class="line"></span><br><span class="line">    node.left = traversal(inorder, inStart, nodeIndexInInorder - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// For the right subtree the post end would be postEnd - 1, because the current node is exactly</span></span><br><span class="line">    <span class="comment">// post end and should be popped.</span></span><br><span class="line">    node.right = traversal(inorder, nodeIndexInInorder + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h2><h3 id="Intro-4"><a href="#Intro-4" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>
<p><strong>Constraints:</strong></p>
<ol>
<li><p>if postorder is 0, then it is a null node</p>
</li>
<li><p>find the last element in postorder array which is the middle node</p>
</li>
<li><p>find the cutting point in inorder array by the middle node we have just found</p>
</li>
<li><p>cut inorder array into left side and right side</p>
</li>
<li><p>cut postorder array into left side and right side</p>
</li>
<li><p>do recursion in left side and right side</p>
</li>
</ol>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-1"><a href="#1-Recursion-1" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>Almost same to the previous question.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// It is more efficient to check the index of node in inorder</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> traversal(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inEnd - inStart &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndexInInorder</span> <span class="operator">=</span> map.get(node.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> nodeIndexInInorder - inStart;</span><br><span class="line"></span><br><span class="line">    node.left = traversal(inorder, inStart, nodeIndexInInorder - <span class="number">1</span>, preorder, preStart + <span class="number">1</span>, preStart + leftSize);</span><br><span class="line">    node.right = traversal(inorder, nodeIndexInInorder + <span class="number">1</span>, inEnd, preorder, preStart + leftSize + <span class="number">1</span>, preEnd);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Divide_And_Conquer</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>Day15 Binary Tree Part02</title>
    <url>/2023/05/03/Day15-Binary-Tree-Part02/</url>
    <content><![CDATA[<h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Level traversal is actually BFS.</p>
<p>We use a queue to do the BFS because FIFO corresponds to the logic of search layer by layer.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce a tempList to record each layer&#x27;s nodes</span></span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We add the popped node value to the temp list and minus the size</span></span><br><span class="line">            tempList.add(popped.val);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// Once the size decreases to 0, it means the current layer has all been iterated</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.add(tempList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-1"><a href="#1-Level-Traversal-1" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Almost same to the previous one except for reversing the list in the end.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce a tempList to record each layer&#x27;s nodes</span></span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We add the popped node value to the temp list and minus the size</span></span><br><span class="line">            tempList.add(popped.val);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// Once the size decreases to 0, it means the current layer has all been iterated</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.add(tempList);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-2"><a href="#1-Level-Traversal-2" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Almost same to the question 107, but the point is that only adding the node to the list when size decrease to 0, namely, when it is the rightmost node of this layer.</p>
<p>At first, I made a mistake to add only the right son node to the queue. But it is not right in the case like  [1, 2], where 2 should also be added to the list although it is the left node while also remains the rightmost node in the second layer.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce a tempList to record each layer&#x27;s nodes</span></span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(popped.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10^5 of the actual answer will be accepted.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-3"><a href="#1-Level-Traversal-3" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still quite similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            total += popped.val;</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(total / tempSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="429-N-ary-Tree-Level-Order-Traversal"><a href="#429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="429. N-ary Tree Level Order Traversal"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></h2><h3 id="Intro-4"><a href="#Intro-4" class="headerlink" title="Intro"></a>Intro</h3><p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p>
<p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-4"><a href="#1-Level-Traversal-4" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            tempList.add(popped.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child : popped.children) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(tempList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></h2><h3 id="Intro-5"><a href="#Intro-5" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).</p>
<h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-5"><a href="#1-Level-Traversal-5" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            max = Math.max(popped.val, max);</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></h2><h3 id="Intro-6"><a href="#Intro-6" class="headerlink" title="Intro"></a>Intro</h3><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-6"><a href="#1-Level-Traversal-6" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Node2 <span class="title function_">connect</span><span class="params">(Node2 root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node2&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span>queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="type">Node2</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                popped.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                popped.next = queue.peek();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><h3 id="Intro-7"><a href="#Intro-7" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-7"><a href="#1-Level-Traversal-7" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxDepth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. Invert Binary Tree</a></h2><h3 id="Intro-8"><a href="#Intro-8" class="headerlink" title="Intro"></a>Intro</h3><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-PreOrder"><a href="#1-Recursion-PreOrder" class="headerlink" title="1.Recursion + PreOrder"></a>1.Recursion + PreOrder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> * PreOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//  It can just be TreeNode invertTree(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//  if (node == null) &#123;return null;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm the logic</span></span><br><span class="line">    <span class="comment">//  swapChildren(node);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.right);</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swapChildren(root);</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion-Postorder"><a href="#2-Recursion-Postorder" class="headerlink" title="2.Recursion + Postorder"></a>2.Recursion + Postorder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> * PostOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//  It can just be TreeNode invertTree(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//  if (node == null) &#123;return null;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm the logic</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.right);</span></span><br><span class="line">    <span class="comment">//  swapChildren(node);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    swapChildren(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Recursion-Midorder"><a href="#3-Recursion-Midorder" class="headerlink" title="3.Recursion + Midorder"></a>3.Recursion + Midorder</h4><p>Not recommended because logic should be changed a bit, otherwise there will be a subtree swapped twice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> * MidOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//  It can just be TreeNode invertTree(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//  if (node == null) &#123;return null;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm the logic</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line">    <span class="comment">//  swapChildren(node);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    swapChildren(root);</span><br><span class="line">    <span class="comment">// When it is midOrder, we must pay attention to the final step</span></span><br><span class="line">    <span class="comment">// Since the swapChildren step has already moved left subTree to right</span></span><br><span class="line">    <span class="comment">// The next step, which should have been invertTree(root.right) should be converted</span></span><br><span class="line">    <span class="comment">// to invertTree(root.left)</span></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Level-Traversal"><a href="#4-Level-Traversal" class="headerlink" title="4.Level Traversal"></a>4.Level Traversal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            swapChildren(popped);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. Symmetric Tree</a></h2><h3 id="Intro-9"><a href="#Intro-9" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder"><a href="#1-Recursion-Postorder" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>We can only use postorder rather the other two while dealing with the issue of comparing the left and right, followed by integrating the result into the upper node. This is quite like backtrack.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> * PostOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// We can only use postOrder in this question because we want to compare</span></span><br><span class="line">    <span class="comment">// the left node and the right of a subtree and then return to the root,</span></span><br><span class="line">    <span class="comment">// following the order of left, right, and middle, which is exactly the</span></span><br><span class="line">    <span class="comment">// order of postOrder.</span></span><br><span class="line">    <span class="comment">// Besides, we must separate the tree into two parts, one is outside part</span></span><br><span class="line">    <span class="comment">// and the other inside part. This is how we can deal with symmetry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      boolean compare(TreeNode left, TreeNode right)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//   We must pay attention to null conditions</span></span><br><span class="line">    <span class="comment">//      if (left == null &amp;&amp; right != null) &#123;return false;&#125;</span></span><br><span class="line">    <span class="comment">//      if (left != null &amp;&amp; right == null) &#123;return false;&#125;</span></span><br><span class="line">    <span class="comment">//      if (left == null &amp;&amp; right == null) &#123;return true;&#125;</span></span><br><span class="line">    <span class="comment">//      if (left.val != right.val) &#123;return false;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm the logic</span></span><br><span class="line">    <span class="comment">//   Pay attention to the compare order</span></span><br><span class="line">    <span class="comment">//   The correct one should be</span></span><br><span class="line">    <span class="comment">//   3.1.outside:   left.left VS right.right</span></span><br><span class="line">    <span class="comment">//   3.2.inside:    left.right VS right.left</span></span><br><span class="line">    <span class="comment">//   It can be proved by drawing a picture</span></span><br><span class="line">    <span class="comment">//      boolean outside = compare(left.left, right.right);</span></span><br><span class="line">    <span class="comment">//      boolean inside = compare(left.right, right.left);</span></span><br><span class="line">    <span class="comment">//      boolean isSame = outside &amp;&amp; inside;</span></span><br><span class="line">    <span class="comment">//      return isSame;</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> compare(root.left, root.right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isSame</span> <span class="operator">=</span> outside &amp;&amp; inside;</span><br><span class="line">      <span class="keyword">return</span> isSame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><p>We can also use queue to solve this question. </p>
<p>The most important point is in what sequence shall we put nodes into the queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// We can also use queue to do layer search</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root.left);</span><br><span class="line">    queue.add(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// poll two nodes and compare</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">// compare these two nodes</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If two nodes are not null and have the same value</span></span><br><span class="line">        <span class="comment">// We then push their sons children into the queue</span></span><br><span class="line">        <span class="comment">// But order is quite important, and we can know the</span></span><br><span class="line">        <span class="comment">// correct order from picture</span></span><br><span class="line">        <span class="comment">// It should be</span></span><br><span class="line">        <span class="comment">//      1.left.left</span></span><br><span class="line">        <span class="comment">//      2.right.right</span></span><br><span class="line">        <span class="comment">//      3.left.right</span></span><br><span class="line">        <span class="comment">//      4.right.left</span></span><br><span class="line">        queue.add(left.left);</span><br><span class="line">        queue.add(right.right);</span><br><span class="line">        queue.add(left.right);</span><br><span class="line">        queue.add(right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
</search>
