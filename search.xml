<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Day01 Array Part01</title>
    <url>/2023/04/20/Day01-Array-Part01/</url>
    <content><![CDATA[<h2 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704 Binary Search"></a><a href="https://leetcode.cn/problems/binary-search/">704 Binary Search</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p>
<p>You must write an algorithm with O(log n) runtime complexity.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Left-Close-Right-Close"><a href="#1-Left-Close-Right-Close" class="headerlink" title="1. Left Close Right Close"></a>1. Left Close Right Close</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Left Close Right Close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// eg:[1, 1] is a legal loop, so use &quot;&lt;=&quot; here</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">         <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">             right = index - <span class="number">1</span>; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">             left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> index;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Left-Close-Right-Open"><a href="#2-Left-Close-Right-Open" class="headerlink" title="2. Left Close Right Open"></a>2. Left Close Right Open</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Left Close Right Open</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// Now right is open, so do not use (nums.length - 1) for start</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// eg:[1, 1) is not a legal loop, so use &quot;&lt;&quot; here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">            right = index; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27 Remove Element"></a><a href="https://leetcode.cn/problems/remove-element/">27 Remove Element</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p> Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.</p>
<p> Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:</p>
<ul>
<li><p>change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.</p>
</li>
<li><p>Return <code>k</code>.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent"><a href="#1-Violent" class="headerlink" title="1.Violent"></a>1.Violent</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Violent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// We have found the element to be deleted, so we need to start a new loop to move forward the elements after the found element</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// Because all the elements after i have been moved forward, it is necessary to minus i to get a new start</span></span><br><span class="line">            size--; <span class="comment">// the size of nums should also be declined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Two-Pointer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// fast index is aimed to go through the old nums</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// slow index is aimed to update out new nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123; <span class="comment">// the element is not the one to be deleted</span></span><br><span class="line">                nums[slow++] = nums[fast++]; <span class="comment">// so fast and slow both move forward, meanwhile nums[slow] is replaced by nums[fast]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// the element is the one to be deleted</span></span><br><span class="line">                fast++; <span class="comment">// so only fast moves forward to go through the nums, while slow just waits for the next loop in which the element shall not be deleted</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">// slow is the size of out new nums</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35 Search Insert Position"></a>35 <a href="https://leetcode.cn/problems/search-insert-position/">Search Insert Position</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p> Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search"><a href="#1-Binary-Search" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binary Search</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// go to left side</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// go to right side</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34 Find First and Last Position of Element in Sorted Array"></a>34 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p>
<p> If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search-1"><a href="#1-Binary-Search-1" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Binary Search</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">1</span>) &#123; <span class="comment">// Defense first</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// move to left part</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// move to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// one index has been found</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// We will try to get its left end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= nums.length - <span class="number">1</span>; i++) &#123; <span class="comment">// We will try to get its right end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">1</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary_Search</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
      </tags>
  </entry>
  <entry>
    <title>Day02 Array Part02</title>
    <url>/2023/04/20/Day02-Array-Part02/</url>
    <content><![CDATA[<h2 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent-Quick-Sort"><a href="#1-Violent-Quick-Sort" class="headerlink" title="1.Violent + Quick_Sort"></a>1.Violent + Quick_Sort</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Violent + Quick_Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// Square First</span></span><br><span class="line">        nums[i] = (<span class="type">int</span>)Math.pow(nums[i], <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// get the position of partition</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="comment">// divide and conquer for the left part</span></span><br><span class="line">        quickSort(arr, left, position - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// divide and conquer for the right part</span></span><br><span class="line">        quickSort(arr, position + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.choose the last element as the pivot to be compared</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">    <span class="comment">// 2.define the pointer that is in front of the pivot, here goes to the leftest</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="comment">// 3.iterate the array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="comment">// if arr[i] is not bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then swap the position itself with both the index and the pointer moving afterwards</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            swap(arr, i, pointer++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if arr[i] is bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then we will just move the index backwards,</span></span><br><span class="line">        <span class="comment">// leaving the pointer unchanged</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.the array has been iterated, and we will finally swap the position of pointer and right</span></span><br><span class="line">    swap(arr, pointer, right);</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">    arr[left] = arr[right];</span><br><span class="line">    arr[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><p>​	In the example of [-4,-1,0,3,10], which contains all three cases of negative number, zero and positive number, we can see easily find out that the biggest number squared will always appear on either left or right side. </p>
<p>This gives us a hint to try to use Two-Pointer Strategy which starts from both sides and by comparison we can just get the targeted squared array within complexity of O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// we are going to iterate the array in a reversed order, so the index should be set the last position</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(nums[left]) &gt;= Math.abs(nums[right])) &#123; <span class="comment">// left absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[left], <span class="number">2</span>));</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// right absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[right], <span class="number">2</span>));</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two-Pointer"></a>1.Two-Pointer</h4><p>​	Still with a left index and right index indicating the bounds of subarray we want</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= nums.length - <span class="number">1</span>) &#123; <span class="comment">// as long as the left index does not get to the end of array, the loop will continue</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target ) &#123; <span class="comment">// sum is smaller than our target, so we have to move right index afterwards</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; nums.length - <span class="number">1</span>) &#123; <span class="comment">// but there might be a case when our right index has already been out of bounds, where we have to stop the loop</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[right++]; <span class="comment">// in normal cases, right index move backwards as well as our sum gets bigger</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// sum is now not bigger than the target, so it is time to move left index afterwards to make the subarray smaller</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">                ans = right - left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, right - left);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[left++]; <span class="comment">// after the left index moves afterwards, the sum will get smaller</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Sliding-Window"><a href="#2-Sliding-Window" class="headerlink" title="2.Sliding-Window"></a>2.Sliding-Window</h4><p>The Sliding-Window here is an enhanced version of Two-Pointer above.</p>
<p>The key point is to use index end as the right side of subarray, while at the meantime when the sum is not smaller than the target, we are going to move the index start to narrow the subarray.</p>
<p>The process of narrowing is included within a while loop below the outer for loop.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sliding_Window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we will need a start index to indicate the left side of subarray</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length; end++) &#123; <span class="comment">// i here indicates the right side, AKA the end of subarray</span></span><br><span class="line">        sum += nums[end];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">// we must use while rather than if here because only by using while can we get the minimum size of subarray</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = end - start + <span class="number">1</span>; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[start++]; <span class="comment">// sum will be smaller after start index moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>​	It is the issue of boarder that we must emphasize on while dealing with this question.</p>
<p>We can stick to one principle, say “Left Close Right Open” in order not to get confused while writing codes.</p>
<p>There are also other points to be treated seriously.</p>
<ol>
<li><p>n might be even or odd, and we have to deal with it separately because of the existence of the center point.</p>
</li>
<li><p>After each All-round loop, the next start point would be changed, and we must know the exact offset. </p>
</li>
<li><p>We must know the unchanged point of every smaller loop that just covers one side of the matrix. In the horizontal movement, it is j that changes, while in the verical one, it is i.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pay attention to the boarder, we will stick to left close right open</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// number to be filled</span></span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// if n == 4, then we will have 2 loops; if n == 5, we will have 3 loops</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we start from (0, 0)</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// up: left to right</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from left to right, i remains the same, while j will change</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,0), (0,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,0), (0,1), (0,2)</span></span><br><span class="line">            ans[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// right: up to down</span></span><br><span class="line">        <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,2), (1,2)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,3), (1,3), (2,3)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// down: right to left</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from right to left, i remains the same, while j will change. And i has been set to the bottom row since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,2), (2,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,3), (3,2), (3,1)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left: down to ip</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,0), (1,0)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,0), (2,0), (1,0)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++; <span class="comment">// now that one outer layer is finished, it is time to increment the start point</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n % <span class="number">2</span>) != <span class="number">0</span>) &#123; <span class="comment">// in the case where n is an odd number, we have to deal with the center point alone</span></span><br><span class="line">        ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
      </tags>
  </entry>
  <entry>
    <title>Day03 Linked List Part01</title>
    <url>/2023/04/21/Day03-Linked-List-Part01/</url>
    <content><![CDATA[<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. Remove Linked List Elements</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the new head.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.Head node is a problem because it does not have a pre node, therefore it must be dealt with alone.</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        <span class="comment">// for defense, head must not be null</span></span><br><span class="line">        <span class="comment">// we use while instead of if here because there might be the case when head = [1,1,1] and val = 1. In such case, all head nodes should be deleted and if does not suffice</span></span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.Now that we have eliminated the threat from head node, it is time to delete nodes afterwards</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; <span class="comment">// it is essential to set a temporary index that points to head</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1           2           3           4</span></span><br><span class="line">    <span class="comment">//      cur         cur.n       cur.n.n</span></span><br><span class="line">    <span class="comment">//  suppose val = 2 and we can see that cur.n is to be deleted</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// we have to get the next of cur, so cur must not be null;</span></span><br><span class="line">        <span class="comment">// we also have to get the val of cur.next, so cur.next must not be null</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next.val == val) &#123; <span class="comment">// we have found the node to be deleted, it is cur.next</span></span><br><span class="line">            cur.next = cur.next.next; <span class="comment">// cur should jump twice and change its next to the cur.next.next, in which cur.next would be skipped</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// it is not the node to be deleted, cur moves afterwards</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head"><a href="#2-Dummy-Head" class="headerlink" title="2.Dummy_Head"></a>2.Dummy_Head</h4><p>While facing linked list related questions, it is always a good idea to consider defining dummy head to avoid dealing with the case concerned with head node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy_Head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// set a dummy head to avoid dealing specially with head node;</span></span><br><span class="line">    <span class="comment">// two pointer is still necessary</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy; <span class="comment">// one starts from dummy</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;  <span class="comment">// one starts from head</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123; <span class="comment">// we have found the node that meets our requirement, it is time to delete</span></span><br><span class="line">            pre.next = cur.next; <span class="comment">// the next node after pre should be the one after cur</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur; <span class="comment">// the node is not the one to be deleted, so pre node moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next; <span class="comment">// in both cases, the cur should move afterwards</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// we must return dummy.next because there might be the case when we would delete head node.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. Design Linked List</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</p>
<p>A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer&#x2F;reference to the next node.</p>
<p>If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>
<p>Implement the MyLinkedList class:</p>
<ul>
<li><p><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</p>
</li>
<li><p>int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.</p>
</li>
<li><p>void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</p>
</li>
<li><p>void addAtTail(int val) Append a node of value val as the last element of the linked list.</p>
</li>
<li><p>void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.</p>
</li>
<li><p>void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Dummy-Head"><a href="#1-Dummy-Head" class="headerlink" title="1.Dummy_Head"></a>1.Dummy_Head</h4><p>This question is a good one to  practice manipulating linked list. </p>
<p>We still need to rely on dummy head in order to simplify the treatment of head node.</p>
<p>Besides, the size of the list is also a key field to be utilized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// sequence is quite important</span></span><br><span class="line">        <span class="comment">//          0           2</span></span><br><span class="line">        <span class="comment">//          cur         cur.next</span></span><br><span class="line">        <span class="comment">// suppose we are going to add 1 as head</span></span><br><span class="line">        <span class="comment">//          0           1           2</span></span><br><span class="line">        <span class="comment">//          cur                     cur.next</span></span><br><span class="line">        <span class="comment">// 1.the next of 1 Node must be connected to cur.next first</span></span><br><span class="line">        <span class="comment">// 2.the cur.next then would be connected to 1 Node</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// move to the tail, if boarder bothers again, take the example of one node again</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, <span class="literal">null</span>);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head-But-More-Concise"><a href="#2-Dummy-Head-But-More-Concise" class="headerlink" title="2. Dummy_Head_But_More_Concise"></a>2. Dummy_Head_But_More_Concise</h4><p>Make addAtHead and addAtTail more concise by combining these two methods with addAtIndex</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. Reverse Linked List</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<h3 id="Soulution"><a href="#Soulution" class="headerlink" title="Soulution"></a>Soulution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>Two pointer, actually three pointer works quite well in this question.</p>
<p>Still sequence is the issue that matters</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// actually we need three pointers in this question and they are pre, cur and cur</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//          pre             cur         temp</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                          pre         cur         temp</span></span><br><span class="line">    <span class="comment">// in the end, it should be like this</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                                                              pre         cur</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// the most previous node should point to null, just as symmetrically, the next of end node points to null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// define our helper node to trace cur.next, otherwise cur loses its way afterwards</span></span><br><span class="line">        <span class="comment">// sequence is also important here</span></span><br><span class="line">        <span class="comment">// 1.cur should point to pre</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 2.pre should become cur</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 3.cur should be replaced with temp</span></span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// seen from the example, pre is the node to be returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion"><a href="#2-Recursion" class="headerlink" title="2. Recursion"></a>2. Recursion</h4><p>Based on the two pointer solution above, we can get an easier but harder to understand solution which utilizes recursion</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// pre should be null and cur should be head</span></span><br><span class="line">    <span class="keyword">return</span> recursion(head, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">recursion</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123; <span class="comment">// the end of recursion</span></span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// still it is pre to be returned</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// helper node is still needed to trace cur.next</span></span><br><span class="line">    cur.next = pre; <span class="comment">// reversed here</span></span><br><span class="line">    <span class="keyword">return</span> recursion(temp, cur); <span class="comment">// the nodes here have changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Linked_List</tag>
        <tag>Dummy_Head</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>Day04 Linked List Part02</title>
    <url>/2023/04/23/Day04-Linked-List-Part02/</url>
    <content><![CDATA[<h2 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Dummy-Head"><a href="#1-Dummy-Head" class="headerlink" title="1.Dummy_Head"></a>1.Dummy_Head</h4><p>Dummy head is quite useful since it simplifies the manipulation of the very first head node.</p>
<p>Also, the sequence of next declaration and the utilization of  helper node are key points in this question</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy Head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// A dummy head is still needed, and its next is the head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">    <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">    <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">    <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Here we do not need to judge if cur is null because we have set the dummy as cur deliberately</span></span><br><span class="line">        <span class="comment">// In order to manipulate 1 and 2 node, we must get cur.next and cur.next.next</span></span><br><span class="line">        <span class="comment">// , which is the reason why they must not be null if the loop continues</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Once we have swapped 1 and 2, it is not possible to get 3 through 2,</span></span><br><span class="line">        <span class="comment">// so we need a helper here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp3</span> <span class="operator">=</span> cur.next.next.next;</span><br><span class="line">        <span class="comment">// As the same, once we connect 0 with 2, it is also not possible to get 1,</span></span><br><span class="line">        <span class="comment">// so we need another helper here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start the swap and sequence is important</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       t1      c.n</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n.n   c.n     t3</span></span><br><span class="line">        <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">        <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">        <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        cur.next.next = temp1;</span><br><span class="line">        cur.next.next.next = temp3;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// It is still dummy&#x27;s next to be returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Dummy-Head"><a href="#1-Two-Pointer-Dummy-Head" class="headerlink" title="1.Two_Pointer + Dummy_Head"></a>1.Two_Pointer + Dummy_Head</h4><p>Two pointer can be use used to get the Nth node from end in one loop.</p>
<p>Suppose we are going to get the 2nd node from end, which is 4 in the example</p>
<ol>
<li>We are going to move fast pointer first</li>
<li>At step 3, when fast pointer has moved 2 steps afterwards, we are going to set the slow pointer. From now on, we will move both pointers simultaneously.</li>
<li>Fast pointer points to null at step 6 and our iteration stops. We can see that slow pointer now points to the node we want</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
</tr>
</tbody></table>
<p>Therefore, two pointer is  a useful skill to get the Nth node from end in one loop.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy Head + Two Pointer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// </span></span><br><span class="line">    <span class="comment">// Suppose n = 2, which means we are going to delete 3 Node</span></span><br><span class="line">    <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">    <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">    <span class="comment">// We must make sure that cur points to the previous node 2 so that we can manipulate node 3</span></span><br><span class="line">    <span class="comment">// This means the slow pointer adopted from the two-pointer skill to get the Nth node from end in one loop should point to the node before, so here should be some adjustment.</span></span><br><span class="line">    <span class="comment">// We can adjust the fast pointer to let it move one more step before moving both pointers</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123; <span class="comment">// We let fast pointer move (n + 1) steps alone</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123; <span class="comment">// We move both pointers until fast points to null</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now it should be like this</span></span><br><span class="line">    <span class="comment">//      0       1       2       3       4       null</span></span><br><span class="line">    <span class="comment">//                      s                       f</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// still return dummy.next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="02-07-Intersection-of-Two-Linked-Lists-LCCI"><a href="#02-07-Intersection-of-Two-Linked-Lists-LCCI" class="headerlink" title="02.07. Intersection of Two Linked Lists LCCI"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">02.07. Intersection of Two Linked Lists LCCI</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter­secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>The key point of this question is to understand the basic principle that judgment of intersection only starts once two lists have the relatively same length from end. We can deduce that by drawling two lists within right alignment.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// Suppose two lists below</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">// B    2       4       5</span></span><br><span class="line">    <span class="comment">// Apparently, Node 4 is the one to be returned, but how?</span></span><br><span class="line">    <span class="comment">// There is a rule that if there is an intersection, the two lists will always meet in the end</span></span><br><span class="line">    <span class="comment">// and the length of sub lists after intersection is the same</span></span><br><span class="line">    <span class="comment">// We can try to show both lists in right alignment</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">// We can know that Node 1 to Node 2 from A list is useless,</span></span><br><span class="line">    <span class="comment">// because intersection can only start when two sub lists are of the same length.</span></span><br><span class="line">    <span class="comment">// So we can skip them these we know the length difference of lists, which is 2</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">//                      cA</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">//                      cB</span></span><br><span class="line">    <span class="comment">// We make two pointers then at the relatively same point from end</span></span><br><span class="line">    <span class="comment">// then we can start move both pointers simultaneously until we find the intersected node</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">//                              cA</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">//                              cB</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="comment">// We must know the length difference</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (curB != <span class="literal">null</span>) &#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        curB = curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get the length difference</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(lenA - lenB);</span><br><span class="line">    <span class="comment">// reset</span></span><br><span class="line">    curA = headA;</span><br><span class="line">    curB = headB;</span><br><span class="line">    <span class="comment">// By default, list A should be the one longer, and we can skip some nodes in it,</span></span><br><span class="line">    <span class="comment">// but this is not always the case, so there is a swap to make sure our assume work</span></span><br><span class="line">    <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">        curA = headB;</span><br><span class="line">        curB = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (diff-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">            <span class="keyword">return</span> curA;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">        curB = curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p>
<p>Do not modify the linked list.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-1"><a href="#1-Two-Pointer-1" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>Two points for this question</p>
<ol>
<li><p>How can we know if there is a cycle in the list?</p>
<p>We can know that by moving two pointers, one moves two steps once and the other one one step once.</p>
<p>If there is no cycle, the faster one will point to null in advance.</p>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">s|f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
</tr>
</tbody></table>
<p>If there is a cycle, the two pointers will meet.</p>
<p>Suppose the node after 3 is node 1.</p>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">s|f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center">f</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center">s</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s|f</td>
</tr>
</tbody></table>
</li>
<li><p>How can we know the entrance of cycle?</p>
<p><a href="https://postimg.cc/R6MwyMy0"><img src="https://i.postimg.cc/Y9F840xQ/Day04-Linked-List-Part02-01.jpg" alt="Day04-Linked-List-Part02-01.jpg"></a></p>
<p>Suppose x as the distance from start to entrance.</p>
<p>Suppose y as the distance from entrance to the point where both pointers meet, actually it is the distance slow pointer has move after it enters the circle.</p>
<p>Suppose z as the distance from the point met to entrance.</p>
<p>What clues can we get then?</p>
<ol>
<li><p>The whole distance of slow is x + y</p>
</li>
<li><p>The whole distance of cycle is y + z</p>
</li>
<li><p>The fast can have already moved n cycles, so the distance of fast is x + y + n * (y + z)</p>
</li>
<li><p>The speed of slow is 1 and the speed of fast is 2, so there is an equation: </p>
<p>​		2 * (x + y) &#x3D; x + y + n * (y + z)</p>
<p>​		x  &#x3D; n * (y + z) - z</p>
</li>
<li><p>n is always &gt;&#x3D; 1 and is not quite important, so we can just combine it with some (n - 1) factor</p>
<p>​		x  &#x3D; (n - 1) * (y + z) + z</p>
</li>
<li><p>Since n is not important, we can actually suppose it be 1 and what we get is</p>
<p>​		x  &#x3D; z</p>
<p>which means we can conclude that distance from start to entrance &#x3D;&#x3D; the distance from the point met to entrance</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// Since there might be a cycle now, we can not rely on dummy head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123; <span class="comment">// we must make sure that fast.next is also not null because there is no dummy head to simplify the manipulation of the very first head node.</span></span><br><span class="line">        <span class="comment">// If it is the case of [1], we will meet null pointer when we move fast for two steps</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123; <span class="comment">// two pointers have met</span></span><br><span class="line">            <span class="comment">// reset slow to head</span></span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="comment">// and move both pointers one step every time</span></span><br><span class="line">            <span class="comment">// they will meet at entrance</span></span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Linked_List</tag>
        <tag>Dummy_Head</tag>
      </tags>
  </entry>
  <entry>
    <title>Day06 Hash Table Part01</title>
    <url>/2023/04/24/Day06-Hash-Table-Part01/</url>
    <content><![CDATA[<h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. Valid Anagram</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</p>
<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table"><a href="#1-Hash-Table" class="headerlink" title="1. Hash_Table"></a>1. Hash_Table</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123; <span class="comment">// If length is different, that will definitely be false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] table = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]; <span class="comment">// We do not need to create an alphabetical table.</span></span><br><span class="line">                               <span class="comment">// A simulation array would be okay.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        table[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++; <span class="comment">// for s add</span></span><br><span class="line">        table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--; <span class="comment">// for t minus</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i] != <span class="number">0</span>) &#123; <span class="comment">// if the value is not 0, it will not be anagram</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// Unlike alphabets, we do not know the exact value in the arrays.</span></span><br><span class="line">    <span class="comment">// So we use set instead of array made by ourselves.</span></span><br><span class="line">    HashSet&lt;Integer&gt; containerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; resultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123; <span class="comment">// get all unique value from nums1</span></span><br><span class="line">        containerSet.add(nums1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123; <span class="comment">// compare nums2 with containerSet and find intersection</span></span><br><span class="line">        <span class="keyword">if</span> (containerSet.contains(nums2[i])) &#123;</span><br><span class="line">            resultSet.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[resultSet.size()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : resultSet) &#123;</span><br><span class="line">        ans[index++] = integer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.cn/problems/happy-number/">202. Happy Number</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Write an algorithm to determine if a number n is happy.</p>
<p>A happy number is a number defined by the following process:</p>
<ul>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or <strong>it loops endlessly in a cycle</strong> which does not include 1.</li>
<li>Those numbers for which this process ends in 1 are happy.</li>
</ul>
<p>Return true if n is a happy number, and false if not.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Set-1"><a href="#1-Set-1" class="headerlink" title="1. Set"></a>1. Set</h4><p>The hardest part might be the algorithm to get the next number.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// It says that there will be an endless loop if n is not happy.</span></span><br><span class="line">    <span class="comment">// So we can use a set to store numbers that have appeared.</span></span><br><span class="line">    <span class="comment">// Once repetition occurs, return false.</span></span><br><span class="line">    HashSet&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    record.add(n); <span class="comment">// put n into record</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextNumber</span> <span class="operator">=</span> getNextNumber(n);</span><br><span class="line">    <span class="keyword">while</span> (nextNumber != <span class="number">1</span>) &#123;</span><br><span class="line">        nextNumber = getNextNumber(nextNumber); <span class="comment">// get the next number</span></span><br><span class="line">        <span class="keyword">if</span> (!record.contains(nextNumber)) &#123; <span class="comment">// if the next number is a new number, we continue</span></span><br><span class="line">            record.add(nextNumber);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// if the next number has appeared, we return false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="comment">// always get the rightmost digit</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line">        sum += digit * digit;</span><br><span class="line">        num = num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table-1"><a href="#1-Hash-Table-1" class="headerlink" title="1.Hash_Table"></a>1.Hash_Table</h4><p>We use Hash if there is a requirement to record the element that has appeared. </p>
<p>We use map because we want to both record the number that has already appeared and the index of it.</p>
<p>Set is not sufficient because it cannot do the latter.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// use map to record target - nums[i]</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// See if there exists a number in the map that equals to nums[i]</span></span><br><span class="line">        <span class="comment">// That is because that we put in the map is target - nums[i]</span></span><br><span class="line">        <span class="keyword">if</span> (map.get(nums[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">            ans[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// What we put is target - nums[i]</span></span><br><span class="line">        <span class="comment">// What we compare in the iteration is target - nums[i] and nums[i]</span></span><br><span class="line">        <span class="comment">// Also sequence is important here to avoid repetition</span></span><br><span class="line">        <span class="comment">//  1.first compare</span></span><br><span class="line">        <span class="comment">//  2.then put</span></span><br><span class="line">        <span class="comment">// if sequence gets wrong, the answer would be [0,0] in the case where nums [3,2,4]</span></span><br><span class="line">        <span class="comment">//  and target = 6 because we failed to avoid repetition</span></span><br><span class="line">        map.put(target - nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash_Table</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title>Day08 String Part01</title>
    <url>/2023/04/26/Day08-String-Part01/</url>
    <content><![CDATA[<h2 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a><a href="https://leetcode.cn/problems/reverse-string/">344. Reverse String</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Write a function that reverses a string. The input string is given as an array of characters s.</p>
<p>You must do this by modifying the input array in-place with O(1) extra memory.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. Reverse String II</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.</p>
<p>If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><p>Actually the hardest part is to understand the question.</p>
<p>If understood, the question becomes quite easy. We just need to pay attention to the steps.</p>
<p>Besides, it is also a more efficient skill to convert string into a char array first and then do the reverse through this array.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// converting s into an array will make it more efficient</span></span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// The step is 2 * k</span></span><br><span class="line">        <span class="comment">// We get a start and an end</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">2</span> * k * times;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; s.length() -<span class="number">1</span> &amp;&amp; end &gt;= s.length() - <span class="number">1</span>) &#123; <span class="comment">// if the rest is less than k</span></span><br><span class="line">            reverse(arr, start, arr.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt;= s.length() - <span class="number">1</span>) &#123; <span class="comment">// if the start is already out of bounds</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// normal case</span></span><br><span class="line">            reverse(arr, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Better-Logic-With-For-Loop"><a href="#2-Better-Logic-With-For-Loop" class="headerlink" title="2.Better Logic With For Loop"></a>2.Better Logic With For Loop</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="comment">// The step is 2 * k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="comment">// normal case</span></span><br><span class="line">        <span class="keyword">if</span> (i + k &lt;= arr.length) &#123;</span><br><span class="line">            reverse(arr, i, i + k -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// end case</span></span><br><span class="line">        reverse(arr, i, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Offer-05-Replace-Space"><a href="#Offer-05-Replace-Space" class="headerlink" title="Offer 05. Replace Space"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">Offer 05. Replace Space</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given String s. Replace all space in s with “%20”;</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal-1"><a href="#1-Normal-1" class="headerlink" title="1. Normal"></a>1. Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// Introduce a pointer and do the iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pointer &lt;= s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(pointer) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(s.charAt(pointer));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Two-Pointer"><a href="#Two-Pointer" class="headerlink" title="Two_Pointer"></a>Two_Pointer</h4><p>It is an extreme solution while dealing with continuous data structure by adopting two pointer to do the filling and covering.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// We go extreme and just need an array of precise size after counting space first</span></span><br><span class="line">    <span class="comment">// Then we adopt two pointer to fill the array</span></span><br><span class="line">    <span class="comment">// The key pointer here is that while filling, we go from end to start</span></span><br><span class="line">    <span class="comment">//  so that covering is acceptable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123; <span class="comment">// defense</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count space and expand the array in the future</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// we will spare three char for replacement</span></span><br><span class="line">            sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if there is no space, just return</span></span><br><span class="line">    <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// we define two pointers</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// s will be expanded and right will start form the new end;</span></span><br><span class="line">    s += sb.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// when we meet space</span></span><br><span class="line">        <span class="keyword">if</span> (chars[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            chars[right] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chars[right] = chars[left];</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></h4><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given an input string s, reverse the order of the words.</p>
<p>A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.</p>
<p>Return a string of the words in reverse order concatenated by a single space.</p>
<p>Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Divide-And-Conquer"><a href="#1-Two-Pointer-Divide-And-Conquer" class="headerlink" title="1.Two_Pointer + Divide_And_Conquer"></a>1.Two_Pointer + Divide_And_Conquer</h4><p>This is a complicated question. The hardest point is to think of the method that firstly reverse all the string and then reverse each word, but that just works.</p>
<p>Another hardship is to think of an efficient way to eliminate all extra spaces. Two pointer works in this situation.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * Two Pointer</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// Suppose s = &quot;We are   happy &quot;</span></span><br><span class="line">    <span class="comment">// 1.First we eliminate all extra space</span></span><br><span class="line">    <span class="comment">//      s = &quot;We are happy&quot;</span></span><br><span class="line">    <span class="comment">// 2.Then we can reverse all the string</span></span><br><span class="line">    <span class="comment">//      s = &quot;yppah era eW&quot;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we reverse each word</span></span><br><span class="line">    <span class="comment">//      s = &quot;happy are We&quot;</span></span><br><span class="line">    <span class="comment">// The second part to reverse all the string is the hardest to think of</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] chars = removeExtraSpace(s);</span><br><span class="line">    reverseString(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> reverseEachWord(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Divide And Conquer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] removeExtraSpace(String s) &#123;</span><br><span class="line">    <span class="comment">// We adopt start and end to eliminate space from both ends</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// eliminate space at head</span></span><br><span class="line">    <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eliminate space at tail</span></span><br><span class="line">    <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We do an iteration of s and append what we need</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// Pay attention to the latter condition which is harder to think of</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(s.charAt(start));</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().toCharArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[start];</span><br><span class="line">        chars[start] = chars[end];</span><br><span class="line">        chars[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; chars.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[end] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">// pay attention to the time when end reaches end.</span></span><br><span class="line">            <span class="comment">// We will reverse the word in this loop otherwise the last word would be missed</span></span><br><span class="line">            <span class="keyword">if</span> (end == chars.length) &#123;</span><br><span class="line">                reverseString(chars, start, end - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[end] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            reverseString(chars, start, end - <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">            start = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Offer-58-II-Reverse-Left-Words"><a href="#Offer-58-II-Reverse-Left-Words" class="headerlink" title="Offer 58 - II. Reverse Left Words"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">Offer 58 - II. Reverse Left Words</a></h2><h3 id="Intro-4"><a href="#Intro-4" class="headerlink" title="Intro"></a>Intro</h3><p>Left reverse of string means moving the first kth character to the tail of string.</p>
<p>For example, string s &#x3D; “abcdefg” and k &#x3D; 2. By left rotating we get “cdefgab”</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Divide-And-Conquer"><a href="#1-Divide-And-Conquer" class="headerlink" title="1.Divide_And_Conquer"></a>1.Divide_And_Conquer</h4><p>Similar to the previous one, we can also adopt “First All Then Part” philosophy.</p>
<p>Take string s &#x3D; “abcdefg” and k &#x3D; 2 as an example.</p>
<ol>
<li>We firstly reverse all and get <ul>
<li>g f e d c b a</li>
</ul>
</li>
<li>We then reverse the last kth character and get<ul>
<li>g f e d c a b</li>
</ul>
</li>
<li>We finally reverse the first (s.length - k)th character and get<ul>
<li>c d e f g a b</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Divide And Conquer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// We stick to &quot;First All Then Part&quot; philosophy</span></span><br><span class="line">    <span class="comment">// suppose s = &quot;abcdefg&quot; and n = 2</span></span><br><span class="line">    <span class="comment">// 1. We firstly reverse all and get</span></span><br><span class="line">    <span class="comment">//      g f e d c b a</span></span><br><span class="line">    <span class="comment">// 2. We then reverse the last kth charater and get</span></span><br><span class="line">    <span class="comment">//      g f e d c a b</span></span><br><span class="line">    <span class="comment">// 3. We finally reverse the fisrt (s.lenghth - k)th character and get</span></span><br><span class="line">    <span class="comment">//      c d e f g a b</span></span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 1. reverse all</span></span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. reverse the last kth</span></span><br><span class="line">    reverse(chars, chars.length -  n , chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. reverse  the first (s.length - k)th</span></span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[start];</span><br><span class="line">        chars[start] = chars[end];</span><br><span class="line">        chars[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>String</tag>
        <tag>Divide_And_Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>Day07 Hash Table Part02</title>
    <url>/2023/04/25/Day07-Hash-Table-Part02/</url>
    <content><![CDATA[<h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 4Sum II</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:</p>
<ul>
<li>0 &lt;&#x3D; i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0<span id="more"></span></li>
</ul>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table-Divide-And-Conquer"><a href="#1-Hash-Table-Divide-And-Conquer" class="headerlink" title="1.Hash_Table + Divide_And_Conquer"></a>1.Hash_Table + Divide_And_Conquer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table + Divide And Conquer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">    <span class="comment">// We do not to care about repetition because all numbers have different indexes</span></span><br><span class="line">    <span class="comment">//  and combination with different position still count.</span></span><br><span class="line">    <span class="comment">// We can divide four arrays into two groups and convert the question into TwoSum1 question</span></span><br><span class="line">    <span class="comment">//  which utilizes hash table.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="comment">// we store sums from the first two arrays into map</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map1And2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">            temp = i + j;</span><br><span class="line">            <span class="keyword">if</span> (map1And2.containsKey(temp)) &#123;</span><br><span class="line">                map1And2.put(temp, map1And2.get(temp) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map1And2.put(temp, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for the rest two arrays, we compare the sum with what we got in the map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums3) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">            temp = i + j;</span><br><span class="line">            <span class="keyword">if</span> (map1And2.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                <span class="comment">// we can directly add the value because just as said before,</span></span><br><span class="line">                <span class="comment">// we do not to worry about repetition since combination</span></span><br><span class="line">                <span class="comment">// with different positions still count</span></span><br><span class="line">                ans += map1And2.get(<span class="number">0</span> - temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.cn/problems/ransom-note/">383. Ransom Note</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.</p>
<p>Each letter in magazine can only be used once in ransomNote.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table"><a href="#1-Hash-Table" class="headerlink" title="1.Hash_Table"></a>1.Hash_Table</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="comment">// All are lowercase English letters, so an array rather than map would suffice</span></span><br><span class="line">    <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123; <span class="comment">// count all characters from magazine</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">character</span> <span class="operator">=</span> magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        record[character]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">character</span> <span class="operator">=</span> ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        record[character]--; <span class="comment">// minus corresponding character</span></span><br><span class="line">        <span class="keyword">if</span> (record[character] &lt; <span class="number">0</span>) &#123; <span class="comment">// if corresponding count is negative, then return false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><a href="https://leetcode.cn/problems/3sum/">15. 3Sum</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i !&#x3D; j, i !&#x3D; k, and j !&#x3D; k, and nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Quick-Sort"><a href="#1-Two-Pointer-Quick-Sort" class="headerlink" title="1.Two_Pointer + Quick_Sort"></a>1.Two_Pointer + Quick_Sort</h4><p>This question does not require returning index, so we can do a quick sort and find the answer by two pointer.</p>
<p>The biggest difficulty is to avoid duplication and we can do that by paying attention to the condition of iteration </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Quick Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// We can use two pointer in this question because we do not need to return index</span></span><br><span class="line">    <span class="comment">// Suppose nums = &#123;-1, 0, 1, 2, -1, 4&#125;</span></span><br><span class="line">    <span class="comment">// We must do a quick sort this nums if we want to adopt two pointer</span></span><br><span class="line">    <span class="comment">// So it will become</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">// Then we do an iteration that starts from -1</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i</span></span><br><span class="line">    <span class="comment">// And we will import two pointers</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i       l                               r</span></span><br><span class="line">    <span class="comment">// it seems now three summed are bigger than 0, therefore we can move r</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i       l                       r</span></span><br><span class="line">    <span class="comment">// bingo, we get one answer &#123;-1, -1, 2&#125; and we shall continue by moving both pointers</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//      i               l       r</span></span><br><span class="line">    <span class="comment">// bingo another one. If we keep moving both pointers, l would be bigger than r</span></span><br><span class="line">    <span class="comment">// which means it is time to continue iteration</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//              i       l                       r</span></span><br><span class="line">    <span class="comment">// too big until it goes to</span></span><br><span class="line">    <span class="comment">//      -1      -1      0       1       2       4</span></span><br><span class="line">    <span class="comment">//              i       l       r</span></span><br><span class="line">    <span class="comment">// but there comes the issue of duplication, so we must exclude this kind of case</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// must sort first</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// if nums[i] is already bigger than 0, we can break the whole iteration and return ans</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we must exclude duplicated A.</span></span><br><span class="line">        <span class="comment">// Two codes here</span></span><br><span class="line">        <span class="comment">// 1.nums[i] == nums[i + 1]</span></span><br><span class="line">        <span class="comment">// 2.nums[i] == nums[i - 1]</span></span><br><span class="line">        <span class="comment">// Suppose [-1, -1, 2] and i = 0 right now</span></span><br><span class="line">        <span class="comment">// code 1 is not okay because we will skip it since nums[i] == nums[i + 1]</span></span><br><span class="line">        <span class="comment">// code 2 is okay because there is no element before first -1, so this one counts</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// Here I use two helpers, but actually it is not that necessary</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tempLeftValue</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempRightValue</span> <span class="operator">=</span> nums[right];</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + tempLeftValue + tempRightValue;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(Arrays.asList(nums[i], tempLeftValue, tempRightValue));</span><br><span class="line">                <span class="comment">// exclude duplicated B</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left + <span class="number">1</span>] == tempLeftValue) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// // exclude duplicated C</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right - <span class="number">1</span>] == tempRightValue) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a><a href="https://leetcode.cn/problems/4sum/">18. 4Sum</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:</p>
<ul>
<li><p>0 &lt;&#x3D; a, b, c, d &lt; n</p>
</li>
<li><p>a, b, c, and d are distinct.</p>
</li>
<li><p>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</p>
</li>
</ul>
<p>You may return the answer in any order.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Quick-Sort-1"><a href="#1-Two-Pointer-Quick-Sort-1" class="headerlink" title="1.Two_Pointer + Quick_Sort"></a>1.Two_Pointer + Quick_Sort</h4><p>It is quite similar to 15.3Sum.</p>
<p>First sort and then apply two pointers.</p>
<p>We can extend this method to even n digits and will result in a declination of complexity from O(N^N) to O(N^(N - 1))</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer + Quick Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// Like ThreeSum15, we can use two pointer</span></span><br><span class="line">    <span class="comment">// And the first step is also sort</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return if it is already too big</span></span><br><span class="line">        <span class="comment">// remember it must be positive</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>  &amp;&amp; nums[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// exclude duplicate A</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// exclude duplicated B</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="comment">// there might be overflow, so make it long</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">// exclude duplicated C</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="comment">// exclude duplicated D</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Hash_Table</tag>
      </tags>
  </entry>
  <entry>
    <title>Day09 String Part02</title>
    <url>/2023/04/27/Day09-String-Part02/</url>
    <content><![CDATA[<h2 id="28-Find-the-Index-of-the-First-Occurrence-in-a-String"><a href="#28-Find-the-Index-of-the-First-Occurrence-in-a-String" class="headerlink" title="28. Find the Index of the First Occurrence in a String"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. Find the Index of the First Occurrence in a String</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Sliding-Window"><a href="#1-Sliding-Window" class="headerlink" title="1.Sliding_Window"></a>1.Sliding_Window</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sliding Window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() &gt; haystack.length()) &#123; <span class="comment">// defense</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// declare two points to make sliding window</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">    <span class="keyword">for</span> (; left &lt; haystack.length(); left++) &#123;</span><br><span class="line">        right = left;</span><br><span class="line">        <span class="comment">// pay attention to the boarder issue, especially the latter one</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &lt; needle.length() &amp;&amp; right &lt; haystack.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">needleChar</span> <span class="operator">=</span> needle.charAt(right - left);</span><br><span class="line">            <span class="type">char</span> <span class="variable">haystackChar</span> <span class="operator">=</span> haystack.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (needleChar == haystackChar) &#123;</span><br><span class="line">                <span class="comment">// When the length reaches needle&#x27;s length, we will return</span></span><br><span class="line">                <span class="keyword">if</span> (right - left == needle.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// move right to make the window</span></span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-KMP"><a href="#2-KMP" class="headerlink" title="2.KMP"></a>2.KMP</h4><p>This is the first time we touch KMP.</p>
<p>The principle behind is quite hard for me to understand.</p>
<p>What I know for now is the existence of the next array that records the biggest public prefix, which is useful to trace the very first element that does not pair with the needle.</p>
<p>Therefore, I will put the code here but honestly speaking, I do not master this algorithm.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">    getNextArray(next, needle);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i))</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (needle.charAt(j) == haystack.charAt(i))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length())</span><br><span class="line">            <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNextArray</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">    <span class="comment">// next array is the array that records the biggest public prefix</span></span><br><span class="line">    <span class="comment">// suppose string s = &quot;abcbabef&quot;</span></span><br><span class="line">    <span class="comment">// its next array would be</span></span><br><span class="line">    <span class="comment">//      0	0	0	0	1	2	0	0</span></span><br><span class="line">    <span class="comment">// suppose string s = &quot;aabaaf&quot;</span></span><br><span class="line">    <span class="comment">// its next array would be</span></span><br><span class="line">    <span class="comment">//      0   1   0   1   2   0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Sliding_Window</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Day10 Stack And Queue Part01</title>
    <url>/2023/04/28/Day10-Stack-And-Queue-Part01/</url>
    <content><![CDATA[<h2 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).</p>
<p>Implement the MyQueue class:</p>
<ul>
<li><p>void push(int x) Pushes element x to the back of the queue.</p>
</li>
<li><p>int pop() Removes the element from the front of the queue and returns it.</p>
</li>
<li><p>int peek() Returns the element at the front of the queue.</p>
</li>
<li><p>boolean empty() Returns true if the queue is empty, false otherwise.</p>
</li>
</ul>
<p>Notes:</p>
<ul>
<li><p>You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid.</p>
</li>
<li><p>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</p>
</li>
</ul>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Suppose we have got 1 2 3 element</span></span><br><span class="line">    <span class="comment">// 1.If it is put, we directly put element in stackIn</span></span><br><span class="line">    <span class="comment">//      stackIn     3 2 1</span></span><br><span class="line">    <span class="comment">//      stackOut    null</span></span><br><span class="line">    <span class="comment">// 2.If we want to pop, there will be two cases</span></span><br><span class="line">    <span class="comment">//      2.1.stackOut is null</span></span><br><span class="line">    <span class="comment">//              stackIn     3 2 1</span></span><br><span class="line">    <span class="comment">//              stackOut    null</span></span><br><span class="line">    <span class="comment">//          2.1.1.We transfer all elements in stackIn to stackOut</span></span><br><span class="line">    <span class="comment">//              stackIn     null</span></span><br><span class="line">    <span class="comment">//              stackOut    1 2 3</span></span><br><span class="line">    <span class="comment">//          2.1.2.We pop element from stackOut and get 1</span></span><br><span class="line">    <span class="comment">//              stackIn     null</span></span><br><span class="line">    <span class="comment">//              stackOut    2 3</span></span><br><span class="line">    <span class="comment">//      2.2.stack out is not null</span></span><br><span class="line">    <span class="comment">//              stackIn     6 5 4</span></span><br><span class="line">    <span class="comment">//              stackOut    2 3</span></span><br><span class="line">    <span class="comment">//          2.2.1.We directly pop element from stackOut and get 2</span></span><br><span class="line">    <span class="comment">//              stackIn     null</span></span><br><span class="line">    <span class="comment">//              stackOut    3</span></span><br><span class="line">    <span class="comment">// 3.If we want to peek, it is similar to pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        fillStackOutIfStackOutIsEmpty();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        fillStackOutIfStackOutIsEmpty();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Because we use this function twice, we make it a function</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillStackOutIfStackOutIsEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).</p>
<p>Implement the MyStack class:</p>
<p>- </p>
<p>  void push(int x) Pushes element x to the top of the stack.</p>
<p>- </p>
<p>  int pop() Removes the element on the top of the stack and returns it.</p>
<p>  -int top() Returns the element on the top of the stack.</p>
<p>  -boolean empty() Returns true if the stack is empty, false otherwise.</p>
<p>Notes:</p>
<p>- </p>
<p>  You must use only standard operations of a queue, which means that only push to back, peek&#x2F;pop from front, size and is empty operations are valid.</p>
<p>- </p>
<p>  Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Queues"><a href="#1-Two-Queues" class="headerlink" title="1.Two_Queues"></a>1.Two_Queues</h4><p>This algorithm uses two queues and queue2 is used for just back up.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue2 is actually a backup queue</span></span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue1.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">popped</span> <span class="operator">=</span> popTheLastElementFromQueue1AndPutOthersInQueue2();</span><br><span class="line">        returnQueue2ToQueue1();</span><br><span class="line">        <span class="keyword">return</span> popped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">topped</span> <span class="operator">=</span> popTheLastElementFromQueue1AndPutOthersInQueue2();</span><br><span class="line">        queue2.offer(topped);</span><br><span class="line">        returnQueue2ToQueue1();</span><br><span class="line">        <span class="keyword">return</span> topped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">returnQueue2ToQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue2.isEmpty()) &#123;</span><br><span class="line">            queue1.offer(queue2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">popTheLastElementFromQueue1AndPutOthersInQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            ans = queue1.poll();</span><br><span class="line">            <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">                queue2.offer(ans);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-One-Queue"><a href="#2-One-Queue" class="headerlink" title="2.One_Queue"></a>2.One_Queue</h4><p>We pop elements and put it back until we come to the the last element.</p>
<p>The question then comes to how we can know if it is the last element.</p>
<p>We can do so by declaring a size field.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * One Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> popTheLastElementAndPutOtherElementsInQueue();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> popTheLastElementAndPutOtherElementsInQueue();</span><br><span class="line">        size--;</span><br><span class="line">        push(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">popTheLastElementAndPutOtherElementsInQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (tempSize != <span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">            tempSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Day11 Stack And Queue Part02</title>
    <url>/2023/04/29/Day11-Stack-And-Queue-Part02/</url>
    <content><![CDATA[<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. Valid Parentheses</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li><p>Open brackets must be closed by the same type of brackets.</p>
</li>
<li><p>Open brackets must be closed in the correct order.</p>
</li>
<li><p>Every close bracket has a corresponding open bracket of the same type.</p>
</li>
</ol>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Stack"><a href="#1-Stack" class="headerlink" title="1.Stack"></a>1.Stack</h4><p>Use stack to solve this question</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// Deque is better than Stack</span></span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// push if it is left</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != s.charAt(i)) &#123;</span><br><span class="line">            <span class="comment">// This is the case when it is right element</span></span><br><span class="line">            <span class="comment">// But either the stack is already empty or element on the top is not the right one</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is the case when everything is fine</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// In the last case where the iteration is over but stack is not empty, return false</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.</p>
<p>We repeatedly make duplicate removals on s until we no longer can.</p>
<p>Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Stack-1"><a href="#1-Stack-1" class="headerlink" title="1.Stack"></a>1.Stack</h4><p>Use stack to solve this question</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != c) &#123;</span><br><span class="line">            <span class="comment">// Two cases when we can push element</span></span><br><span class="line">            <span class="comment">// 1. stack is empty</span></span><br><span class="line">            <span class="comment">// 2. the element on the top is not c</span></span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// In the case when element ont the top is c</span></span><br><span class="line">            <span class="comment">// we pop</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// pay attention to the sequence since it is stack</span></span><br><span class="line">        str = stack.pop() + str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two_Pointer"></a>2.Two_Pointer</h4><p>We can use two pointer to simulate stack.</p>
<p>The point is to replace chars[slow] with chars[fast]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// We can use two pointer to simulate stack</span></span><br><span class="line">    <span class="comment">//      a   a   b   b   c</span></span><br><span class="line">    <span class="comment">// 0    s/f</span></span><br><span class="line">    <span class="comment">// 1        s/f</span></span><br><span class="line">    <span class="comment">// 2    s       f</span></span><br><span class="line">    <span class="comment">// 3        s       f</span></span><br><span class="line">    <span class="comment">// 4    s               f</span></span><br><span class="line">    <span class="comment">// char[s] would be replaced with char[fast]</span></span><br><span class="line">    <span class="comment">// what is finally returned would be 0 - slow</span></span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// replace chars[slow] with chars[fast]</span></span><br><span class="line">        chars[slow] = chars[fast];</span><br><span class="line">        <span class="comment">// judge if it is adjacent</span></span><br><span class="line">        <span class="keyword">if</span> (slow &gt; <span class="number">0</span> &amp;&amp; chars[slow] == chars[slow - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// it is adjacent, so slow moves back</span></span><br><span class="line">            slow--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// it is not adjacent, so slow moves forward</span></span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, slow);</span><br><span class="line">&#125; 	</span><br></pre></td></tr></table></figure>

<h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.</p>
<p>Evaluate the expression. Return an integer that represents the value of the expression.</p>
<p>Note that:</p>
<ul>
<li><p>The valid operators are ‘+’, ‘-‘, ‘*’, and ‘&#x2F;‘.</p>
</li>
<li><p>Each operand may be an integer or another expression.</p>
</li>
<li><p>The division between two integers always truncates toward zero.</p>
</li>
<li><p>There will not be any division by zero.</p>
</li>
<li><p>The input represents a valid arithmetic expression in a reverse polish notation.</p>
</li>
<li><p>The answer and all the intermediate calculations can be represented in a 32-bit integer.</p>
</li>
</ul>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Stack-2"><a href="#1-Stack-2" class="headerlink" title="1.Stack"></a>1.Stack</h4><p>Reverse Polish Notation is a reflection of how computer works</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    <span class="comment">// Use Deque&lt;Integer&gt; rather than Deque&lt;String&gt;</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(-stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(stack.pop() * stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">divider</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">divided</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            stack.push(divided / divider);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(Integer.valueOf(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Day13 Stack And Queue Part03</title>
    <url>/2023/05/01/Day13-Stack-And-Queue-Part03/</url>
    <content><![CDATA[<h2 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return the max sliding window.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Monotonic-Queue"><a href="#1-Monotonic-Queue" class="headerlink" title="1.Monotonic_Queue"></a>1.Monotonic_Queue</h4><p>We can adopt monotonic queue to maintain only the necessary element, namely, the element that might be the maximum number in the self-designed two-sided queue.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Monotonic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// We can adopt monotonic queue to solve this question</span></span><br><span class="line">    <span class="comment">// Suppose nums = &#123;1,3,-1,-3,5,3,6,7&#125;, k = 3</span></span><br><span class="line">    <span class="comment">//      1   3   -1  -3  5   3   6   6</span></span><br><span class="line">    <span class="comment">// 0    l       r</span></span><br><span class="line">    <span class="comment">// 0 1: 1</span></span><br><span class="line">    <span class="comment">// 0 1: We push left element</span></span><br><span class="line">    <span class="comment">// 0 2: 3</span></span><br><span class="line">    <span class="comment">// 0 2: Since 3 is bigger than 1, we can just pop 1 because it is pointless to maintain it</span></span><br><span class="line">    <span class="comment">// 0 3: 3   -1</span></span><br><span class="line">    <span class="comment">// 0 3: We push -1 because it is smaller than 3</span></span><br><span class="line">    <span class="comment">//      1   3   -1  -3  5   3   6   6</span></span><br><span class="line">    <span class="comment">// 1        l       r</span></span><br><span class="line">    <span class="comment">// 1 1: 3   -1  -3</span></span><br><span class="line">    <span class="comment">// 1 1: We must pop 1 if following the requirement but actually 1 has already been popped</span></span><br><span class="line">    <span class="comment">// and the element 1 that should have been popped is not the current max value, so no</span></span><br><span class="line">    <span class="comment">// other action except push -3 that is smaller than 3 should be carried out</span></span><br><span class="line">    <span class="comment">//      1   3   -1  -3  5   3   6   6</span></span><br><span class="line">    <span class="comment">// 2            l       r</span></span><br><span class="line">    <span class="comment">// 2 1: -1  -3</span></span><br><span class="line">    <span class="comment">// 2 1: We must pop 3 according to the requirement, and it is just the biggest element, so</span></span><br><span class="line">    <span class="comment">// it would be popped from our queue</span></span><br><span class="line">    <span class="comment">// 2 2: -1  -3  5</span></span><br><span class="line">    <span class="comment">// 2 2: We push 5 into the queue</span></span><br><span class="line">    <span class="comment">// 2 3: 5</span></span><br><span class="line">    <span class="comment">// 2 3: Since 5 is the biggest element, all elements before it would be popped.</span></span><br><span class="line">    <span class="comment">// This is how our queue works</span></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left + k - <span class="number">1</span>&lt; nums.length; left++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            myQueue.pop(nums[left - <span class="number">1</span>]);</span><br><span class="line">            myQueue.push(nums[right]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                myQueue.push(nums[left + i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> myQueue.getMax();</span><br><span class="line">        ans[left] = maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">// Deque is a two-sided queue which is the only solution while pushing</span></span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We must keep it monotonic, so while pushing, we would remove all elements that are</span></span><br><span class="line">    <span class="comment">// smaller than the to-be pushed one from, quite importantly speaking, from tail</span></span><br><span class="line">    <span class="comment">// For example</span></span><br><span class="line">    <span class="comment">//      3   -1</span></span><br><span class="line">    <span class="comment">// And 2 is to be pushed</span></span><br><span class="line">    <span class="comment">// We must remove -1, so the result would be</span></span><br><span class="line">    <span class="comment">//      3   2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.getLast() &lt; x) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only when the to-be popped element equal the first element will we pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.getFirst() == x) &#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Min-Heap"><a href="#1-Min-Heap" class="headerlink" title="1. Min Heap"></a>1. Min Heap</h4><p>We can rely on the data structure, min heap, to solve this question because this kind of structure is quite good at collecting the extreme number among a lot of numbers through its top, where the extreme number, the smallest one if it is min heap and the biggest one if it is max heap is stored.</p>
<p><a href="https://postimg.cc/gLKtxdCb"><img src="https://i.postimg.cc/tJKKm4DJ/Day12-Stack-And-Queue-Part03-01.jpg" alt="Day12-Stack-And-Queue-Part03-01.jpg"></a><br>    min heap</p>
<p>One question which arises is why we use min heap rather than max heap in this question. That is because the min heap stores the element with the lowest frequency on its top and we can pop the top element if the heap’s size surpasses k, which is the size of to-be-returned array, leaving elements with the highest frequency at last.</p>
<p>Another question is how we can realize min heap in java. The answer is priority queue, but we must realize its comparator in this question.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Min Heap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 1.We first iterate nums and get the hashmap that records frequency of each element</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">            map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.We rely on min heap in this question and the realization of it in java is</span></span><br><span class="line">    <span class="comment">//  priority queue</span></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// It should be a min heap, which means the smallest one should be on the top</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getValue() - o2.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.We then iterate map and put element in the priorityQueue</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        priorityQueue.offer(entry);</span><br><span class="line">        <span class="comment">// If the size of priorityQueue is bigger than k, it means we should remove the top element,</span></span><br><span class="line">        <span class="comment">// which is the current number with the lowest frequency</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &gt; k) &#123;</span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.We finally fill the array</span></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="comment">// 5.Although the question does not ask for return the array in desc order, we can do so</span></span><br><span class="line">    <span class="comment">// by iterating from end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ans[i] = priorityQueue.poll().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Monotonic</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Day14 Binary Tree Part01</title>
    <url>/2023/05/02/Day14-Binary-Tree-Part01/</url>
    <content><![CDATA[<h2 id="Binary-Tree-Concept"><a href="#Binary-Tree-Concept" class="headerlink" title="Binary Tree Concept"></a>Binary Tree Concept</h2><h3 id="1-Perfect-Binary-Tree-amp-Complete-Binary-Tree"><a href="#1-Perfect-Binary-Tree-amp-Complete-Binary-Tree" class="headerlink" title="1.Perfect Binary Tree &amp; Complete Binary Tree"></a>1.Perfect Binary Tree &amp; Complete Binary Tree</h3><h4 id="1-1-Perfect-Binary-Tree"><a href="#1-1-Perfect-Binary-Tree" class="headerlink" title="1.1.Perfect Binary Tree"></a>1.1.Perfect Binary Tree</h4><p>The degree of its nodes is either 2 or 0(for nodes that are at bottom)</p>
<p><a href="https://postimg.cc/3k9bpbTH"><img src="https://i.postimg.cc/7LyvFptb/Day-14-Binary-Tree-Part01-01.jpg" alt="Day-14-Binary-Tree-Part01-01.jpg"></a></p>
<span id="more"></span>

<h4 id="1-2-Complete-Binary-Tree"><a href="#1-2-Complete-Binary-Tree" class="headerlink" title="1.2.Complete Binary Tree"></a>1.2.Complete Binary Tree</h4><p>Except for the bottom layer, all other layers should be filled with nodes in maximum number. And as for the bottom layer, nodes can only be filled in the order from left to right. If there is a node at bottom with its left-sided node empty, this tree would not be complete binary tree.</p>
<p><a href="https://postimg.cc/rRm5BgH5"><img src="https://i.postimg.cc/T1jQW4qN/Day-14-Binary-Tree-Part01-02.jpg" alt="Day-14-Binary-Tree-Part01-02.jpg"></a></p>
<h3 id="2-Binary-Search-Tree"><a href="#2-Binary-Search-Tree" class="headerlink" title="2.Binary Search Tree"></a>2.Binary Search Tree</h3><h4 id="2-1-Binary-Search-Tree"><a href="#2-1-Binary-Search-Tree" class="headerlink" title="2.1.Binary Search Tree"></a>2.1.Binary Search Tree</h4><p>Binary search tree is a tree with order.</p>
<ul>
<li>If one node has left subtree, then all nodes from this subtree is smaller than this node.</li>
<li>If one node has right subtree, then all nodes from this subtree is bigger than this node.</li>
<li>The left subtree and the right subtree of one node is also binary search tree.</li>
</ul>
<p> &#x2F;** * Min Heap *&#x2F;public int[] topKFrequent(int[] nums, int k) {    &#x2F;&#x2F; 1.We first iterate nums and get the hashmap that records frequency of each element    HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();    for (int i &#x3D; 0; i &lt; nums.length; i++) {        if (map.containsKey(nums[i])) {            map.put(nums[i], map.get(nums[i]) + 1);        } else {            map.put(nums[i], 1);        }    }    &#x2F;&#x2F; 2.We rely on min heap in this question and the realization of it in java is    &#x2F;&#x2F;  priority queue    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {        @Override        &#x2F;&#x2F; It should be a min heap, which means the smallest one should be on the top        public int compare(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2) {            return o1.getValue() - o2.getValue();        }    });    &#x2F;&#x2F; 3.We then iterate map and put element in the priorityQueue    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {        priorityQueue.offer(entry);        &#x2F;&#x2F; If the size of priorityQueue is bigger than k, it means we should remove the top element,        &#x2F;&#x2F; which is the current number with the lowest frequency        if (priorityQueue.size() &gt; k) {            priorityQueue.poll();        }    }    &#x2F;&#x2F; 4.We finally fill the array    int[] ans &#x3D; new int[k];    &#x2F;&#x2F; 5.Although the question does not ask for return the array in desc order, we can do so    &#x2F;&#x2F; by iterating from end    for (int i &#x3D; k - 1; i &gt;&#x3D; 0; i–) {        ans[i] &#x3D; priorityQueue.poll().getKey();    }    return ans;}java</p>
<h4 id="2-2-AVL-Tree"><a href="#2-2-AVL-Tree" class="headerlink" title="2.2.AVL Tree"></a>2.2.AVL Tree</h4><p>AVL tree is a special search tree.</p>
<ul>
<li>It can be an empty tree</li>
<li>Or if is not empty, the absolute height difference of the left subtree and the right one from the root should not surpass 1.</li>
<li>Both its left and right subtree are AVL trees.</li>
</ul>
<p><a href="https://postimg.cc/4mZF2hsP"><img src="https://i.postimg.cc/vH6FBWKJ/Day-14-Binary-Tree-Part01-04.jpg" alt="Day-14-Binary-Tree-Part01-04.jpg"></a></p>
<h3 id="3-The-Implementation-of-Binary-Tree"><a href="#3-The-Implementation-of-Binary-Tree" class="headerlink" title="3.The Implementation of Binary Tree"></a>3.The Implementation of Binary Tree</h3><h4 id="3-1-Linked-List"><a href="#3-1-Linked-List" class="headerlink" title="3.1.Linked List"></a>3.1.Linked List</h4><p>We can implement binary tree through linked list that has fields of left son node and right son node, which is easy to understand.</p>
<h4 id="3-2-Array"><a href="#3-2-Array" class="headerlink" title="3.2.Array"></a>3.2.Array</h4><p>We can also use array to implement binary tree.</p>
<p>If the index of the node is i, then its left son has the index of (i * 2 + 1) and its right son (i * 2 + 2)</p>
<p><a href="https://postimg.cc/5QMYSJc7"><img src="https://i.postimg.cc/C5RGYMcg/Day-14-Binary-Tree-Part01-05.jpg" alt="Day-14-Binary-Tree-Part01-05.jpg"></a></p>
<h3 id="4-The-Iteration-of-Binary-Tree"><a href="#4-The-Iteration-of-Binary-Tree" class="headerlink" title="4.The Iteration of Binary Tree"></a>4.The Iteration of Binary Tree</h3><h4 id="4-1-DFS"><a href="#4-1-DFS" class="headerlink" title="4.1.DFS"></a>4.1.DFS</h4><p>Understand all three methods by the position of root.</p>
<h5 id="4-1-1-PreOrder"><a href="#4-1-1-PreOrder" class="headerlink" title="4.1.1.PreOrder"></a>4.1.1.PreOrder</h5><p>Root at head</p>
<p><a href="https://postimg.cc/2LhzTLdh"><img src="https://i.postimg.cc/fygJzxJ2/Day-14-Binary-Tree-Part01-06.jpg" alt="Day-14-Binary-Tree-Part01-06.jpg"></a></p>
<h5 id="4-1-2-InOrder"><a href="#4-1-2-InOrder" class="headerlink" title="4.1.2.InOrder"></a>4.1.2.InOrder</h5><p>Root at middle</p>
<p><a href="https://postimg.cc/mtWZkVRw"><img src="https://i.postimg.cc/pXpm016g/Day-14-Binary-Tree-Part01-07.jpg" alt="Day-14-Binary-Tree-Part01-07.jpg"></a></p>
<h5 id="4-1-3PostOrder"><a href="#4-1-3PostOrder" class="headerlink" title="4.1.3PostOrder"></a>4.1.3PostOrder</h5><p>Root at end</p>
<p><a href="https://postimg.cc/xqzT9Br8"><img src="https://i.postimg.cc/v8P1td3r/Day-14-Binary-Tree-Part01-08.jpg" alt="Day-14-Binary-Tree-Part01-08.jpg"></a></p>
<h4 id="4-2-BFS"><a href="#4-2-BFS" class="headerlink" title="4.2.BFS"></a>4.2.BFS</h4><p>By layer</p>
<h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the preorder traversal of its nodes’ values.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion"><a href="#1-Recursion" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>We can follow three rules while writing recursion</p>
<ol>
<li>Confirm the params and returned value of recursion function</li>
<li>Confirm the end condition, otherwise there might be stack overflow</li>
<li>Confirm the logic of single layer of recursion</li>
</ol>
<p>As for preorder traversal, we can realize three rules</p>
<ol>
<li><p>The params should be the current node and the container that stores the result</p>
<ul>
<li>void preorder(Treenode root, List<Integer> list)</li>
</ul>
</li>
<li><p>The end condition should be when the current root is null, which means it is time to return</p>
<ul>
<li>if (root &#x3D;&#x3D; null) {return}</li>
</ul>
</li>
<li><p>The logic of single layer is to firstly store the root, then do recursion of its left, and at last do recursion of its right</p>
<ul>
<li>list.add(root.value);</li>
<li>preorder(root.left, list);</li>
<li>preorder(root.right, list);</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    preorder(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preorder(root.left, list);</span><br><span class="line">    preorder(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Stack"><a href="#2-Stack" class="headerlink" title="2.Stack"></a>2.Stack</h4><p>We can also use a stack to do the iteration rather than recursion</p>
<p>For example, if a tree is </p>
<p>​		5</p>
<p>​	4	6</p>
<p>1	2</p>
<p>We use a stack to iterate</p>
<ol>
<li>stack: 5 <ul>
<li>then 5 is popped and added to list</li>
<li>list: 5</li>
</ul>
</li>
<li>stack: 6<ul>
<li>We first put the right son of 5 because it is stack and what is pushed first gets popped last</li>
</ul>
</li>
<li>stack: 6 4<ul>
<li>We then put the left son of 5</li>
</ul>
</li>
<li>stack: 6<ul>
<li>4 gets popped out and added to list</li>
<li>list: 5 4</li>
</ul>
</li>
<li>stack: 6 2<ul>
<li>The right son of 4 gets pushed in</li>
</ul>
</li>
<li>stack: 6 2 1<ul>
<li>The left son of 4 gets pushed in</li>
</ul>
</li>
<li>stack: 6 2<ul>
<li>1 gets popped out and added to list</li>
<li>list: 5 4 1</li>
</ul>
</li>
<li>stack: 6<ul>
<li>2 gets popped out and added to list</li>
<li>list: 5 4 1 2</li>
</ul>
</li>
<li>stack: <ul>
<li>6 gets popped out and added to list</li>
<li>list: 5 4 1 2 6</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// Put the root in stack so that iteration can begin</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// We must pay attention to the order of pushing</span></span><br><span class="line">        <span class="comment">// Since it is preorder, the order would be to root, root.left and root.right</span></span><br><span class="line">        <span class="comment">// But for stack, the popped out element would be the last element pushed</span></span><br><span class="line">        <span class="comment">// So the push order should be opposite to the preorder order, which means</span></span><br><span class="line">        <span class="comment">// we should push right first, then left</span></span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. Binary Tree Postorder Traversal</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the postorder traversal of its nodes’ values.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-1"><a href="#1-Recursion-1" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>As for postorder traversal, we can realize three rules</p>
<ol>
<li><p>The params should be the current node and the container that stores the result</p>
<ul>
<li>void preorder(Treenode root, List<Integer> list)</li>
</ul>
</li>
<li><p>The end condition should be when the current root is null, which means it is time to return</p>
<ul>
<li>if (root &#x3D;&#x3D; null) {return}</li>
</ul>
</li>
<li><p>The logic of single layer is to firstly do recursion of its left, then do recursion of its right, and at last store root’s value</p>
<ul>
<li><p>preorder(root.left, list);</p>
</li>
<li><p>preorder(root.right, list);</p>
</li>
<li><p>list.add(root.value);</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    postorder(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root.left, list);</span><br><span class="line">    postorder(root.right, list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Stack-1"><a href="#2-Stack-1" class="headerlink" title="2.Stack"></a>2.Stack</h4><p>Postorder can be modified from preorder since the order of postorder, which is left, right, root, can be achieved by firstly swapping the order of left and right from preorder followed by reversing the result list.</p>
<p>For example, if a tree is </p>
<p>​		5</p>
<p>​	4	6</p>
<p>1	2</p>
<p>We use a stack to iterate</p>
<ol>
<li><p>stack: 5 </p>
<ul>
<li>then 5 is popped and added to list</li>
<li>list: 5</li>
</ul>
</li>
<li><p>stack: 4</p>
<ul>
<li>We first put the left son of 5 because it is stack and what is pushed first gets popped last</li>
</ul>
</li>
<li><p>stack: 4 6</p>
<ul>
<li>We then put the right son of 5</li>
</ul>
</li>
<li><p>stack: 4</p>
<ul>
<li>6 gets popped out and added to list</li>
<li>list: 5 6</li>
</ul>
</li>
<li><p>stack: 1</p>
<ul>
<li>4 gets popped and added to list</li>
<li>The left son of 4 gets pushed in</li>
<li>list: 5 6 4</li>
</ul>
</li>
<li><p>stack: 1 2</p>
<ul>
<li>The right son of 4 gets pushed in</li>
</ul>
</li>
<li><p>stack: 1</p>
<ul>
<li>2 gets popped out and added to list</li>
<li>list: 5 6 4 2</li>
</ul>
</li>
<li><p>stack: </p>
<ul>
<li>1 gets popped out and added to list</li>
<li>list: 5 6 4 2 1</li>
</ul>
</li>
<li><p>We finally reverse the list and get what we want</p>
<ul>
<li>list: 1 2 4 6 5</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// Put the root in stack so that iteration can begin</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// We must pay attention to the order of pushing</span></span><br><span class="line">        <span class="comment">// Since it is postorder, the order would be to root.left, root.right and root</span></span><br><span class="line">        <span class="comment">// But for stack, the popped out element would be the last element pushed</span></span><br><span class="line">        <span class="comment">// So the push order should be opposite to the preorder order, which means</span></span><br><span class="line">        <span class="comment">// we should push left first, then right</span></span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Since postorder is modified from preorder, we have to reverse the list at last.</span></span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the inorder traversal of its nodes’ values.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-2"><a href="#1-Recursion-2" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>As for inorder traversal, we can realize three rules</p>
<ol>
<li><p>The params should be the current node and the container that stores the result</p>
<ul>
<li>void preorder(Treenode root, List<Integer> list)</li>
</ul>
</li>
<li><p>The end condition should be when the current root is null, which means it is time to return</p>
<ul>
<li>if (root &#x3D;&#x3D; null) {return}</li>
</ul>
</li>
<li><p>The logic of single layer is to firstly do recursion of its left, then store root’s value, and at last do recursion of its right</p>
<ul>
<li><p>preorder(root.left, list);</p>
</li>
<li><p>list.add(root.value);</p>
</li>
<li><p>preorder(root.right, list);</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    inorder(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inorder(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Stack-2"><a href="#2-Stack-2" class="headerlink" title="2.Stack"></a>2.Stack</h4><p>Using stack to iterate tree in inorder is more difficult than previous two orders because the order of visiting each node and the order of dealing with each node is different. When we visit the root, we cannot add it in the result list until we visit the left node at bottom. To solve this problem, we can introduce a cursor that points to the node we visit.</p>
<p>For example, if a tree is </p>
<p>​		5</p>
<p>​	4	6</p>
<p>1	2</p>
<p>We use a stack and cursor to iterate</p>
<ol>
<li>stack: null<ul>
<li>cur &#x3D; 5</li>
</ul>
</li>
<li>stack: 5<ul>
<li>cur &#x3D; 5.left &#x3D; 4</li>
</ul>
</li>
<li>stack: 5 4<ul>
<li>cur &#x3D; 4.left &#x3D; 1</li>
</ul>
</li>
<li>stack: 5 4 1<ul>
<li>cur &#x3D; 1.left &#x3D; null</li>
</ul>
</li>
<li>stack: 5 4<ul>
<li>cur &#x3D; 1.right &#x3D; null</li>
<li>list: 1</li>
</ul>
</li>
<li>stack: 5<ul>
<li>cur &#x3D; 4.right &#x3D; 2</li>
<li>list: 1 4</li>
</ul>
</li>
<li>stack: 5 2<ul>
<li>cur &#x3D; 2.left &#x3D; null</li>
</ul>
</li>
<li>stack: 5<ul>
<li>cur &#x3D; 2.right &#x3D; null</li>
<li>list: 1 4 2</li>
</ul>
</li>
<li>stack: <ul>
<li>cur &#x3D; 5.right &#x3D; 6</li>
<li>list: 1 4 2 5</li>
</ul>
</li>
<li>stack: 6<ul>
<li>cur &#x3D; 6.left &#x3D; null</li>
</ul>
</li>
<li>stack:<ul>
<li>cur &#x3D; 6.right &#x3D; null</li>
<li>list: 1 4 2 5 6</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We need a cursor to track the node</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Stack</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day16 Binary Tree Part03</title>
    <url>/2023/05/04/Day16-Binary-Tree-Part03/</url>
    <content><![CDATA[<h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>It was written in day 15.</p>
<p>Check it out: <a href="https://zhaoyiwei0311.github.io/2023/05/03/Day15-Binary-Tree-Part02/">104. Maximum Depth of Binary Tree</a></p>
<h4 id="2-Recursion"><a href="#2-Recursion" class="headerlink" title="2.Recursion"></a>2.Recursion</h4><p>There is a difference between <strong>height</strong> and <strong>depth</strong>.</p>
<p>For height, it is counted from bottom to top, which means postorder is a good choice if we want to the height, since it starts from bottom and get returned to the node above, which is exactly the sequence of calculating height.</p>
<p>And as for depth, it is counted from top to bottom. So preorder would be an alternative since it starts from top and transfer the recursion to nodes below, which corresponds to the order of calculating depth.</p>
<p>For this question, we use postorder to track from bottom to top, which means we will actually return the height rather than depth. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// We use postorder and track from bottom to top</span></span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      int maxDepth(TreeNode root)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end condition</span></span><br><span class="line">    <span class="comment">//   We return when we get to null and the returned value should be 0</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, We confirm the logic</span></span><br><span class="line">    <span class="comment">//   Because it is postorder, we must follow the order of left, right and middle</span></span><br><span class="line">    <span class="comment">//      int leftHeight = maxDepth(root.left);</span></span><br><span class="line">    <span class="comment">//      int rightHeight = maxDepth(root.right);</span></span><br><span class="line">    <span class="comment">//      return Math.max(leftHeight, rightHeight);</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> maxDepth(root.left) + <span class="number">1</span>; <span class="comment">// left</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> maxDepth(root.right) + <span class="number">1</span>; <span class="comment">// right</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight); <span class="comment">// middle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given a n-ary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder"><a href="#1-Recursion-Postorder" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>Similar to the previous question.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      int maxDepth(Node root)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">//      if (root.children.size() == 0</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm logic</span></span><br><span class="line">    <span class="comment">// We do an iteration of loop and get the maxDepth just as it were a binary tree</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] childrenArr = <span class="keyword">new</span> <span class="title class_">int</span>[root.children.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.children.size(); i++) &#123;</span><br><span class="line">        childrenArr[i] = maxDepth(root.children.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> childrenArr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childrenArr.length; i++) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, childrenArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxHeight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><p>Much easier to understand</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; popped.children.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (popped.children.get(i) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(popped.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        maxDepth++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder-1"><a href="#1-Recursion-Postorder-1" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>It is far harder than maximum depth because leaf is quite a big trouble getting people easily confused with the concept of height.</p>
<p>For example, in the case below, we may get a wrong answer 1 rather than 3 because we do not really understand what leaf stands for. </p>
<p><a href="https://postimg.cc/CztnFpHt"><img src="https://i.postimg.cc/MpZ7mWcW/Day-16-Binary-Tree-Part03-01.jpg" alt="Day-16-Binary-Tree-Part03-01.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** The logic of this question is much harder than maximum depth because</span></span><br><span class="line"><span class="comment">     *  of the concept of leaf</span></span><br><span class="line"><span class="comment">     *  In the case of</span></span><br><span class="line"><span class="comment">     *              1</span></span><br><span class="line"><span class="comment">     *                  2</span></span><br><span class="line"><span class="comment">     *              3       4</span></span><br><span class="line"><span class="comment">     *          5</span></span><br><span class="line"><span class="comment">     *  The minimum depth should stop at 4</span></span><br><span class="line"><span class="comment">     *  But it is easy to get the answer 1</span></span><br><span class="line"><span class="comment">     *  because we may fail to take the null condition of both left and right sons</span></span><br><span class="line"><span class="comment">     *  into account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">    <span class="comment">// We must separately deal with the null situation</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// in this case, there are still leaves at right</span></span><br><span class="line">        <span class="keyword">return</span> leftDepth + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// in this case, there are still leaves at left</span></span><br><span class="line">        <span class="keyword">return</span> rightDepth + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// in this case, both sides have leaves</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(rightDepth, leftDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Layer-Traversal"><a href="#2-Layer-Traversal" class="headerlink" title="2.Layer Traversal"></a>2.Layer Traversal</h4><p>Layer search is still easier to understand.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// Similarly, the nearest leaf is when two sons are null</span></span><br><span class="line">            <span class="keyword">if</span> (popped != <span class="literal">null</span> &amp;&amp; (popped.left == <span class="literal">null</span> &amp;&amp; popped.right == <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pay attention to the null pointer exception</span></span><br><span class="line">            <span class="keyword">if</span> (popped != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        minDepth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a complete binary tree, return the number of the nodes in the tree.</p>
<p>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.</p>
<p>Design an algorithm that runs in less than O(n) time complexity.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal-Recursion-Postorder"><a href="#1-Normal-Recursion-Postorder" class="headerlink" title="1.Normal + Recursion + Postorder"></a>1.Normal + Recursion + Postorder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      int countNodes(TreeNode root)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end condition</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm logic</span></span><br><span class="line">    <span class="comment">//      int left = countNodes(root.left);</span></span><br><span class="line">    <span class="comment">//      int right = countNodes(root.right);</span></span><br><span class="line">    <span class="comment">//      return left + right + 1</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countNodes(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countNodes(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Layer-Traversal-1"><a href="#2-Layer-Traversal-1" class="headerlink" title="2. Layer Traversal"></a>2. Layer Traversal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        count += size;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Feature-Recursion-Postorder"><a href="#3-Feature-Recursion-Postorder" class="headerlink" title="3.Feature + Recursion + Postorder"></a>3.Feature + Recursion + Postorder</h4><p>We must understand what the complete binary tree is and learn the feature of it. <a href="https://zhaoyiwei0311.github.io/2023/05/02/Day14-Binary-Tree-Part01/">Complete Binary Tree</a></p>
<p>There are only two kinds of complete tree.</p>
<ol>
<li><a href="https://zhaoyiwei0311.github.io/2023/05/02/Day14-Binary-Tree-Part01/">Perfect Binary Tree</a> which is full.</li>
<li>Each layer except the bottom is filled full.</li>
</ol>
<p>For the first case, we just need to get its layer n and calculate (2 ^ n -1), which is the answer.</p>
<p>For the second case, we can rely on recursion and adopt the thought of conquering and divide to find the smallest perfect tree.</p>
<p><a href="https://postimg.cc/HJPq66T5"><img src="https://i.postimg.cc/QtXjxzP6/Day-16-Binary-Tree-Part03-02.jpg" alt="Day-16-Binary-Tree-Part03-02.jpg"></a></p>
<p>Another question arouses that how can we judge whether a tree is a perfect tree.</p>
<p>The answer is we can go deep through both leftmost and rightmost side and count their layers. If layer are same, then it is a perfect tree, otherwise, it is not.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Feature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.First confirm returned value and params</span></span><br><span class="line"><span class="comment">     *      int countNodes(TreeNode root)</span></span><br><span class="line"><span class="comment">     * 2.Then confirm end conditions</span></span><br><span class="line"><span class="comment">     *      if (root == null) &#123;return 0&#125;</span></span><br><span class="line"><span class="comment">     * 3.Finally, confirm logic</span></span><br><span class="line"><span class="comment">     *      3.1.We first need to confirm whether the tree in current recursion is a</span></span><br><span class="line"><span class="comment">     *          perfect tree</span></span><br><span class="line"><span class="comment">     *      3.2.If it is a perfect tree, then just calculate</span></span><br><span class="line"><span class="comment">     *      3.3.If it is not, then do the recursion by adopting divide and conquer thought</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftLayer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightLayer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftLayer++;</span><br><span class="line">        left = left.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightLayer++;</span><br><span class="line">        right = right.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftLayer == rightLayer) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(Math.pow(<span class="number">2</span>, leftLayer) - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.right) + countNodes(root.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Divide_And_Conquer</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day17 Binary Tree Part04</title>
    <url>/2023/05/05/Day17-Binary-Tree-Part04/</url>
    <content><![CDATA[<h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a binary tree, determine if it is <strong>height-balanced</strong>.</p>
<p>Height-balanced means the absolute height difference between left and right subtrees should not surpass 1.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder"><a href="#1-Recursion-Postorder" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>We will have to know the height of each subtree and compare them to get the height difference. In this case, we must use postorder since it can integrate the result form below and transfer the result to upper nodes.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> postorder(root);</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  We use postorder to track the height of subtree</span></span><br><span class="line">    <span class="comment">//      int postorder(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (node == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm logic</span></span><br><span class="line">    <span class="comment">//  if the height difference surpasses 1, then return -1</span></span><br><span class="line">    <span class="comment">//  else return bigger height + 1</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> postorder(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> postorder(node.right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span> || Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. Binary Tree Paths</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return all root-to-leaf paths in any order.</p>
<p>A leaf is a node with no children.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Preorder-Backtrack"><a href="#1-Recursion-Preorder-Backtrack" class="headerlink" title="1.Recursion + Preorder + Backtrack"></a>1.Recursion + Preorder + Backtrack</h4><p>This questions asks for backtrack.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Since string is hard to deal with, we can introduce an arraylist instead for help</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Integer&gt; container = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Preorder + Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.First We must confirm returned value and params</span></span><br><span class="line"><span class="comment">     *  We use outside variables, so it is</span></span><br><span class="line"><span class="comment">     *      void preorder(TreeNode node)</span></span><br><span class="line"><span class="comment">     * 2.Then we must confirm end conditions</span></span><br><span class="line"><span class="comment">     *  if node is null, we will absolutely return</span></span><br><span class="line"><span class="comment">     *  Besides, if node has no children, which means it is a leaf node, we will also</span></span><br><span class="line"><span class="comment">     *  return after manipulating list and container</span></span><br><span class="line"><span class="comment">     *      if (node == null) &#123;return&#125;</span></span><br><span class="line"><span class="comment">     *      if (node.left == null &amp;&amp; node.right == null) &#123;</span></span><br><span class="line"><span class="comment">     *          list.add(convertContainerElementsToFormattedString());</span></span><br><span class="line"><span class="comment">     *          container.remove(container.size() - 1);</span></span><br><span class="line"><span class="comment">     *          return;</span></span><br><span class="line"><span class="comment">     *      &#125;</span></span><br><span class="line"><span class="comment">     * 3.Finally, we must confirm logic</span></span><br><span class="line"><span class="comment">     *  For this question, we are using backtrack, which means we must</span></span><br><span class="line"><span class="comment">     *  pop the last element out</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    container.add(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123; <span class="comment">//leaf node, time to handle list and container</span></span><br><span class="line">        list.add(convertContainerElementsToFormattedString());</span><br><span class="line">        container.remove(container.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(node.left);</span><br><span class="line">    preorder(node.right);</span><br><span class="line">    <span class="comment">// In the end, we will pop the last element from container</span></span><br><span class="line">    container.remove(container.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">convertContainerElementsToFormattedString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; container.size(); i++) &#123;</span><br><span class="line">        stringBuilder.append(container.get(i));</span><br><span class="line">        <span class="keyword">if</span> (i != container.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the sum of all left leaves.</p>
<p>A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder-1"><a href="#1-Recursion-Postorder-1" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>The point in this question is how we can judge whether a node is left leaf. We can only do that by judging its father. If the father node has a non-null left son and its non-null left son has no sons, then we can say it is the father of a left leaf. As for the father’s right son, it does not matter at all. We must understand that well because at the very beginning, I met up with the case of </p>
<p>{1}, which should return 0 </p>
<p>While I mistaken the returned value for 1. The reason is that I did not judge the left leaf from its father but from itself.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//      int sumOfLeftLeaves(TreeNode root)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm the end conditions</span></span><br><span class="line">    <span class="comment">//  As usual, we return 0 if root is null</span></span><br><span class="line">    <span class="comment">//  Besides, we return 0 if root is a leaf node.</span></span><br><span class="line">    <span class="comment">//  Then a question arises that when are we able to add value</span></span><br><span class="line">    <span class="comment">//  and the answer is when we see the father of a left leaf node,</span></span><br><span class="line">    <span class="comment">//  which will be dealt with at logic part</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">//      if (root.left == null &amp;&amp; root.right == null) &#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm the logic</span></span><br><span class="line">    <span class="comment">//  It is postorder, so the order would be left, right and middle</span></span><br><span class="line">    <span class="comment">//  The special point is when the node we are dealing with is the father</span></span><br><span class="line">    <span class="comment">//  of a left leaf. In such case, we will cover the left with the node&#x27;s</span></span><br><span class="line">    <span class="comment">//  left son&#x27;s value and this answers the previous question on how we can add sum.</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">    <span class="comment">// This is the special point when we meet the father of a left leaf,</span></span><br><span class="line">    <span class="comment">// which we will replace left with its son&#x27;s value</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        left = root.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">    sum = left + right;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Level Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// If we meet the father of a left leaf</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span> &amp;&amp; popped.left.left == <span class="literal">null</span> &amp;&amp; popped.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += popped.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>Day18 Binary Tree Part05</title>
    <url>/2023/05/07/Day18-Binary-Tree-Part05/</url>
    <content><![CDATA[<h2 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the leftmost value in the last row of the tree.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Since recursion is hard to detect whether it is the bottom level or not, level traversal might be an easier alternative.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Layer Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">// index == size means we find the leftmost element in this level  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">                <span class="comment">// we replace ans with the leftmost element at new level</span></span><br><span class="line">                ans = popped.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion-Backtrack"><a href="#2-Recursion-Backtrack" class="headerlink" title="2.Recursion + Backtrack"></a>2.Recursion + Backtrack</h4><p>Recursion is harder to understand.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We need two global variables. One to record the current max depth,</span></span><br><span class="line"><span class="comment">// and the other the current ans</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Preorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traversal(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There are two important problems in this question</span></span><br><span class="line"><span class="comment">//  1.The way to know the bottom level.</span></span><br><span class="line"><span class="comment">//  2.The way to know if the node is the leftmost node at bottom.</span></span><br><span class="line"><span class="comment">// For the first problem, we can compare the depth of current level</span></span><br><span class="line"><span class="comment">// traversed with the max depth</span></span><br><span class="line"><span class="comment">// For the second problem, if there are simultaneously two nodes at bottom,</span></span><br><span class="line"><span class="comment">// we can get the right answer by traversing left one first and update the</span></span><br><span class="line"><span class="comment">// max depth as well as ans, then while traversing right side, the current depth</span></span><br><span class="line"><span class="comment">// cannot surpass max depth, the right node would be ignored</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      void traversal(TreeNode node, int depth)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (node == null) &#123;return;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We will use backtrack in this question because depth must be decremented</span></span><br><span class="line">    <span class="comment">//  when returning to upper level</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We get a leaf node and can compare depth now</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If it is the leftmost node, then at that time max depth will still be</span></span><br><span class="line">        <span class="comment">// smaller than depth. But if it is the rightmost node, then the updated</span></span><br><span class="line">        <span class="comment">// max depth will equal to the depth, which blocks further steps</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">            ans = node.val;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">    traversal(node.left, depth);</span><br><span class="line">    traversal(node.right, depth);</span><br><span class="line">    <span class="comment">// We need backtrack</span></span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.cn/problems/path-sum/">112. Path Sum</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p>
<p>A leaf is a node with no children.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Backtrack"><a href="#1-Recursion-Backtrack" class="headerlink" title="1.Recursion + Backtrack"></a>1.Recursion + Backtrack</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      boolean hasPathSum(TreeNode root, int targetSum)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  Two cases would be considered</span></span><br><span class="line">    <span class="comment">//  One is when root is null, which is needless to mention, </span></span><br><span class="line">    <span class="comment">//  The other one is when we find the value of leaf node equals</span></span><br><span class="line">    <span class="comment">//  to the target sum</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We get booleans from both tight and left</span></span><br><span class="line">    <span class="comment">//  and once there is a true, we can return true, otherwise return</span></span><br><span class="line">    <span class="comment">//  false</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == targetSum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetSum = targetSum - root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left, targetSum);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right, targetSum);</span><br><span class="line">    <span class="keyword">return</span> left || right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. Path Sum II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.</p>
<p>A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Backtrack-1"><a href="#1-Recursion-Backtrack-1" class="headerlink" title="1.Recursion + Backtrack"></a>1.Recursion + Backtrack</h4><p>We need to know all the routes, so the traversal function does not to return any specific value but void. This is quite different from the previous one that need to return a Boolean.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Global variables </span></span><br><span class="line"><span class="comment">// One for final answer and the other for temporarily recording path</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    traversal(root, targetSum);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We are tracking all routes, so we do not need to return any specific value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      void traversal(TreeNode node, int targetSum)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  As usual, return if node is null</span></span><br><span class="line">    <span class="comment">//  Besides, when the leaf node happens to be the targetSum, we</span></span><br><span class="line">    <span class="comment">//  will also return as well as put path into list</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We add node to the path and then do traversal to its left and</span></span><br><span class="line">    <span class="comment">//  right node. Finally, we will have to move the node from path</span></span><br><span class="line">    <span class="comment">//  since it is backtrack.</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val == targetSum &amp;&amp; node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="comment">// Remember arraylist is an referenced object</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.add(node.val);</span><br><span class="line">    targetSum = targetSum - node.val;</span><br><span class="line">    traversal(node.left, targetSum);</span><br><span class="line">    traversal(node.right, targetSum);</span><br><span class="line">    <span class="comment">// backtrack that removes the last node entering path</span></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;&#x3D; inorder.length &lt;&#x3D; 3000</li>
<li>postorder.length &#x3D;&#x3D; inorder.length</li>
<li>-3000 &lt;&#x3D; inorder[i], postorder[i] &lt;&#x3D; 3000</li>
<li>inorder and postorder consist of unique values.</li>
<li>Each value of postorder also appears in inorder.</li>
<li>inorder is guaranteed to be the inorder traversal of the tree.</li>
<li>postorder is guaranteed to be the postorder traversal of the tree</li>
</ul>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion"><a href="#1-Recursion" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>The last element of postorder array is the node in the middle, then we can go back to inorder array and divide arrays into two parts, left array and right array, by the middle node we have found. After that, we do recursion in both left array and right array, which is quite like what we do in fast sort. There are, in conclusion, 6 steps that can meet the requirement.</p>
<p><strong>Constraints:</strong></p>
<ol>
<li>if postorder is 0, then it is a null node</li>
<li>find the last element in postorder array which is the middle node</li>
<li>find the cutting point in inorder array by the middle node we have just found</li>
<li>cut inorder array into left side and right side</li>
<li>cut postorder array into left side and right side</li>
<li>do recursion in left side and right side</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// It is more efficient to check the index of node in inorder</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> traversal(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  Returned value is of course TreeNode</span></span><br><span class="line">    <span class="comment">//  And as for param, we will divide into two parts, one is start and end index in inorder array</span></span><br><span class="line">    <span class="comment">//  the other is start and end index in postorder array</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  We stick to left close right close principle, so when end index of inorder - start index of</span></span><br><span class="line">    <span class="comment">//  inorder is negative, we return null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We get the node from tail of postorder array, which is for certain because of the order of</span></span><br><span class="line">    <span class="comment">//  postorder. </span></span><br><span class="line">    <span class="comment">//  Then we get the node&#x27;s index of inorder array through map, which helps us divide</span></span><br><span class="line">    <span class="comment">//  the array into two parts and get the size of each part.</span></span><br><span class="line">    <span class="comment">//  At last, we do recursion. </span></span><br><span class="line">    <span class="keyword">if</span> (inEnd - inStart &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postEnd]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndexInInorder</span> <span class="operator">=</span> map.get(node.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> nodeIndexInInorder - inStart;</span><br><span class="line"></span><br><span class="line">    node.left = traversal(inorder, inStart, nodeIndexInInorder - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// For the right subtree the post end would be postEnd - 1, because the current node is exactly</span></span><br><span class="line">    <span class="comment">// post end and should be popped.</span></span><br><span class="line">    node.right = traversal(inorder, nodeIndexInInorder + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h2><h3 id="Intro-4"><a href="#Intro-4" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>
<p><strong>Constraints:</strong></p>
<ol>
<li><p>if postorder is 0, then it is a null node</p>
</li>
<li><p>find the last element in postorder array which is the middle node</p>
</li>
<li><p>find the cutting point in inorder array by the middle node we have just found</p>
</li>
<li><p>cut inorder array into left side and right side</p>
</li>
<li><p>cut postorder array into left side and right side</p>
</li>
<li><p>do recursion in left side and right side</p>
</li>
</ol>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-1"><a href="#1-Recursion-1" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>Almost same to the previous question.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// It is more efficient to check the index of node in inorder</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> traversal(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inEnd - inStart &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndexInInorder</span> <span class="operator">=</span> map.get(node.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> nodeIndexInInorder - inStart;</span><br><span class="line"></span><br><span class="line">    node.left = traversal(inorder, inStart, nodeIndexInInorder - <span class="number">1</span>, preorder, preStart + <span class="number">1</span>, preStart + leftSize);</span><br><span class="line">    node.right = traversal(inorder, nodeIndexInInorder + <span class="number">1</span>, inEnd, preorder, preStart + leftSize + <span class="number">1</span>, preEnd);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Divide_And_Conquer</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>Day20 Binary Tree Part06</title>
    <url>/2023/05/08/Day20-Binary-Tree-Part06/</url>
    <content><![CDATA[<h2 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:</p>
<ol>
<li>Create a root node whose value is the maximum value in nums.</li>
<li>Recursively build the left subtree on the subarray prefix to the left of the maximum value.</li>
<li>Recursively build the right subtree on the subarray suffix to the right of the maximum value.</li>
</ol>
<p>Return the maximum binary tree built from nums.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion"><a href="#1-Recursion" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>It is quite similar to the [106. Construct Binary Tree from Inorder and Postorder Traversal](app:&#x2F;&#x2F;obsidian.md&#x2F;Day18 Binary Tree Part05#<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> traversal(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  we use pointer to cut array, so what we need for extra is a start pointer and an</span></span><br><span class="line">    <span class="comment">//  end one.</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  if end - start &lt; 0, it means that we can only have null node for child, which</span></span><br><span class="line">    <span class="comment">//  results in returning null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  we do recursion with different start and end</span></span><br><span class="line">    <span class="keyword">if</span> (end - start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(max);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> maxIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightStart</span> <span class="operator">=</span> maxIndex + <span class="number">1</span>;</span><br><span class="line">    node.left = traversal(nums, start, leftEnd);</span><br><span class="line">    node.right = traversal(nums, rightStart, end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>You are given two binary trees root1 and root2.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return the merged tree.</p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>I have thought too much at first while dealing with the case like one node’s left is null while the other one’s is not. Actually, it does not matter because we can just replace null node with non-null node if node1’s left is null and if node2’s left is null, we can even do nothing because node1’s left can just remain correct.</p>
<p>As for the case when both nodes’ left are null, I also thought too much at first. But in fact, putting only non-null nodes into queues can just avoid this situation.</p>
<p>Also there is one more point to mention. While handling null situation, we can firstly judge node1 and if node1 is null, we can just simply return node2. Then judge node2 in the same way. Even in the case when both nodes are null, this method is also correct.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Layer Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">    <span class="comment">// if (root1 == null &amp;&amp; root2 == null) &#123;</span></span><br><span class="line">    <span class="comment">//     return null;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// codes above can be converted to the codes below, which is more concise</span></span><br><span class="line">    <span class="comment">// and can avoid bugs in case like root1 == null and root2 == [1]</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue1.add(root1);</span><br><span class="line">    queue2.add(root2);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We will only put non-null node in queues, so these two nodes popped</span></span><br><span class="line">        <span class="comment">// will not be null</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">popped1</span> <span class="operator">=</span> queue1.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">popped2</span> <span class="operator">=</span> queue2.poll();</span><br><span class="line">        popped1.val += popped2.val;</span><br><span class="line">        <span class="keyword">if</span> (popped1.left != <span class="literal">null</span> &amp;&amp; popped2.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue1.add(popped1.left);</span><br><span class="line">            queue2.add(popped2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (popped1.right != <span class="literal">null</span> &amp;&amp; popped2.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue1.add(popped1.right);</span><br><span class="line">            queue2.add(popped2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// What about popped1.left != null &amp;&amp; popped2.left == null</span></span><br><span class="line">        <span class="comment">// Actually, this does not matter because there will be no subtree of</span></span><br><span class="line">        <span class="comment">// popped2.left, so popped1.left will just remain.</span></span><br><span class="line">        <span class="keyword">if</span> (popped1.left == <span class="literal">null</span> &amp;&amp; popped2.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            popped1.left = popped2.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (popped1.right == <span class="literal">null</span> &amp;&amp; popped2.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            popped1.right = popped2.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion-Preorder"><a href="#2-Recursion-Preorder" class="headerlink" title="2. Recursion + Preorder"></a>2. Recursion + Preorder</h4><p>Pay attention to end conditions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Preorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      TreeNode mergeTrees(TreeNode root1, TreeNode root2)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  Still we return when we face null conditions, but there are two nodes now,</span></span><br><span class="line">    <span class="comment">//  so shall we judge three times to see if both are null or node1 is null or</span></span><br><span class="line">    <span class="comment">//  node2 is null?</span></span><br><span class="line">    <span class="comment">//  Actually there is no need. We can judge firstly node1 and return node2 if node1</span></span><br><span class="line">    <span class="comment">//  is null. Then we can judge node2 and return node1 if node2 is null. This can</span></span><br><span class="line">    <span class="comment">//  apply even for the case when two nodes are null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We just add up values.</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    root1.val += root2.val;</span><br><span class="line">    root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">    root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. Search in a Binary Search Tree</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>You are given the root of a binary search tree (BST) and an integer val.</p>
<p>Find the node in the BST that the node’s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-1"><a href="#1-Recursion-1" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      TreeNode searchBST(TreeNode root, int val)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  We return when root is null or root&#x27;s value equals to val</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  Since it is binary search tree, we can search like doing binary</span></span><br><span class="line">    <span class="comment">//  search in an ordered array</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if (root == null) &#123;</span></span><br><span class="line">    <span class="comment">//     return null;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// if (root.val == val) &#123;</span></span><br><span class="line">    <span class="comment">//     return root;</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// more concisely</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode next;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">        next = root.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchBST(next, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2. Level Traversal"></a>2. Level Traversal</h4><p>The feature of binary search tree enables us not to rely on a queue. Just go left or right</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Level Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// We must fully utilize binary search tree</span></span><br><span class="line">    <span class="comment">// if val is bigger than root&#x27;s value, we go left</span></span><br><span class="line">    <span class="comment">// else we go right</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>A valid BST is defined as follows:</p>
<p>- </p>
<p>  The left subtree of a node contains only nodes with keys less than the node’s key.</p>
<p>- </p>
<p>  The right subtree of a node contains only nodes with keys greater than the node’s key.</p>
<p>- </p>
<p>  Both the left and right subtrees must also be binary search trees.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Inorder"><a href="#1-Recursion-Inorder" class="headerlink" title="1.Recursion + Inorder"></a>1.Recursion + Inorder</h4><p>From left to middle to right, the binary search tree can be seen as an ascending order array, which means we can set a benchmark value and do an inorder recursion to see if the current node’s value is bigger than benchmark. If it is, then return true and update benchmark with node’s value, otherwise return false.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The benchmark value</span></span><br><span class="line"><span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Inorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      boolean isValidBST(TreeNode root)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (root == null) &#123;return true&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We follow the order of left, middle and right.</span></span><br><span class="line">    <span class="comment">//  When it is middle, we do comparison with value and current node&#x27;s val.</span></span><br><span class="line">    <span class="comment">//  If value is smaller, then we update it with current node&#x27;s val</span></span><br><span class="line">    <span class="comment">//  Otherwise, we return false</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value = root.val;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day21 Binary Tree Part07</title>
    <url>/2023/05/09/Day21-Binary-Tree-Part07/</url>
    <content><![CDATA[<h2 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Preorder"><a href="#1-Recursion-Preorder" class="headerlink" title="1.Recursion + Preorder"></a>1.Recursion + Preorder</h4><p>We must fully utilize features of BST and the best way to do it is by  using inorder recursion.</p>
<p>Another point is to record the previous node and calculate difference with the current node.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We need to record the previous node</span></span><br><span class="line">TreeNode pre;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Inorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traversal(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      void traversal(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (node == null) &#123;return&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We have recorded the previous node. So we can calculate</span></span><br><span class="line">    <span class="comment">//  its difference with the current node if previous node is</span></span><br><span class="line">    <span class="comment">//  not null. In any case, we must update previous node with</span></span><br><span class="line">    <span class="comment">//  the current one.</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traversal(node.left);</span><br><span class="line">    <span class="comment">// for the root since root&#x27;s previous is null</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">        result = Math.min(result, node.val - pre.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update previous node</span></span><br><span class="line">    pre = node;</span><br><span class="line">    traversal(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><p>Level traversal also follows inorder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We need to record previous node</span></span><br><span class="line">TreeNode pre;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Level Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We do not push root into stack at first, but makes a pointer</span></span><br><span class="line">    <span class="comment">// pointing to it.</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            <span class="comment">// left</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// middle</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">                result = Math.min(result, cur.val - pre.val);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">// right</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.</p>
<p>If the tree has more than one mode, return them in any order.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent"><a href="#1-Violent" class="headerlink" title="1.Violent"></a>1.Violent</h4><p>If it were not BST, we can rely on map and do a violent search.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Violent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == maxCount) &#123;</span><br><span class="line">            list.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        ans[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traversal(node.left);</span><br><span class="line">    traversal(node.right);</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(node.val)) &#123;</span><br><span class="line">        map.put(node.val, map.get(node.val) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(node.val, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    maxCount = Math.max(map.get(node.val), maxCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion-Inorder"><a href="#2-Recursion-Inorder" class="headerlink" title="2.Recursion + Inorder"></a>2.Recursion + Inorder</h4><p>The inorder recursion of a binary tree results in an ascending array. This is the feature we must rely on, and we do so by using a previous node to track value.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// It is important to set global variables</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">TreeNode pre;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Inorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">    traversal(root);</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        ans[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  count, maxCount, previous node and list are all global variables,</span></span><br><span class="line">    <span class="comment">//  so we only need to return void</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  return null if node is null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic, and it is inorder recursion</span></span><br><span class="line">    <span class="comment">//  3.1.If pre is null, then we have our first node, we set count as 1</span></span><br><span class="line">    <span class="comment">//  3.2.If pre.val != node.val, we also set count as 1</span></span><br><span class="line">    <span class="comment">//  3.3.If pre.val == node.val, we add count</span></span><br><span class="line">    <span class="comment">//  3.4.If count surpasses maxCount, we clear list and add node&#x27;s val in</span></span><br><span class="line">    <span class="comment">//      new list. Then we update maxCount</span></span><br><span class="line">    <span class="comment">//  3.5.If count == maxCount, we add node&#x27;s val in list</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traversal(node.left);</span><br><span class="line">    <span class="comment">// Pre == null means it is the first node</span></span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">null</span> || pre.val != node.val) &#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        maxCount = count;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = node;</span><br><span class="line">    traversal(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal-1"><a href="#2-Level-Traversal-1" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><p>Iteration method is harder to write and think of, although it is similar to the inorder recursion</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Level Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Use a pointer to refer to root rather than directly put it in the stack</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            <span class="comment">// left</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// middle</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="literal">null</span> || cur.val != pre.val) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">                list.clear();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                maxCount = count;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">// right</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        ans[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Constraints:</p>
<ul>
<li>The number of nodes in the tree is in the range [2, 105].</li>
<li>-10^9 &lt;&#x3D; Node.val &lt;&#x3D; 10^9</li>
<li>All Node.val are unique.</li>
<li>p !&#x3D; q</li>
<li>p and q will exist in the tree.</li>
</ul>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>We do search from bottom to top, So it will postorder that we will use.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">qVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Postorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    pVal = p.val;</span><br><span class="line">    qVal = q.val;</span><br><span class="line">    <span class="keyword">return</span> traversal(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  We use global variables and what we return is TreeNode</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  As usual, we return null if node is null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  3.1.We do postorder, so first left, then right, and middle at last</span></span><br><span class="line">    <span class="comment">//  3.2.When it is the node we want, which means the value of which is</span></span><br><span class="line">    <span class="comment">//      either pVal or qVal, we return it.</span></span><br><span class="line">    <span class="comment">//  3.3.When left and right are neither null, it means we have found the</span></span><br><span class="line">    <span class="comment">//      father node, and we shall return it.</span></span><br><span class="line">    <span class="comment">//  3.4.When left is null and right is not, we shall return left</span></span><br><span class="line">    <span class="comment">//  3.5.When right is null and left is not, we shall return right</span></span><br><span class="line">    <span class="comment">//  3.6.If the situation does not meet any mentioned above, we return null</span></span><br><span class="line">    <span class="comment">//  3.7.What if the node is p or q and one of its children is another target?</span></span><br><span class="line">    <span class="comment">//      Actually in 3.2, we have dealt with this situation. Since at last when</span></span><br><span class="line">    <span class="comment">//      it comes to root, there will be a non-null node on either side and one</span></span><br><span class="line">    <span class="comment">//      null node on another. What we will return is the non-null node, which is</span></span><br><span class="line">    <span class="comment">//      exactly the special father node.</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> traversal(node.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> traversal(node.right);</span><br><span class="line">    <span class="comment">// It helps in dealing with the case when current node is p or q, with its child</span></span><br><span class="line">    <span class="comment">// is another target</span></span><br><span class="line">    <span class="keyword">if</span> (node.val == pVal || node.val == qVal) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is the case when current node&#x27;s children are targets, with current node</span></span><br><span class="line">    <span class="comment">// being their father</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day22 Binary Tree Part08</title>
    <url>/2023/05/10/Day22-Binary-Tree-Part08/</url>
    <content><![CDATA[<h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Common-Recursion"><a href="#1-Common-Recursion" class="headerlink" title="1.Common + Recursion"></a>1.Common + Recursion</h4><p>It is still a common recursion because I still search the whole tree.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Preorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="comment">// Draw a graph, and we can deduce that the first node whose</span></span><br><span class="line">    <span class="comment">// value is between p and q is the node we want</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and parmas</span></span><br><span class="line">    <span class="comment">//      TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  if root is null, we of course should return</span></span><br><span class="line">    <span class="comment">//  Besides, if root is the first node whose value lies between p and q&#x27;s value,</span></span><br><span class="line">    <span class="comment">//  it should also be returned. ANd lie here is left close right close</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We check left and right, followed by returning the non-null left or non-null</span></span><br><span class="line">    <span class="comment">//  right or null if both left and right are null</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.val &gt; q.val &amp;&amp; root.val &lt;= p.val &amp;&amp; root.val &gt;= q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &lt; q.val &amp;&amp; root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Feature-Recursion"><a href="#2-Feature-Recursion" class="headerlink" title="2.Feature + Recursion"></a>2.Feature + Recursion</h4><p>Since it is a BST, we only need to search one side rather than the whole tree.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> traversal(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">traversal</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      TreeNode traversal(TreeNode root, TreeNode p, TreeNode q)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  If root is null, we of course should return null</span></span><br><span class="line">    <span class="comment">//  The point here is that we only need to search one side rather than the whole</span></span><br><span class="line">    <span class="comment">//  tree thanks to the feature of BST</span></span><br><span class="line">    <span class="comment">//  If root is bigger than both nodes, we go right and return the non-null right</span></span><br><span class="line">    <span class="comment">//  If root is smaller than both node, we go left and return the non-null left</span></span><br><span class="line">    <span class="comment">//  Else we have found the node that satisfies our requirement</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> traversal(root.left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> traversal(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></h4><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</p>
<p>Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>We do not need to reconstruct tree. What we need to do is to fill the node which is null as well as in the position we want with new node whose value is val.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Level Traversal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; val &amp;&amp; cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; val &amp;&amp; cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; val &amp;&amp; cur.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; val &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion"><a href="#2-Recursion" class="headerlink" title="2.Recursion"></a>2.Recursion</h4><p>We can fully utilize the feature of BST and do only the side search</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> traversal(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      TreeNode traversal(TreeNode root, int val)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  If it is null, it means we have found the node that should be added</span></span><br><span class="line">    <span class="comment">//  The reason is that we only do side search thanks to feature of BST,</span></span><br><span class="line">    <span class="comment">//  so we will always find a null point that satisfies our requirement.</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We do side search, so if root&#x27;s val is bigger than val, we assign its</span></span><br><span class="line">    <span class="comment">//  left with the traversed node. Otherwise, we assign its right with the</span></span><br><span class="line">    <span class="comment">//  traversed node</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">        root.left = traversal(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">        root.right = traversal(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li><p>Search for a node to remove.</p>
</li>
<li><p>If the node is found, delete the node.</p>
</li>
</ol>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion"><a href="#1-Recursion" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>The returned value would be treenode and params remain same to  the function.</p>
<p>The end condition would still be returning null if node is null, meaning we did not find what we want.</p>
<p>What is hardest is the logic. We have to face five situations.</p>
<ol>
<li>The node is not what we want. We keep traversing until we get a  null node and return. But it is a BST, so we only need to do side search.<ol>
<li>If node’s val is bigger than key, we traverse its left side.</li>
<li>If node’s val is smaller than key, we traverse its right side.</li>
</ol>
</li>
<li>The node is what we want. And its two children are both null, meaning it is a leaf  node. In this case, we return null to the upper layer, telling node’s father its child is deleted.</li>
<li>The node is what we want. And its left child null while its right child not null. In this case, we return its right child to the upper layer, telling node’s father it has a new child.</li>
<li>The node is what we want. And its right child null while its left child not null. In this case, we return its left child to the upper layer, telling node’s father it has a new child.</li>
<li>The node is what we want. And both its children are not null. In this case, we have two things to do.<ol>
<li>Move node’s left child to the leftmost leaf node of its right child, forming a new binary search tree.</li>
<li>return node’s right child to the upper layer, telling node’s father it has a new child.</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      TreeNode deleteNode(TreeNode root, int key)</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//      if (root == null) return null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  There are five cases that need to be handled, see in the blog</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// It means there is no node that has value of key in the whole tree,</span></span><br><span class="line">    <span class="comment">// so we return null</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Four cases when root has the value of key</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// It is a leaf node, we can directly return it to the upper node</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Its left is not null, while its right is.</span></span><br><span class="line">        <span class="comment">// In this case, we return its left child to the upper node.</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Similar logic applies to the opposite case</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// It has both children.</span></span><br><span class="line">        <span class="comment">//  What we do then is first move its left child to the leftmost</span></span><br><span class="line">        <span class="comment">//  leaf node of its right child</span></span><br><span class="line">        <span class="comment">//  Then we return its right child to upper node</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">            <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.left = root.left;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When root&#x27;s val is not key, we can fully utilize the feature of BST and </span></span><br><span class="line">    <span class="comment">// separate traversal into two sides rather than do a whole tree search.</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day23 Binary Tree Part09</title>
    <url>/2023/05/12/Day23-Binary-Tree-Part09/</url>
    <content><![CDATA[<h2 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer.</p>
<p>Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion"><a href="#1-Recursion" class="headerlink" title="1.Recursion"></a>1.Recursion</h4><p>The point is to keep doing recursion to node’s left or right child if node’s val is not in our range and get finally the result from recursion rather than from its direct left or right child.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  It is convenient to transfer TreeNode, so we will return TreeNode</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  It is still returning null when root is null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  What if root&#x27;s val is bigger than high or smaller than low?</span></span><br><span class="line">    <span class="comment">//  At this case, we cannot just return its left when root is bigger</span></span><br><span class="line">    <span class="comment">//  neither can we return right when root is smaller</span></span><br><span class="line">    <span class="comment">//  But instead, we should do a recursion to its left when root is</span></span><br><span class="line">    <span class="comment">//  bigger or to its right when root is smaller</span></span><br><span class="line">    <span class="comment">//  For example, suppose low is 3 and high is 4</span></span><br><span class="line">    <span class="comment">//          3</span></span><br><span class="line">    <span class="comment">//      1       4</span></span><br><span class="line">    <span class="comment">//  n       2</span></span><br><span class="line">    <span class="comment">// When we get to node 1, which does not satisfy our requirements,</span></span><br><span class="line">    <span class="comment">// we cannot just return its right, namely, 2 to node 3&#x27;s left.</span></span><br><span class="line">    <span class="comment">// What we must do is do a recursion to 1&#x27;s right and find out that</span></span><br><span class="line">    <span class="comment">// no node is okay to be in the new tree</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">        <span class="comment">// Do not just return current node&#x27;s right</span></span><br><span class="line">        <span class="comment">// Do recursion to its right instead</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left, low, high);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = trimBST(root.left, low, high);</span><br><span class="line">    root.right = trimBST(root.right, low, high);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. Convert Sorted Array to Binary Search Tree</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums where the elements are sorted in ascending order, convert it to a <strong>height-balanced</strong> binary search tree.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Two-Pointer-Divide-And-Conquer"><a href="#1-Recursion-Two-Pointer-Divide-And-Conquer" class="headerlink" title="1.Recursion + Two Pointer + Divide And Conquer"></a>1.Recursion + Two Pointer + Divide And Conquer</h4><p>Pay attention to the requirement of height-balanced. We can adopt two pointer and stick to divide and conquer principle to solve this question ensuring that two sides have the smallest height differences.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> traversal(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  We need two pointers as params, so that we can divide array</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  We return null when pointers cross lines</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  The basic logic is divide and conquer, dividing array into smaller</span></span><br><span class="line">    <span class="comment">//  parts until it cannot be separated more</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> || end &gt; nums.length - <span class="number">1</span> || start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end - start + <span class="number">1</span>) / <span class="number">2</span> + start;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightStart</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">    node.left = traversal(nums, start, leftEnd);</span><br><span class="line">    node.right = traversal(nums, rightStart, end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>
<p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p>
<ul>
<li><p>The left subtree of a node contains only nodes with keys less than the node’s key.</p>
</li>
<li><p>The right subtree of a node contains only nodes with keys greater than the node’s key.</p>
</li>
<li><p>Both the left and right subtrees must also be binary search trees.</p>
</li>
</ul>
<h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><p>The normal solution does not utilize feature of BST, but just stupidly do what the question asks for</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    sum = getBSTAllSum(root);</span><br><span class="line">    traversal(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traversal(root.left);</span><br><span class="line">    sum -= root.val;</span><br><span class="line">    root.val += sum;</span><br><span class="line">    traversal(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getBSTAllSum</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> getBSTAllSum(root.left);</span><br><span class="line">    <span class="type">long</span> <span class="variable">right</span> <span class="operator">=</span> getBSTAllSum(root.right);</span><br><span class="line">    <span class="keyword">return</span> root.val + left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2.Solution"></a>2.Solution</h4><p>While at first glance the requirement seems hard to realize, it is actually a simple one since it is a BST we are dealing with.</p>
<p>BST can be converted to a sorted array.</p>
<p>For example:</p>
<p>​	3</p>
<p>1	2</p>
<p>can be converted to [1, 2, 3]</p>
<p>And the result array expected is [6, 5, 3]</p>
<p>The shortcut is that we do not have to worry too much about sum of all nodes but instead we can adopt a previous pointer and iterate from end, which, in this example, is 3. We set 3 as then previous pointer and move next to 2, followed by adding the value of previous point to the current one and set the current one as new previous point. During this procedure, we will realize the same effect as adding the sum of all nodes whose value is bigger than the current one’s.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion + Reversed Inorder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traversal(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First we confirm returned value and params</span></span><br><span class="line">    <span class="comment">//  We rely on global variable pre, so we return void and needs</span></span><br><span class="line">    <span class="comment">//  no other params but node</span></span><br><span class="line">    <span class="comment">// 2.Then we confirm end conditions</span></span><br><span class="line">    <span class="comment">//  As usual, return null if node is null</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm logic</span></span><br><span class="line">    <span class="comment">//  We are using reversed inorder to do recursion, so the first</span></span><br><span class="line">    <span class="comment">//  node met is the biggest node in the tree.</span></span><br><span class="line">    <span class="comment">//  We follow the sequence of right, mid and left</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traversal(node.right);</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.val += pre.val;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = node;</span><br><span class="line">    traversal(node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Recursion</tag>
        <tag>Divide_And_Conquer</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Day25 Backtrack Part02</title>
    <url>/2023/05/15/Day25-Backtrack-Part02/</url>
    <content><![CDATA[<h2 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. Combination Sum III</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:</p>
<ul>
<li>Only numbers 1 through 9 are used.</li>
<li>Each number is used at most once.</li>
</ul>
<p>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack"><a href="#1-Backtrack" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    sum = n;</span><br><span class="line">    backtrack(<span class="number">1</span>, <span class="number">9</span>, k);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end ; i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        sum -= i;</span><br><span class="line">        backtrack(i + <span class="number">1</span>, end, size);</span><br><span class="line">        <span class="comment">// Essence of backtrack</span></span><br><span class="line">        sum += i;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Backtrack-Pruning"><a href="#2-Backtrack-Pruning" class="headerlink" title="2.Backtrack + Pruning"></a>2.Backtrack + Pruning</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    sum = n;</span><br><span class="line">    backtrack(<span class="number">1</span>, <span class="number">9</span>, k);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// Pruning: the size of current layer is too big</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() &gt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pruning: the current node is too big</span></span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end ; i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        sum -= i;</span><br><span class="line">        backtrack(i + <span class="number">1</span>, end, size);</span><br><span class="line">        <span class="comment">// Essence of backtrack</span></span><br><span class="line">        sum += i;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><a href="https://postimg.cc/G9MTrB7k"><img src="https://i.postimg.cc/bNPxxk1F/Day-24-Backtrack-Part01-02.jpg" alt="Day-24-Backtrack-Part01-02.jpg"></a></p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack-1"><a href="#1-Backtrack-1" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p><a href="https://postimg.cc/9rhfhqsf"><img src="https://i.postimg.cc/J4yHjNqj/Day-24-Backtrack-Part01-03.jpg" alt="Day-24-Backtrack-Part01-03.jpg"></a></p>
<p>Here is the tree structure of solution</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We can use a map or an array to store information of phone letters</span></span><br><span class="line"><span class="comment">// Here I use array and set the first two letters to null as the question asks</span></span><br><span class="line">String[] letterArray = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">digits</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.digits = digits;</span><br><span class="line">    length = digits.length();</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> currentLayerStartIndex, <span class="type">int</span> currentLayerIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stringBuilder.length() == length) &#123;</span><br><span class="line">        list.add(stringBuilder.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">currentDigit</span> <span class="operator">=</span> digits.charAt(currentLayerIndex);</span><br><span class="line">    <span class="comment">// Remember to minus &#x27;0&#x27; to get the correct index in array</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentLayerSize</span> <span class="operator">=</span> letterArray[currentDigit - <span class="string">&#x27;0&#x27;</span>].length();</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentLayerString</span> <span class="operator">=</span> letterArray[currentDigit - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> currentLayerStartIndex; i &lt; currentLayerSize; i++) &#123;</span><br><span class="line">        stringBuilder.append(currentLayerString.charAt(i));</span><br><span class="line">        backtrack(<span class="number">0</span>, currentLayerIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Essence of backtrack</span></span><br><span class="line">        stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtrack</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>Day24 Backtrack Part01</title>
    <url>/2023/05/15/Day24-Backtrack-Part01/</url>
    <content><![CDATA[<h2 id="Concept-of-Backtrack"><a href="#Concept-of-Backtrack" class="headerlink" title="Concept of Backtrack"></a>Concept of Backtrack</h2><p>Backtrack is an algorithm that enumerates all possible results in a violent way, which means it is not quite efficient, but we have to use it in some cases because there are no better solutions.</p>
<span id="more"></span>

<h3 id="1-Cases-where-we-can-adopt-backtrack"><a href="#1-Cases-where-we-can-adopt-backtrack" class="headerlink" title="1.Cases where we can adopt backtrack"></a>1.Cases where we can adopt backtrack</h3><ol>
<li>Combination</li>
<li>Partitioning</li>
<li>Subset</li>
<li>Chess board</li>
</ol>
<h3 id="2-Abstraction-of-Backtrack"><a href="#2-Abstraction-of-Backtrack" class="headerlink" title="2.Abstraction of Backtrack"></a>2.Abstraction of Backtrack</h3><p>Backtrack can be viewed as a <strong>tree</strong>.</p>
<p>Backtrack searches subset in the set by recursion. The size of set is the width of tree, and the depth of recursion is the depth of tree.</p>
<h3 id="3-Template-of-Tree"><a href="#3-Template-of-Tree" class="headerlink" title="3.Template of Tree"></a>3.Template of Tree</h3><ol>
<li><p>Returned value and params</p>
<p>In most cases, returned value would be void</p>
<p>But params cannot be confirmed at first place</p>
<p><strong>void backtrack(params)</strong></p>
</li>
<li><p>End conditions</p>
<p>if (end conditions) {</p>
<pre><code>store result;
 
return;
</code></pre>
<p>}</p>
</li>
<li><p>Logic</p>
<p>for (elements in this layer) {</p>
<pre><code>deal with current node;

backtrack(params);

remove result; (essence of backtrack)
</code></pre>
<p>}</p>
</li>
</ol>
<h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.cn/problems/combinations/">77. Combinations</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].</p>
<p>You may return the answer in any order.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack"><a href="#1-Backtrack" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// We can use linked list because it is easier to remove and add </span></span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    backtrack(<span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// end condition is when path size equals to our need</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">        list.add(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, end, size);</span><br><span class="line">        <span class="comment">// Essence of backtrack</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Backtrack-Pruning"><a href="#2-Backtrack-Pruning" class="headerlink" title="2.Backtrack + Pruning"></a>2.Backtrack + Pruning</h4><p>Pruning can to some extent increase the efficiency of backtrack.</p>
<p>In this question, if n &#x3D; 4 and k &#x3D; 4, then elements after 1 at first layer are all useless. We can prune those elements.</p>
<p><a href="https://postimg.cc/LnRgybSy"><img src="https://i.postimg.cc/Prvb5gRk/Day-24-Backtrack-Part01-01.jpg" alt="Day-24-Backtrack-Part01-01.jpg"></a></p>
<ol>
<li>The number of elements chosen: <strong>path.size()</strong></li>
<li>The number of elements required: <strong>k - path.size()</strong></li>
<li>The maximum start index of this layer: <strong>n - (k - path.size) + 1</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// We can use linked list because it is easier to remove and add</span></span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    backtrack(<span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// end condition is when path size equals to our need</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.The number of elements chosen: path.size()</span></span><br><span class="line">    <span class="comment">// 2.The number of elements required: k - path.size()</span></span><br><span class="line">    <span class="comment">// 3.The maximum start index of this layer: n - (k - path.size) + 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end - (size - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, end, size);</span><br><span class="line">        <span class="comment">// Essence of backtrack</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtrack</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>Day27 Backtrack Part03</title>
    <url>/2023/05/15/Day27-Backtrack-Part03/</url>
    <content><![CDATA[<h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.cn/problems/combination-sum/">39. Combination Sum</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p>
<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack"><a href="#1-Backtrack" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>Because multiple choice is allowed in this question, the start index in each loop does not need to be set to start index + 1, but just start index itself, then backtrack will automatically choose the corresponding number.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    <span class="comment">// We must sort array at first</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtrack(<span class="number">0</span>, candidates);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] candidates)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The current node is too big</span></span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        target -= candidates[i];</span><br><span class="line">        <span class="comment">// Multiple choice is allowed because there is enough space</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="number">0</span> &amp;&amp; target &gt;= candidates[i]) &#123;</span><br><span class="line">            backtrack(i, candidates);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Multiple choice is not allowed because there is no enough space</span></span><br><span class="line">            backtrack(i + <span class="number">1</span>, candidates);</span><br><span class="line">        &#125;</span><br><span class="line">        target += candidates[i];</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Backtrack-Pruning"><a href="#2-Backtrack-Pruning" class="headerlink" title="2.Backtrack + Pruning"></a>2.Backtrack + Pruning</h4><p><a href="https://postimg.cc/0bcsh4td"><img src="https://i.postimg.cc/Gm1mTwGN/Day-27-Backtrack-Part03-01.jpg" alt="Day-27-Backtrack-Part03-01.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    <span class="comment">// We must sort array at first</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtrack(<span class="number">0</span>, candidates);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] candidates)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The current node is too big</span></span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We can a pruning condition that disables next layer if next layer is too big</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        target -= candidates[i];</span><br><span class="line">        <span class="comment">// Multiple choice is allowed because there is enough space</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt; <span class="number">0</span> &amp;&amp; target &gt;= candidates[i]) &#123;</span><br><span class="line">            backtrack(i, candidates);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Multiple choice is not allowed because there is no enough space</span></span><br><span class="line">            backtrack(i + <span class="number">1</span>, candidates);</span><br><span class="line">        &#125;</span><br><span class="line">        target += candidates[i];</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. Combination Sum II</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.</p>
<p>Each number in candidates may only be used once in the combination.</p>
<p>Note: The solution set must not contain duplicate combinations.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack-1"><a href="#1-Backtrack-1" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>How to remove duplicated elements is the biggest difference of this question from the previous one. </p>
<p>But at first, we need to know when we should remove duplicated elements. There are two directions in backtrack since it is of tree structure. One is horizontal layer and the other one is vertical branch. It is the horizontal direction that we must remove duplicated elements.</p>
<p>We can assume candidates as [1, 1, 2] and target &#x3D; 3</p>
<p><a href="https://postimg.cc/dhms8YRM"><img src="https://i.postimg.cc/Vk2JPsdN/Day-27-Backtrack-Part03-02.jpg" alt="Day-27-Backtrack-Part03-02.jpg"></a></p>
<p>The picture above shows why horizontal duplicate should be removed.</p>
<p>Now the question comes to how we can realize function that informs us if the current node is horizontally duplicate.</p>
<p>The answer is that we can use a “used array” to indicate if a node is used horizontally.</p>
<p><a href="https://postimg.cc/0bwf88Dq"><img src="https://i.postimg.cc/hPC31vGh/Day-27-Backtrack-Part03-03.jpg" alt="Day-27-Backtrack-Part03-03.jpg"></a></p>
<p>If the current node is same as the previous one and value in used array of the previous index is 0, then that shows the current node is horizontally duplicate.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Used array is to record horizontal duplicates</span></span><br><span class="line"><span class="type">boolean</span>[] used = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// Must sort candidates at first</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, candidates);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> sum, <span class="type">int</span>[] candidates)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="comment">// if used[i - 1] is true, it means we are doing a vertical branch traversal</span></span><br><span class="line">        <span class="comment">// otherwise it means we are doing a horizontal one</span></span><br><span class="line">        <span class="comment">// And if both used[i - 1] = false and the current value and the previous one</span></span><br><span class="line">        <span class="comment">// are same, it means we encounter duplicate</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        <span class="comment">// Vertical, so set used to true</span></span><br><span class="line">        used[i] =<span class="literal">true</span>;</span><br><span class="line">        backtrack(i + <span class="number">1</span>, sum + candidates[i], candidates);</span><br><span class="line">        <span class="comment">// Essence of backtrack, so set used to false, which means we are staring</span></span><br><span class="line">        <span class="comment">// horizontal traversal</span></span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Backtrack-Pruning-1"><a href="#2-Backtrack-Pruning-1" class="headerlink" title="2.Backtrack + Pruning"></a>2.Backtrack + Pruning</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Used array is to record horizontal duplicates</span></span><br><span class="line"><span class="type">boolean</span>[] used = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// Must sort candidates at first</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, candidates);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> sum, <span class="type">int</span>[] candidates)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Pruning by setting constraint on end index with target - sum</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length &amp;&amp; candidates[i] &lt;= target - sum; i++) &#123;</span><br><span class="line">            <span class="comment">// if used[i - 1] is true, it means we are doing a vertical branch traversal</span></span><br><span class="line">            <span class="comment">// otherwise it means we are doing a horizontal one</span></span><br><span class="line">            <span class="comment">// And if both used[i - 1] = false and the current value and the previous one</span></span><br><span class="line">            <span class="comment">// are same, it means we encounter duplicate</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            <span class="comment">// Vertical, so set used to true</span></span><br><span class="line">            used[i] =<span class="literal">true</span>;</span><br><span class="line">            backtrack(i + <span class="number">1</span>, sum + candidates[i], candidates);</span><br><span class="line">            <span class="comment">// Essence of backtrack, so set used to false, which means we are staring</span></span><br><span class="line">            <span class="comment">// horizontal traversal</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. Palindrome Partitioning</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack-2"><a href="#1-Backtrack-2" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>The most important point in this question is to put the <strong>divider</strong>.</p>
<p><a href="https://postimg.cc/pywYbH3n"><img src="https://i.postimg.cc/RVFPtCRG/Day-27-Backtrack-Part03-04.jpg" alt="Day-27-Backtrack-Part03-04.jpg"></a></p>
<p>Divider is the vertical line in picture. In the first layer, divider is 0, 1, 2 seperately.</p>
<p>Another point is end condition. In this question, we can only return when start index is bigger than end index because substring API we use.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    string = s;</span><br><span class="line">    backtrack(<span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// End condition is start index be bigger than end index</span></span><br><span class="line">     <span class="keyword">if</span> (startIndex &gt; endIndex) &#123;</span><br><span class="line">         list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPalindrome(startIndex, i)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Divider is the key of this question</span></span><br><span class="line">        <span class="comment">// It should be set to i and will result in good partition</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">divider</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// Since we are using substring API, divider + 1 is necessary</span></span><br><span class="line">        path.add(string.substring(startIndex, divider + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// In the deeper branch, the start index should be i + 1, namely starting from</span></span><br><span class="line">        <span class="comment">// element after divider</span></span><br><span class="line">        backtrack(divider + <span class="number">1</span>, endIndex);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (string.charAt(startIndex) != string.charAt(endIndex)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        startIndex++;</span><br><span class="line">        endIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtrack</tag>
        <tag>Combination</tag>
        <tag>Partition</tag>
      </tags>
  </entry>
  <entry>
    <title>Day28 Backtrack Part04</title>
    <url>/2023/05/16/Day28-Backtrack-Part04/</url>
    <content><![CDATA[<h2 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. Restore IP Addresses</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.</p>
<ul>
<li>For example, “0.1.2.201” and “192.168.1.1” are valid IP addresses, but “0.011.255.245”, “192.168.1.312” and “<a href="mailto:&#x31;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#64;&#49;&#x2e;&#x31;">&#x31;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#64;&#49;&#x2e;&#x31;</a>“ are invalid IP addresses.</li>
</ul>
<p>Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack"><a href="#1-Backtrack" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// DotsCount is used to record current dots number. We end when it gets 3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dotsCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// DotsArray is used to record index of each dot</span></span><br><span class="line"><span class="type">int</span>[] dotsIndexArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    string = s;</span><br><span class="line">    backtrack(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// End condition is when there are 3 dots recorded, which means there will be 4 segments</span></span><br><span class="line">    <span class="keyword">if</span> (dotsCount == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValidSegment(string, dotsIndexArray[<span class="number">2</span>] + <span class="number">1</span>, string.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> getIpAddress(string, dotsIndexArray);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        list.add(result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; string.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// Pruning</span></span><br><span class="line">        <span class="keyword">if</span> (i - startIndex &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Segment verification</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidSegment(string, startIndex, i)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dotsCount++;</span><br><span class="line">        dotsIndexArray[dotsCount - <span class="number">1</span>] = i;</span><br><span class="line">        backtrack(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Essence of backtrack</span></span><br><span class="line">        dotsIndexArray[dotsCount - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dotsCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidSegment</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end - start &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; end - start &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Integer.valueOf(s.substring(start, end + <span class="number">1</span>)) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getIpAddress</span><span class="params">(String s, <span class="type">int</span>[] dotsIndexArray)</span> &#123;</span><br><span class="line">    stringBuilder.append(s.substring(<span class="number">0</span>, dotsIndexArray[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line">    stringBuilder.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    stringBuilder.append(s.substring(dotsIndexArray[<span class="number">0</span>] + <span class="number">1</span>, dotsIndexArray[<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">    stringBuilder.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    stringBuilder.append(s.substring(dotsIndexArray[<span class="number">1</span>] + <span class="number">1</span>, dotsIndexArray[<span class="number">2</span>] + <span class="number">1</span>));</span><br><span class="line">    stringBuilder.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    stringBuilder.append(s.substring(dotsIndexArray[<span class="number">2</span>] + <span class="number">1</span>, string.length()));</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">    stringBuilder = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a><a href="https://leetcode.cn/problems/subsets/">78. Subsets</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p>
<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack-1"><a href="#1-Backtrack-1" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>Unlike combination and partition which records only the leaf node, subset questions ask us to record every node during traversal.</p>
<p><a href="https://postimg.cc/nMdHp7qN"><img src="https://i.postimg.cc/7Y4b1nhP/Day-28-Backtrack-Part04-01.jpg" alt="Day-28-Backtrack-Part04-01.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    array = nums;</span><br><span class="line">    <span class="comment">// Null set should be added at first</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    backtrack(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == array.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; array.length; i++) &#123;</span><br><span class="line">        path.add(array[i]);</span><br><span class="line">        <span class="comment">// Special point about subset because we must add all nodes to list, rather than</span></span><br><span class="line">        <span class="comment">// just leaf nodes</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        backtrack(i + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. Subsets II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).</p>
<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack-2"><a href="#1-Backtrack-2" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>We can combine <a href="https://zhaoyiwei0311.github.io/2023/05/15/Day27-Backtrack-Part03/">40. Combination Sum II</a> with this question as they must both solve duplicate issue. Similarly, we can use a used array to record horizontal duplicate situation.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// Used array is to record horizontal duplicates </span></span><br><span class="line"><span class="type">boolean</span>[] used = <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">    array = nums;</span><br><span class="line">    <span class="comment">// add empty set at first</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    backtrack(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; array.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// When we encounter horizontal duplicate</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; array[i] == array[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.add(array[i]);</span><br><span class="line">        <span class="comment">// As for subset question, we must add all its nodes rather than just leaf nodes</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        backtrack(i + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtrack</tag>
        <tag>Partition</tag>
        <tag>Subset</tag>
      </tags>
  </entry>
  <entry>
    <title>Day32 Greedy Part02</title>
    <url>/2023/05/23/Day32-Greedy-Part02/</url>
    <content><![CDATA[<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.</p>
<p>On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</p>
<p>Find and return the maximum profit you can achieve.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy"><a href="#1-Greedy" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>There is only one stock and no transaction fee. The point is to divide profit of, for example from day 1 to day 4, into (day 4 - day 3) + (day 3 - day 2) + (day 2 - day 1) and only choose positive profit days.</p>
<p>Another point is that there is no profit in day 1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (profit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxProfit += profit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.cn/problems/jump-game/">55. Jump Game</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an integer array nums. You are initially positioned at the array’s first index, and each element in the array represents your maximum jump length at that position.</p>
<p>Return true if you can reach the last index, or false otherwise.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-1"><a href="#1-Greedy-1" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>There is no need to consider how many step I must jump during iteration. What we need to do is to know range that covers the current furthest distance and that is our local optimal which will lead to global optimal to cover the overall furthest range.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// Range is what matters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If nums.length == 1, we will always arrive. So this can be</span></span><br><span class="line">    <span class="comment">// regarded as a special case</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// The point is to set a dynamic end, which is cover</span></span><br><span class="line">    <span class="comment">// It will return false when it cannot move any further</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++) &#123;</span><br><span class="line">        <span class="comment">// update cover</span></span><br><span class="line">        cover = Math.max(cover, nums[i] + i);</span><br><span class="line">        <span class="comment">// cover is able to cover all range, so we return true</span></span><br><span class="line">        <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. Jump Game II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].</p>
<p>Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:</p>
<ul>
<li>0 &lt;&#x3D; j &lt;&#x3D; nums[i] and</li>
<li>i + j &lt; n</li>
</ul>
<p>Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-2"><a href="#1-Greedy-2" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>Similar to previous question, we need to know range that covers greatest distance. But difference lies in that we need to divide range into 2 parts. One is current range, which is included in current step during iteration, the other is next range, which is for the next step.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We need 3 variables and update them accordingly</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curStart</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curCover</span> <span class="operator">=</span> nums[curStart];</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curStart &lt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// count should be added here, where no special treat is needed</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// we end while loop when we find current cover is big enough</span></span><br><span class="line">        <span class="keyword">if</span> (curCover &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we update next cover to find how far the next step can go</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> curStart; i &lt;= curCover; i++) &#123;</span><br><span class="line">            nextCover = Math.max(nums[i] + i, nextCover);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we update variables for current loop to new status</span></span><br><span class="line">        curStart = curCover;</span><br><span class="line">        curCover = nextCover;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>Day29 Backtrack Part05</title>
    <url>/2023/05/19/Day29-Backtrack-Part05/</url>
    <content><![CDATA[<h2 id="491-Non-decreasing-Subsequences"><a href="#491-Non-decreasing-Subsequences" class="headerlink" title="491. Non-decreasing Subsequences"></a><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. Non-decreasing Subsequences</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack"><a href="#1-Backtrack" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>The trap of this question is that it cannot sort array as we did in <a href="https://zhaoyiwei0311.github.io/2023/05/16/Day28-Backtrack-Part04/">90. Subsets II</a> because we need information in original array.</p>
<p>But we still need to remove duplicate in the same layer as picture shows.</p>
<p><a href="https://postimg.cc/ygqW4HPt"><img src="https://i.postimg.cc/bJrnnY2y/Day-29-Backtrack-Part05-01.jpg" alt="Day-29-Backtrack-Part05-01.jpg"></a></p>
<p>The solution is we can use a map to store used information while doing iteration in the same layer.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    array = nums;</span><br><span class="line">    backtrack(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// Subsequence must be at least bigger than 2, so path should be added to list</span></span><br><span class="line">    <span class="comment">// Besides, we must not return since path is still useful in future traversal</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We need a map to store used information</span></span><br><span class="line">    HashMap&lt;Integer, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Condition of non-decreasing should be satisfied </span></span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; <span class="number">0</span> &amp;&amp; array[i] &lt; path.getLast()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The same value is used in the same layer, which means it is a duplicate</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; map.containsKey(array[i]) &amp;&amp; !map.get(array[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(array[i]);</span><br><span class="line">        map.put(array[i], <span class="literal">true</span>);</span><br><span class="line">        backtrack(i + <span class="number">1</span>);</span><br><span class="line">        map.put(array[i], <span class="literal">false</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a><a href="https://leetcode.cn/problems/permutations/">46. Permutations</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 6</li>
<li>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10</li>
<li>All the integers of nums are unique.</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack-1"><a href="#1-Backtrack-1" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>As for permutation, path should be with order, which mean [1, 2] and [2, 1] are different. Then a big difference from previous questions occurs that no start index while calling function is needed for we have to traverse the whole array each time. Instead, another array that records used status is needed as picture shows.</p>
<p><a href="https://postimg.cc/KRwnvRms"><img src="https://i.postimg.cc/t4CDkxwy/Day-29-Backtrack-Part05-02.jpg" alt="Day-29-Backtrack-Part05-02.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Array that records used status is needed</span></span><br><span class="line"><span class="type">boolean</span>[] used = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    array = nums;</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[array.length];</span><br><span class="line">    backtrack();</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No start index needed for it is permutation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// End condition is easy to understand</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == array.length) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(array[i]);</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        backtrack();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. Permutations II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Backtrack-2"><a href="#1-Backtrack-2" class="headerlink" title="1.Backtrack"></a>1.Backtrack</h4><p>It is similar to <a href="https://zhaoyiwei0311.github.io/2023/05/15/Day27-Backtrack-Part03/">40. Combination Sum II</a>. We need to remove duplicate in the same layer by using a used array. But at first we must sort array if we want to utilize array[i] &#x3D;&#x3D; array[i - 1].</p>
<p>Another trick is that we only need to use one used array instead of one for branch and one for layer separately. We have already sorted array and in the case when array[i] &#x3D;&#x3D; array[i - 1],  we can judge duplicate by judging used[i - 1]. If used[i - 1] is false, then it is duplicate in the same layer because we must have already backtracked array[i - 1] and restored used status to false. If used[i - 1] is true, we are actually   traversing branch, which is okay for duplicate. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Only one used array is needed</span></span><br><span class="line"><span class="type">boolean</span>[] used = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// Sort array first</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    array = nums;</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[array.length];</span><br><span class="line">    backtrack();</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// End condition is easy to understand</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == array.length) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Branch used, which is okay to skip</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Layer used, we encounter duplicate</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; array[i] == array[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.add(array[i]);</span><br><span class="line">        backtrack();</span><br><span class="line">        path.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtrack</tag>
        <tag>Subset</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>Day31 Greedy Part01</title>
    <url>/2023/05/19/Day31-Greedy-Part01/</url>
    <content><![CDATA[<h2 id="Concept-of-Greedy-Algorithm"><a href="#Concept-of-Greedy-Algorithm" class="headerlink" title="Concept of Greedy Algorithm"></a>Concept of Greedy Algorithm</h2><p>The essence of greedy algorithm is <strong>“From local optima to global optima”</strong>.</p>
<h2 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. Assign Cookies</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>
<p>Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;&#x3D; g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy"><a href="#1-Greedy" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>We can deduce that greedy algorithm can be adopted here because there is local optima “Satisfying the greediest child with the biggest biscuit” that leads to global optima “Satisfying most children”.</p>
<p>Besides, efficiency is also important. Instead of using two for loop, we can set a pointer that moves if some condition is met, decreasing loop count from 2 to 1. </p>
<p>But what to put in the for loop becomes a question. We can put children in for loop and move biscuit index if requirement is met. However, if we put biscuit instead, there will be problem.</p>
<p>Suppose biscuit &#x3D; {1, 2, 3, 4} and children &#x3D; {1, 2, 3, 5}</p>
<p>child pointer will remain at last while biscuit does its loop because no condition would be met.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">    <span class="comment">// Local optima: satisfy the greediest child with the biggest biscuit</span></span><br><span class="line">    <span class="comment">// Global optima: make most children satisfied.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We must sort two arrays first</span></span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">satisfiedChildrenCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We iterate children and move biscuitIndex if child is satisfied</span></span><br><span class="line">    <span class="comment">// But iterating biscuits and moving childIndex if biscuit is okay is not applicable</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">biscuitIndex</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (biscuitIndex &gt;= <span class="number">0</span> &amp;&amp; s[biscuitIndex] &gt;= g[i]) &#123;</span><br><span class="line">            satisfiedChildrenCount++;</span><br><span class="line">            biscuitIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> satisfiedChildrenCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376. Wiggle Subsequence"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. Wiggle Subsequence</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p>
<p>For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.<br>In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.<br>A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Given an integer array nums, return the length of the longest wiggle subsequence of nums.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-1"><a href="#1-Greedy-1" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p><a href="https://postimg.cc/bdkvvGJs"><img src="https://i.postimg.cc/J7dHPZCc/Day-31-Greedy-Part01-01.jpg" alt="Day-31-Greedy-Part01-01.jpg"></a></p>
<p>As the picture shows, the local optima can be seen as deleting redundant elements in a monotonic subsequence, which will lead to global optima that is the longest wiggle sequence.</p>
<p>But there are 3 situations that need to be considered.</p>
<ol>
<li><p>Flat between 2 points</p>
<p><a href="https://postimg.cc/bDnMfSPh"><img src="https://i.postimg.cc/Ss1p8ctJ/Day-31-Greedy-Part01-02.jpg" alt="Day-31-Greedy-Part01-02.jpg"></a></p>
<p>It counts 3 rather than 2</p>
</li>
<li><p>The start and End</p>
<p>Maybe there are just 2 numbers in the array, and it should be counted as 2. We can set a special judgment for it alone, or we can set a dummy pre difference that is 0 to solve this problem.</p>
</li>
</ol>
<p><a href="https://postimg.cc/s1WpR9Z8"><img src="https://i.postimg.cc/1RCMwvR9/Day-31-Greedy-Part01-03.jpg" alt="Day-31-Greedy-Part01-03.jpg"></a></p>
<ol start="3">
<li>Flat in monotonic</li>
</ol>
<p><a href="https://postimg.cc/8jB8ZzLY"><img src="https://i.postimg.cc/yY2VYJx7/Day-31-Greedy-Part01-04.jpg" alt="Day-31-Greedy-Part01-04.jpg"></a></p>
<p>As the picture shows, we can only update pre diff to cur diff when it satisfies the definition of wiggling.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// We need two pointers</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + <span class="number">1</span> &lt; nums.length; i++) &#123;</span><br><span class="line">        curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">        <span class="comment">// &quot;&lt;= &gt;=&quot; is necessary because there is flat situation</span></span><br><span class="line">        <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            <span class="comment">// Only update pre diff when there is wiggle</span></span><br><span class="line">            preDiff = curDiff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. Maximum Subarray</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums, find the subarray with the largest sum, and return its sum.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-2"><a href="#1-Greedy-2" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>Local optima: abandon the sum when it is negative because any number plus a negative number only leads to a smaller one.</p>
<p>Global optima: get the biggest sum from array</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        result = Math.max(sum, result);</span><br><span class="line">        <span class="comment">// We only abandon while sum &lt; 0, but not nums[i] &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>Day34 Greedy Part04</title>
    <url>/2023/05/23/Day34-Greedy-Part04/</url>
    <content><![CDATA[<h2 id="860-Lemonade-Change"><a href="#860-Lemonade-Change" class="headerlink" title="860. Lemonade Change"></a><a href="https://leetcode.cn/problems/lemonade-change/">860. Lemonade Change</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.</p>
<p>Note that you do not have any change in hand at first.</p>
<p>Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy"><a href="#1-Greedy" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>There are 3 cases.</p>
<ol>
<li><p>When customer pays with 5, just add 5 as our backup.</p>
</li>
<li><p>When customer pays with 10, return false if there is no 5 left or give out 1 * 5 and get 1 * 10 as backup.</p>
</li>
<li><p>When customer pays with 20, we have two strategies if supply is enough. </p>
<ol>
<li>1 * 10 and 1 * 5</li>
<li>3 * 5</li>
</ol>
<p>And obviously, the local optimal would be 1 because <strong>10 is less useful than 5</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 1.Customer pays with 5, just add 5 backup</span></span><br><span class="line">        <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">            five++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.Customer pays with 10, give out 5 if there is sufficient 5 and</span></span><br><span class="line">        <span class="comment">// add 10 backup, or return false</span></span><br><span class="line">        <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.Customer pays with 20, we have 2 strategies here</span></span><br><span class="line">        <span class="comment">// But 10 + 5 should be priority since 10 is less useful</span></span><br><span class="line">        <span class="keyword">if</span> (bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ten--;</span><br><span class="line">                five--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ten &lt;= <span class="number">0</span> &amp;&amp; five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                five -= <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] &#x3D; [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</p>
<p>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] &#x3D; [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-1"><a href="#1-Greedy-1" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>Similar to [[Day33 Greedy Part03#^26caed|135.Candy]], this question asks us to only consider <strong>only one side once</strong>.</p>
<p>We can choose to sort by height first, or by queue number first. But the latter lead to nothing but chaos, so we choose to sort by height first.</p>
<p>Suppose we have [7,0], [4,4], [7,1], [5,0], [6,1], [5,2]</p>
<ol>
<li><p>Sort by height <strong>desc</strong> and if height is same, the one with smaller order is in the front.</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7,0</td>
<td align="center">7,1</td>
<td align="center">6,1</td>
<td align="center">5,0</td>
<td align="center">5,2</td>
<td align="center">4,4</td>
</tr>
</tbody></table>
</li>
<li><p>Insert one by one, now the order is where the element should be put.</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7,0</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7,0</td>
<td align="center">7,1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7,0</td>
<td align="center"><strong>6,1</strong></td>
<td align="center"><strong>7,1</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>5,0</strong></td>
<td align="center"><strong>7,0</strong></td>
<td align="center">6,1</td>
<td align="center">7,1</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5,0</td>
<td align="center">7,0</td>
<td align="center"><strong>5,2</strong></td>
<td align="center">6,1</td>
<td align="center">7,1</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5,0</td>
<td align="center">7,0</td>
<td align="center">5,2</td>
<td align="center">6,1</td>
<td align="center"><strong>4,4</strong></td>
<td align="center"><strong>7,1</strong></td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">    <span class="comment">// 1.First sort people by their height in desc</span></span><br><span class="line">    <span class="comment">// and if height is same, sort by order asc</span></span><br><span class="line">    Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// We can use a linked list to insert element</span></span><br><span class="line">    LinkedList&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// add API can add according to index, which is just element&#x27;s order</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] person : people) &#123;</span><br><span class="line">        list.add(person[<span class="number">1</span>], person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. Minimum Number of Arrows to Burst Balloons</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] &#x3D; [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.</p>
<p>Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;&#x3D; x &lt;&#x3D; xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p>
<p>Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-2"><a href="#1-Greedy-2" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>Shoot as many overlapped balloons as possible. </p>
<p>One point here is the boarder. It can be either left boarder or right boarder that we should stick to and I would choose right boarder.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="comment">// First we must sort array by its left boarder</span></span><br><span class="line">    <span class="comment">// Pay attention to the compare method we use because there might be overflow</span></span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">boarder</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Two cases we might come up with</span></span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; boarder) &#123;</span><br><span class="line">            <span class="comment">// 1.The left boarder of current element surpasses our set boarder</span></span><br><span class="line">            <span class="comment">//  In this case we need to add arrow</span></span><br><span class="line">            count++;</span><br><span class="line">            boarder = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.The left boarder of current element is below our set boarder</span></span><br><span class="line">            <span class="comment">//  In this case, the arrow can shoot through, but we might truncate</span></span><br><span class="line">            <span class="comment">//  our boarder accordingly</span></span><br><span class="line">            boarder = Math.min(boarder, points[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Divide_And_Conquer</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>Day33 Greedy Part03</title>
    <url>/2023/05/23/Day33-Greedy-Part03/</url>
    <content><![CDATA[<h2 id="1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="1005. Maximize Sum Of Array After K Negations"></a><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. Maximize Sum Of Array After K Negations</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given an integer array nums and an integer k, modify the array in the following way:</p>
<p>choose an index i and replace nums[i] with -nums[i].<br>You should apply this process exactly k times. You may choose the same index i multiple times.</p>
<p>Return the largest possible sum of the array after modifying it in this way.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-Directly-Sort"><a href="#1-Greedy-Directly-Sort" class="headerlink" title="1.Greedy (Directly Sort)"></a>1.Greedy (Directly Sort)</h4><p>Sort nums and if the smallest one is positive or zero, keep multiplying it by -1 until k gets to 0. If the smallest one is negative, try to make all negative ones positive if there is still k remaining. If all negative numbers are converted to positive while k still stands, then we sort nums again and do what we did when all numbers are positive</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// We must sort nums first</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// The case when smallest one is positive or zero</span></span><br><span class="line">    <span class="comment">// just multiply the smallest one with -1 until k gets exhausted</span></span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// The case when smallest one is negative</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Set k gets exhausted as end condition</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to convert all negative elements to positive </span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; nums.length &amp;&amp; nums[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">                index++;</span><br><span class="line">                k--;</span><br><span class="line">            <span class="comment">// If conversion is over and there is still k remaining,</span></span><br><span class="line">            <span class="comment">// then we just repeat what we did while all elements are positive    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Arrays.sort(nums);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                    nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(nums).sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Greedy-Sort-absolute-value"><a href="#2-Greedy-Sort-absolute-value" class="headerlink" title="2.Greedy (Sort absolute value)"></a>2.Greedy (Sort absolute value)</h4><p>Or we can sort by absolute value and make sure that those with greatest absolute values being positive as many as possible.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// Sort by absolute value and let those with greater absolute value stay</span></span><br><span class="line">    <span class="comment">// forward</span></span><br><span class="line">    nums = IntStream.of(nums)</span><br><span class="line">            .boxed().sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))</span><br><span class="line">            .mapToInt(Integer::intValue).toArray();</span><br><span class="line">    <span class="comment">// Try to make as many negative numbers of greater absolute value positive as we can </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if k still remains positive</span></span><br><span class="line">    <span class="comment">//  if k is even, just ignore</span></span><br><span class="line">    <span class="comment">//  otherwise, just convert the smallest one to negative</span></span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        nums[nums.length - <span class="number">1</span>] = -nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(nums).sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a><a href="https://leetcode.cn/problems/gas-station/">134. Gas Station</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.</p>
<p>Given two integer arrays gas and cost, return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy"><a href="#1-Greedy" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>There is a fill array and a cost array, so we may consider creating a rest array. Take fill &#x3D; [1, 2, 3, 4, 5] and cost &#x3D; [3, 4, 5, 1, 2] as an example and we can get as follows.</p>
<p><a href="https://postimg.cc/xkcdRwck"><img src="https://i.postimg.cc/5tmFx1Jm/Day-31-Greedy-Part03-01.jpg" alt="Day-31-Greedy-Part03-01.jpg"></a></p>
<p>Then we need to keep the sum of rest positive to keep car driving, so the first 3 stations cannot be taken as start point. We will, actually skip all stations, the car traveling to which with a sum of gas negative,and try to take its next station as a starter. The reason we dare to give up all previous stations and do not consider any station between original start and ending point where sum gets negative is shown below.  </p>
<p><a href="https://postimg.cc/wRsD3wCP"><img src="https://i.postimg.cc/j2Mcg9Zs/Day-31-Greedy-Part03-02.jpg" alt="Day-31-Greedy-Part03-02.jpg"></a></p>
<p>To conclude, there are 2 cases to be considered.</p>
<ol>
<li>When cost array overruns fill array, we shall return -1 since under any circumstance will this car fail to travel around.</li>
<li>When current sum is negative, it means all previous stations cannot support the car to go further, thus we need to try to set new start that lies afterwards.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] rest = <span class="keyword">new</span> <span class="title class_">int</span>[gas.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">        rest[i] = gas[i] - cost[i];</span><br><span class="line">        totalSum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// In the case when cost overruns fill, we shall return -1</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rest.length; i++) &#123;</span><br><span class="line">        currentSum += rest[i];</span><br><span class="line">        <span class="comment">// If current sum &lt; 0, we must give up all stations before and try to set</span></span><br><span class="line">        <span class="comment">// new start to the next station</span></span><br><span class="line">        <span class="keyword">if</span> (currentSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">            currentSum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode.cn/problems/candy/">135. Candy</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>Return the minimum number of candies you need to have to distribute the candies to the children.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Greedy-1"><a href="#1-Greedy-1" class="headerlink" title="1.Greedy"></a>1.Greedy</h4><p>At first glance, it is obvious to think about dealing with both sides simultaneously. But this method gets people confused easily, so what is the solution is to <strong>think one side, then the other</strong></p>
<ol>
<li><p>Compare with left</p>
<p>The order of this comparing is from left to right, which is easy to understand. When we find rating[i] &gt; ratings[i - 1], the corresponding candy[i] should be candy[i - 1] + 1</p>
</li>
<li><p>Compare with right</p>
<p>The order of this comparing is from right to left rather than left to right because the latter cannot utilize the result from previous comparing. When we find rating[i] &gt; rating[i + 1], the corresponding candy[i] may change. But we must decide from candy[i + 1] + 1 and candy[i] from the previous round and choose the bigger value from the two.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">    <span class="comment">// Initialize candy</span></span><br><span class="line">    Arrays.fill(candy, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 1.Compare with left, from left to right</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; candy.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.Compare with right, from right to left and utilize the previous round</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> candy.length - <span class="number">2</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            candy[i] = Math.max(candy[i + <span class="number">1</span>] + <span class="number">1</span>, candy[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Arrays.stream(candy).sum();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Divide_And_Conquer</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>Day15 Binary Tree Part02</title>
    <url>/2023/05/03/Day15-Binary-Tree-Part02/</url>
    <content><![CDATA[<h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal"><a href="#1-Level-Traversal" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Level traversal is actually BFS.</p>
<p>We use a queue to do the BFS because FIFO corresponds to the logic of search layer by layer.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce a tempList to record each layer&#x27;s nodes</span></span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We add the popped node value to the temp list and minus the size</span></span><br><span class="line">            tempList.add(popped.val);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// Once the size decreases to 0, it means the current layer has all been iterated</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.add(tempList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-1"><a href="#1-Level-Traversal-1" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Almost same to the previous one except for reversing the list in the end.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce a tempList to record each layer&#x27;s nodes</span></span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We add the popped node value to the temp list and minus the size</span></span><br><span class="line">            tempList.add(popped.val);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// Once the size decreases to 0, it means the current layer has all been iterated</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.add(tempList);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-2"><a href="#1-Level-Traversal-2" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Almost same to the question 107, but the point is that only adding the node to the list when size decrease to 0, namely, when it is the rightmost node of this layer.</p>
<p>At first, I made a mistake to add only the right son node to the queue. But it is not right in the case like  [1, 2], where 2 should also be added to the list although it is the left node while also remains the rightmost node in the second layer.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce a tempList to record each layer&#x27;s nodes</span></span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(popped.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10^5 of the actual answer will be accepted.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-3"><a href="#1-Level-Traversal-3" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still quite similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            total += popped.val;</span><br><span class="line">            <span class="comment">// We add left son and right son of popped node</span></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(total / tempSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="429-N-ary-Tree-Level-Order-Traversal"><a href="#429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="429. N-ary Tree Level Order Traversal"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></h2><h3 id="Intro-4"><a href="#Intro-4" class="headerlink" title="Intro"></a>Intro</h3><p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p>
<p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-4"><a href="#1-Level-Traversal-4" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We use a queue to store nodes</span></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// We add root to the queue</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// We introduce size variable to record each layer&#x27;s size</span></span><br><span class="line">        <span class="comment">// The current size of queue is actually the size of each layer of tree</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            tempList.add(popped.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child : popped.children) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(tempList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></h2><h3 id="Intro-5"><a href="#Intro-5" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).</p>
<h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-5"><a href="#1-Level-Traversal-5" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            max = Math.max(popped.val, max);</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></h2><h3 id="Intro-6"><a href="#Intro-6" class="headerlink" title="Intro"></a>Intro</h3><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-6"><a href="#1-Level-Traversal-6" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Node2 <span class="title function_">connect</span><span class="params">(Node2 root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node2&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span>queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="type">Node2</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                popped.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                popped.next = queue.peek();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h2><h3 id="Intro-7"><a href="#Intro-7" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Level-Traversal-7"><a href="#1-Level-Traversal-7" class="headerlink" title="1.Level Traversal"></a>1.Level Traversal</h4><p>Still similar.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxDepth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. Invert Binary Tree</a></h2><h3 id="Intro-8"><a href="#Intro-8" class="headerlink" title="Intro"></a>Intro</h3><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-PreOrder"><a href="#1-Recursion-PreOrder" class="headerlink" title="1.Recursion + PreOrder"></a>1.Recursion + PreOrder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> * PreOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//  It can just be TreeNode invertTree(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//  if (node == null) &#123;return null;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm the logic</span></span><br><span class="line">    <span class="comment">//  swapChildren(node);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.right);</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swapChildren(root);</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion-Postorder"><a href="#2-Recursion-Postorder" class="headerlink" title="2.Recursion + Postorder"></a>2.Recursion + Postorder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> * PostOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//  It can just be TreeNode invertTree(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//  if (node == null) &#123;return null;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm the logic</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.right);</span></span><br><span class="line">    <span class="comment">//  swapChildren(node);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    swapChildren(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Recursion-Midorder"><a href="#3-Recursion-Midorder" class="headerlink" title="3.Recursion + Midorder"></a>3.Recursion + Midorder</h4><p>Not recommended because logic should be changed a bit, otherwise there will be a subtree swapped twice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack</span></span><br><span class="line"><span class="comment"> * MidOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.First confirm the returned value and params</span></span><br><span class="line">    <span class="comment">//  It can just be TreeNode invertTree(TreeNode node)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//  if (node == null) &#123;return null;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, confirm the logic</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line">    <span class="comment">//  swapChildren(node);</span></span><br><span class="line">    <span class="comment">//  invertTree(node.left);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    swapChildren(root);</span><br><span class="line">    <span class="comment">// When it is midOrder, we must pay attention to the final step</span></span><br><span class="line">    <span class="comment">// Since the swapChildren step has already moved left subTree to right</span></span><br><span class="line">    <span class="comment">// The next step, which should have been invertTree(root.right) should be converted</span></span><br><span class="line">    <span class="comment">// to invertTree(root.left)</span></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Level-Traversal"><a href="#4-Level-Traversal" class="headerlink" title="4.Level Traversal"></a>4.Level Traversal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">popped</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            swapChildren(popped);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (popped.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (popped.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(popped.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. Symmetric Tree</a></h2><h3 id="Intro-9"><a href="#Intro-9" class="headerlink" title="Intro"></a>Intro</h3><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Recursion-Postorder"><a href="#1-Recursion-Postorder" class="headerlink" title="1.Recursion + Postorder"></a>1.Recursion + Postorder</h4><p>We can only use postorder rather the other two while dealing with the issue of comparing the left and right, followed by integrating the result into the upper node. This is quite like backtrack.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> * PostOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// We can only use postOrder in this question because we want to compare</span></span><br><span class="line">    <span class="comment">// the left node and the right of a subtree and then return to the root,</span></span><br><span class="line">    <span class="comment">// following the order of left, right, and middle, which is exactly the</span></span><br><span class="line">    <span class="comment">// order of postOrder.</span></span><br><span class="line">    <span class="comment">// Besides, we must separate the tree into two parts, one is outside part</span></span><br><span class="line">    <span class="comment">// and the other inside part. This is how we can deal with symmetry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.First confirm returned value and params</span></span><br><span class="line">    <span class="comment">//      boolean compare(TreeNode left, TreeNode right)</span></span><br><span class="line">    <span class="comment">// 2.Then confirm the end condition</span></span><br><span class="line">    <span class="comment">//   We must pay attention to null conditions</span></span><br><span class="line">    <span class="comment">//      if (left == null &amp;&amp; right != null) &#123;return false;&#125;</span></span><br><span class="line">    <span class="comment">//      if (left != null &amp;&amp; right == null) &#123;return false;&#125;</span></span><br><span class="line">    <span class="comment">//      if (left == null &amp;&amp; right == null) &#123;return true;&#125;</span></span><br><span class="line">    <span class="comment">//      if (left.val != right.val) &#123;return false;&#125;</span></span><br><span class="line">    <span class="comment">// 3.Finally, we confirm the logic</span></span><br><span class="line">    <span class="comment">//   Pay attention to the compare order</span></span><br><span class="line">    <span class="comment">//   The correct one should be</span></span><br><span class="line">    <span class="comment">//   3.1.outside:   left.left VS right.right</span></span><br><span class="line">    <span class="comment">//   3.2.inside:    left.right VS right.left</span></span><br><span class="line">    <span class="comment">//   It can be proved by drawing a picture</span></span><br><span class="line">    <span class="comment">//      boolean outside = compare(left.left, right.right);</span></span><br><span class="line">    <span class="comment">//      boolean inside = compare(left.right, right.left);</span></span><br><span class="line">    <span class="comment">//      boolean isSame = outside &amp;&amp; inside;</span></span><br><span class="line">    <span class="comment">//      return isSame;</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> compare(root.left, root.right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isSame</span> <span class="operator">=</span> outside &amp;&amp; inside;</span><br><span class="line">      <span class="keyword">return</span> isSame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Level-Traversal"><a href="#2-Level-Traversal" class="headerlink" title="2.Level Traversal"></a>2.Level Traversal</h4><p>We can also use queue to solve this question. </p>
<p>The most important point is in what sequence shall we put nodes into the queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// We can also use queue to do layer search</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root.left);</span><br><span class="line">    queue.add(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// poll two nodes and compare</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">// compare these two nodes</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If two nodes are not null and have the same value</span></span><br><span class="line">        <span class="comment">// We then push their sons children into the queue</span></span><br><span class="line">        <span class="comment">// But order is quite important, and we can know the</span></span><br><span class="line">        <span class="comment">// correct order from picture</span></span><br><span class="line">        <span class="comment">// It should be</span></span><br><span class="line">        <span class="comment">//      1.left.left</span></span><br><span class="line">        <span class="comment">//      2.right.right</span></span><br><span class="line">        <span class="comment">//      3.left.right</span></span><br><span class="line">        <span class="comment">//      4.right.left</span></span><br><span class="line">        queue.add(left.left);</span><br><span class="line">        queue.add(right.right);</span><br><span class="line">        queue.add(left.right);</span><br><span class="line">        queue.add(right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>Binary_Tree</tag>
        <tag>DFS</tag>
        <tag>Level_Traversal</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
</search>
