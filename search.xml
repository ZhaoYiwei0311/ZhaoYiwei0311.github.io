<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Day01 Array Part01</title>
    <url>/2023/04/20/Day01-Array-Part01/</url>
    <content><![CDATA[<h2 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704 Binary Search"></a><a href="https://leetcode.cn/problems/binary-search/">704 Binary Search</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p>
<p>You must write an algorithm with O(log n) runtime complexity.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Left-Close-Right-Close"><a href="#1-Left-Close-Right-Close" class="headerlink" title="1. Left Close Right Close"></a>1. Left Close Right Close</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Left Close Right Close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// eg:[1, 1] is a legal loop, so use &quot;&lt;=&quot; here</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">         <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">             right = index - <span class="number">1</span>; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">             left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> index;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Left-Close-Right-Open"><a href="#2-Left-Close-Right-Open" class="headerlink" title="2. Left Close Right Open"></a>2. Left Close Right Open</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Left Close Right Open</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// Now right is open, so do not use (nums.length - 1) for start</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// eg:[1, 1) is not a legal loop, so use &quot;&lt;&quot; here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// Do not cross the boarder of Integer</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// Go to left part</span></span><br><span class="line">            right = index; <span class="comment">// It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// Go to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>; <span class="comment">//It has been known that nums[index] is not the answer we want, so just exclude it for the next loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27 Remove Element"></a><a href="https://leetcode.cn/problems/remove-element/">27 Remove Element</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p> Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.</p>
<p> Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:</p>
<ul>
<li><p>change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.</p>
</li>
<li><p>Return <code>k</code>.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent"><a href="#1-Violent" class="headerlink" title="1.Violent"></a>1.Violent</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Violent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// We have found the element to be deleted, so we need to start a new loop to move forward the elements after the found element</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// Because all the elements after i have been moved forward, it is necessary to minus i to get a new start</span></span><br><span class="line">            size--; <span class="comment">// the size of nums should also be declined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Two-Pointer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// fast index is aimed to go through the old nums</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// slow index is aimed to update out new nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123; <span class="comment">// the element is not the one to be deleted</span></span><br><span class="line">                nums[slow++] = nums[fast++]; <span class="comment">// so fast and slow both move forward, meanwhile nums[slow] is replaced by nums[fast]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// the element is the one to be deleted</span></span><br><span class="line">                fast++; <span class="comment">// so only fast moves forward to go through the nums, while slow just waits for the next loop in which the element shall not be deleted</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">// slow is the size of out new nums</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35 Search Insert Position"></a>35 <a href="https://leetcode.cn/problems/search-insert-position/">Search Insert Position</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p> Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search"><a href="#1-Binary-Search" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binary Search</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// go to left side</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// go to right side</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34 Find First and Last Position of Element in Sorted Array"></a>34 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p> Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p>
<p> If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>
<p> You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Binary-Search-1"><a href="#1-Binary-Search-1" class="headerlink" title="1.Binary Search"></a>1.Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Binary Search</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">1</span>) &#123; <span class="comment">// Defense first</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) &#123; <span class="comment">// move to left part</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] &lt; target) &#123; <span class="comment">// move to right part</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// one index has been found</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// We will try to get its left end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= nums.length - <span class="number">1</span>; i++) &#123; <span class="comment">// We will try to get its right end</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                    ans[<span class="number">1</span>] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary_Search</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
      </tags>
  </entry>
  <entry>
    <title>Day02 Array Part02</title>
    <url>/2023/04/20/Day02-Array-Part02/</url>
    <content><![CDATA[<h2 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Violent-Quick-Sort"><a href="#1-Violent-Quick-Sort" class="headerlink" title="1.Violent + Quick_Sort"></a>1.Violent + Quick_Sort</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Violent + Quick_Sort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// Square First</span></span><br><span class="line">        nums[i] = (<span class="type">int</span>)Math.pow(nums[i], <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// get the position of partition</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="comment">// divide and conquer for the left part</span></span><br><span class="line">        quickSort(arr, left, position - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// divide and conquer for the right part</span></span><br><span class="line">        quickSort(arr, position + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.choose the last element as the pivot to be compared</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">    <span class="comment">// 2.define the pointer that is in front of the pivot, here goes to the leftest</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="comment">// 3.iterate the array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="comment">// if arr[i] is not bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then swap the position itself with both the index and the pointer moving afterwards</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            swap(arr, i, pointer++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if arr[i] is bigger than the pivot,</span></span><br><span class="line">        <span class="comment">// then we will just move the index backwards,</span></span><br><span class="line">        <span class="comment">// leaving the pointer unchanged</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.the array has been iterated, and we will finally swap the position of pointer and right</span></span><br><span class="line">    swap(arr, pointer, right);</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">    arr[left] = arr[right];</span><br><span class="line">    arr[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Two-Pointer"><a href="#2-Two-Pointer" class="headerlink" title="2.Two-Pointer"></a>2.Two-Pointer</h4><p>​	In the example of [-4,-1,0,3,10], which contains all three cases of negative number, zero and positive number, we can see easily find out that the biggest number squared will always appear on either left or right side. </p>
<p>This gives us a hint to try to use Two-Pointer Strategy which starts from both sides and by comparison we can just get the targeted squared array within complexity of O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// we are going to iterate the array in a reversed order, so the index should be set the last position</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(nums[left]) &gt;= Math.abs(nums[right])) &#123; <span class="comment">// left absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[left], <span class="number">2</span>));</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// right absolute value is bigger</span></span><br><span class="line">            ans[index--] = (<span class="type">int</span>)(Math.pow(nums[right], <span class="number">2</span>));</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two-Pointer"></a>1.Two-Pointer</h4><p>​	Still with a left index and right index indicating the bounds of subarray we want</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two-Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= nums.length - <span class="number">1</span>) &#123; <span class="comment">// as long as the left index does not get to the end of array, the loop will continue</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target ) &#123; <span class="comment">// sum is smaller than our target, so we have to move right index afterwards</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; nums.length - <span class="number">1</span>) &#123; <span class="comment">// but there might be a case when our right index has already been out of bounds, where we have to stop the loop</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[right++]; <span class="comment">// in normal cases, right index move backwards as well as our sum gets bigger</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// sum is now not bigger than the target, so it is time to move left index afterwards to make the subarray smaller</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">                ans = right - left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, right - left);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[left++]; <span class="comment">// after the left index moves afterwards, the sum will get smaller</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Sliding-Window"><a href="#2-Sliding-Window" class="headerlink" title="2.Sliding-Window"></a>2.Sliding-Window</h4><p>The Sliding-Window here is an enhanced version of Two-Pointer above.</p>
<p>The key point is to use index end as the right side of subarray, while at the meantime when the sum is not smaller than the target, we are going to move the index start to narrow the subarray.</p>
<p>The process of narrowing is included within a while loop below the outer for loop.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sliding_Window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we will need a start index to indicate the left side of subarray</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length; end++) &#123; <span class="comment">// i here indicates the right side, AKA the end of subarray</span></span><br><span class="line">        sum += nums[end];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">// we must use while rather than if here because only by using while can we get the minimum size of subarray</span></span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = end - start + <span class="number">1</span>; <span class="comment">// ans is initialized to 0 at the beginning, so there is a judgment first</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[start++]; <span class="comment">// sum will be smaller after start index moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>​	Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>​	It is the issue of boarder that we must emphasize on while dealing with this question.</p>
<p>We can stick to one principle, say “Left Close Right Open” in order not to get confused while writing codes.</p>
<p>There are also other points to be treated seriously.</p>
<ol>
<li><p>n might be even or odd, and we have to deal with it separately because of the existence of the center point.</p>
</li>
<li><p>After each All-round loop, the next start point would be changed, and we must know the exact offset. </p>
</li>
<li><p>We must know the unchanged point of every smaller loop that just covers one side of the matrix. In the horizontal movement, it is j that changes, while in the verical one, it is i.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pay attention to the boarder, we will stick to left close right open</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// number to be filled</span></span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// if n == 4, then we will have 2 loops; if n == 5, we will have 3 loops</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// we start from (0, 0)</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// up: left to right</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from left to right, i remains the same, while j will change</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,0), (0,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,0), (0,1), (0,2)</span></span><br><span class="line">            ans[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// right: up to down</span></span><br><span class="line">        <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be n - loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (0,2), (1,2)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (0,3), (1,3), (2,3)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// down: right to left</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">            <span class="comment">// we use j as the index in this loop because from right to left, i remains the same, while j will change. And i has been set to the bottom row since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,2), (2,1)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,3), (3,2), (3,1)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left: down to ip</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">            <span class="comment">// we use i as the index in this loop because from up to down, j remains the same, while i will change. And j has already been changed since the previous loop</span></span><br><span class="line">            <span class="comment">// the end will be loop because it is the rule of left close right open that we obey</span></span><br><span class="line">            <span class="comment">// in the case of n == 3, the first layer would be (2,0), (1,0)</span></span><br><span class="line">            <span class="comment">// in the case of n == 4, the first layer would be (3,0), (2,0), (1,0)</span></span><br><span class="line">            ans[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++; <span class="comment">// now that one outer layer is finished, it is time to increment the start point</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n % <span class="number">2</span>) != <span class="number">0</span>) &#123; <span class="comment">// in the case where n is an odd number, we have to deal with the center point alone</span></span><br><span class="line">        ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two_Pointer</tag>
        <tag>Sliding_window</tag>
      </tags>
  </entry>
  <entry>
    <title>Day03 Linked List Part01</title>
    <url>/2023/04/21/Day03-Linked-List-Part01/</url>
    <content><![CDATA[<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. Remove Linked List Elements</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the new head.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Normal"><a href="#1-Normal" class="headerlink" title="1.Normal"></a>1.Normal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.Head node is a problem because it does not have a pre node, therefore it must be dealt with alone.</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        <span class="comment">// for defense, head must not be null</span></span><br><span class="line">        <span class="comment">// we use while instead of if here because there might be the case when head = [1,1,1] and val = 1. In such case, all head nodes should be deleted and if does not suffice</span></span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.Now that we have eliminated the threat from head node, it is time to delete nodes afterwards</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; <span class="comment">// it is essential to set a temporary index that points to head</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1           2           3           4</span></span><br><span class="line">    <span class="comment">//      cur         cur.n       cur.n.n</span></span><br><span class="line">    <span class="comment">//  suppose val = 2 and we can see that cur.n is to be deleted</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// we have to get the next of cur, so cur must not be null;</span></span><br><span class="line">        <span class="comment">// we also have to get the val of cur.next, so cur.next must not be null</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next.val == val) &#123; <span class="comment">// we have found the node to be deleted, it is cur.next</span></span><br><span class="line">            cur.next = cur.next.next; <span class="comment">// cur should jump twice and change its next to the cur.next.next, in which cur.next would be skipped</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// it is not the node to be deleted, cur moves afterwards</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head"><a href="#2-Dummy-Head" class="headerlink" title="2.Dummy_Head"></a>2.Dummy_Head</h4><p>While facing linked list related questions, it is always a good idea to consider defining dummy head to avoid dealing with the case concerned with head node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy_Head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// set a dummy head to avoid dealing specially with head node;</span></span><br><span class="line">    <span class="comment">// two pointer is still necessary</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy; <span class="comment">// one starts from dummy</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;  <span class="comment">// one starts from head</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123; <span class="comment">// we have found the node that meets our requirement, it is time to delete</span></span><br><span class="line">            pre.next = cur.next; <span class="comment">// the next node after pre should be the one after cur</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur; <span class="comment">// the node is not the one to be deleted, so pre node moves afterwards</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next; <span class="comment">// in both cases, the cur should move afterwards</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// we must return dummy.next because there might be the case when we would delete head node.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. Design Linked List</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</p>
<p>A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer&#x2F;reference to the next node.</p>
<p>If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>
<p>Implement the MyLinkedList class:</p>
<ul>
<li><p><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</p>
</li>
<li><p>int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.</p>
</li>
<li><p>void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</p>
</li>
<li><p>void addAtTail(int val) Append a node of value val as the last element of the linked list.</p>
</li>
<li><p>void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.</p>
</li>
<li><p>void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.</p>
</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Dummy-Head"><a href="#1-Dummy-Head" class="headerlink" title="1.Dummy_Head"></a>1.Dummy_Head</h4><p>This question is a good one to  practice manipulating linked list. </p>
<p>We still need to rely on dummy head in order to simplify the treatment of head node.</p>
<p>Besides, the size of the list is also a key field to be utilized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// sequence is quite important</span></span><br><span class="line">        <span class="comment">//          0           2</span></span><br><span class="line">        <span class="comment">//          cur         cur.next</span></span><br><span class="line">        <span class="comment">// suppose we are going to add 1 as head</span></span><br><span class="line">        <span class="comment">//          0           1           2</span></span><br><span class="line">        <span class="comment">//          cur                     cur.next</span></span><br><span class="line">        <span class="comment">// 1.the next of 1 Node must be connected to cur.next first</span></span><br><span class="line">        <span class="comment">// 2.the cur.next then would be connected to 1 Node</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// move to the tail, if boarder bothers again, take the example of one node again</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, <span class="literal">null</span>);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Dummy-Head-But-More-Concise"><a href="#2-Dummy-Head-But-More-Concise" class="headerlink" title="2. Dummy_Head_But_More_Concise"></a>2. Dummy_Head_But_More_Concise</h4><p>Make addAtHead and addAtTail more concise by combining these two methods with addAtIndex</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the size of MyLinkedList</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy is the most important point in this question, its next is the original head node.</span></span><br><span class="line">    <span class="comment">// we will always start from dummy.</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialized</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// for defense</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123; <span class="comment">// here the end should be &lt;=, take the example of one node and we can figure out why</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">		addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// suppose we want to add 2 Node at index 1, which results in the example below</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">// then when will our cur stop iterating?</span></span><br><span class="line">        <span class="comment">// it should be like this</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         newNode     cur.n</span></span><br><span class="line">        <span class="comment">// because only by manipulating cur.next can we both know the previous node and the node to be added</span></span><br><span class="line">        <span class="comment">// and from the example, we know how to write for loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// still sequence is quite important</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val, cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123; <span class="comment">// defense</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// the key point is also to know exactly the relationship between cur and the indexth node</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//          cur         cur.n</span></span><br><span class="line">        <span class="comment">// suppose index = 1, which means 2 is the node to be deleted</span></span><br><span class="line">        <span class="comment">//          0           1           2           3</span></span><br><span class="line">        <span class="comment">//                      cur         cur.n       cur.n.n</span></span><br><span class="line">        <span class="comment">// cur should stop before the node to be deleted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. Reverse Linked List</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<h3 id="Soulution"><a href="#Soulution" class="headerlink" title="Soulution"></a>Soulution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>Two pointer, actually three pointer works quite well in this question.</p>
<p>Still sequence is the issue that matters</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// actually we need three pointers in this question and they are pre, cur and cur</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//          pre             cur         temp</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                          pre         cur         temp</span></span><br><span class="line">    <span class="comment">// in the end, it should be like this</span></span><br><span class="line">    <span class="comment">//          null            1           2           3           4           null</span></span><br><span class="line">    <span class="comment">//                                                              pre         cur</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// the most previous node should point to null, just as symmetrically, the next of end node points to null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// define our helper node to trace cur.next, otherwise cur loses its way afterwards</span></span><br><span class="line">        <span class="comment">// sequence is also important here</span></span><br><span class="line">        <span class="comment">// 1.cur should point to pre</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 2.pre should become cur</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 3.cur should be replaced with temp</span></span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// seen from the example, pre is the node to be returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Recursion"><a href="#2-Recursion" class="headerlink" title="2. Recursion"></a>2. Recursion</h4><p>Based on the two pointer solution above, we can get an easier but harder to understand solution which utilizes recursion</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// pre should be null and cur should be head</span></span><br><span class="line">    <span class="keyword">return</span> recursion(head, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">recursion</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123; <span class="comment">// the end of recursion</span></span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// still it is pre to be returned</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// helper node is still needed to trace cur.next</span></span><br><span class="line">    cur.next = pre; <span class="comment">// reversed here</span></span><br><span class="line">    <span class="keyword">return</span> recursion(temp, cur); <span class="comment">// the nodes here have changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Linked_List</tag>
        <tag>Dummy_Head</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>Day04 Linked List Part02</title>
    <url>/2023/04/23/Day04-Linked-List-Part02/</url>
    <content><![CDATA[<h2 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Dummy-Head"><a href="#1-Dummy-Head" class="headerlink" title="1.Dummy_Head"></a>1.Dummy_Head</h4><p>Dummy head is quite useful since it simplifies the manipulation of the very first head node.</p>
<p>Also, the sequence of next declaration and the utilization of  helper node are key points in this question</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy Head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// A dummy head is still needed, and its next is the head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">    <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">    <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">    <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Here we do not need to judge if cur is null because we have set the dummy as cur deliberately</span></span><br><span class="line">        <span class="comment">// In order to manipulate 1 and 2 node, we must get cur.next and cur.next.next</span></span><br><span class="line">        <span class="comment">// , which is the reason why they must not be null if the loop continues</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Once we have swapped 1 and 2, it is not possible to get 3 through 2,</span></span><br><span class="line">        <span class="comment">// so we need a helper here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp3</span> <span class="operator">=</span> cur.next.next.next;</span><br><span class="line">        <span class="comment">// As the same, once we connect 0 with 2, it is also not possible to get 1,</span></span><br><span class="line">        <span class="comment">// so we need another helper here</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start the swap and sequence is important</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       t1      c.n</span></span><br><span class="line">        <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n.n   c.n     t3</span></span><br><span class="line">        <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">        <span class="comment">//      c       c.n     c.n.n</span></span><br><span class="line">        <span class="comment">//      0       2       1       3       4</span></span><br><span class="line">        <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        cur.next.next = temp1;</span><br><span class="line">        cur.next.next.next = temp3;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// It is still dummy&#x27;s next to be returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-Dummy-Head"><a href="#1-Two-Pointer-Dummy-Head" class="headerlink" title="1.Two_Pointer + Dummy_Head"></a>1.Two_Pointer + Dummy_Head</h4><p>Two pointer can be use used to get the Nth node from end in one loop.</p>
<p>Suppose we are going to get the 2nd node from end, which is 4 in the example</p>
<ol>
<li>We are going to move fast pointer first</li>
<li>At step 3, when fast pointer has moved 2 steps afterwards, we are going to set the slow pointer. From now on, we will move both pointers simultaneously.</li>
<li>Fast pointer points to null at step 6 and our iteration stops. We can see that slow pointer now points to the node we want</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
</tr>
</tbody></table>
<p>Therefore, two pointer is  a useful skill to get the Nth node from end in one loop.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dummy Head + Two Pointer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// </span></span><br><span class="line">    <span class="comment">// Suppose n = 2, which means we are going to delete 3 Node</span></span><br><span class="line">    <span class="comment">//      0       1       2       3       4</span></span><br><span class="line">    <span class="comment">//                      c       c.n     c.n.n</span></span><br><span class="line">    <span class="comment">// We must make sure that cur points to the previous node 2 so that we can manipulate node 3</span></span><br><span class="line">    <span class="comment">// This means the slow pointer adopted from the two-pointer skill to get the Nth node from end in one loop should point to the node before, so here should be some adjustment.</span></span><br><span class="line">    <span class="comment">// We can adjust the fast pointer to let it move one more step before moving both pointers</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123; <span class="comment">// We let fast pointer move (n + 1) steps alone</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123; <span class="comment">// We move both pointers until fast points to null</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now it should be like this</span></span><br><span class="line">    <span class="comment">//      0       1       2       3       4       null</span></span><br><span class="line">    <span class="comment">//                      s                       f</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">// still return dummy.next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="02-07-Intersection-of-Two-Linked-Lists-LCCI"><a href="#02-07-Intersection-of-Two-Linked-Lists-LCCI" class="headerlink" title="02.07. Intersection of Two Linked Lists LCCI"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">02.07. Intersection of Two Linked Lists LCCI</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter­secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer"><a href="#1-Two-Pointer" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>The key point of this question is to understand the basic principle that judgment of intersection only starts once two lists have the relatively same length from end. We can deduce that by drawling two lists within right alignment.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// Suppose two lists below</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">// B    2       4       5</span></span><br><span class="line">    <span class="comment">// Apparently, Node 4 is the one to be returned, but how?</span></span><br><span class="line">    <span class="comment">// There is a rule that if there is an intersection, the two lists will always meet in the end</span></span><br><span class="line">    <span class="comment">// and the length of sub lists after intersection is the same</span></span><br><span class="line">    <span class="comment">// We can try to show both lists in right alignment</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">// We can know that Node 1 to Node 2 from A list is useless,</span></span><br><span class="line">    <span class="comment">// because intersection can only start when two sub lists are of the same length.</span></span><br><span class="line">    <span class="comment">// So we can skip them these we know the length difference of lists, which is 2</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">//                      cA</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">//                      cB</span></span><br><span class="line">    <span class="comment">// We make two pointers then at the relatively same point from end</span></span><br><span class="line">    <span class="comment">// then we can start move both pointers simultaneously until we find the intersected node</span></span><br><span class="line">    <span class="comment">// A    1       2       3       4       5</span></span><br><span class="line">    <span class="comment">//                              cA</span></span><br><span class="line">    <span class="comment">// B                    2       4       5</span></span><br><span class="line">    <span class="comment">//                              cB</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="comment">// We must know the length difference</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (curB != <span class="literal">null</span>) &#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        curB = curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get the length difference</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(lenA - lenB);</span><br><span class="line">    <span class="comment">// reset</span></span><br><span class="line">    curA = headA;</span><br><span class="line">    curB = headB;</span><br><span class="line">    <span class="comment">// By default, list A should be the one longer, and we can skip some nodes in it,</span></span><br><span class="line">    <span class="comment">// but this is not always the case, so there is a swap to make sure our assume work</span></span><br><span class="line">    <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">        curA = headB;</span><br><span class="line">        curB = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (diff-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">            <span class="keyword">return</span> curA;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = curA.next;</span><br><span class="line">        curB = curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p>
<p>Do not modify the linked list.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Two-Pointer-1"><a href="#1-Two-Pointer-1" class="headerlink" title="1.Two_Pointer"></a>1.Two_Pointer</h4><p>Two points for this question</p>
<ol>
<li><p>How can we know if there is a cycle in the list?</p>
<p>We can know that by moving two pointers, one moves two steps once and the other one one step once.</p>
<p>If there is no cycle, the faster one will point to null in advance.</p>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">s|f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center">f</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s</td>
<td align="center"></td>
<td align="center">f</td>
</tr>
</tbody></table>
<p>If there is a cycle, the two pointers will meet.</p>
<p>Suppose the node after 3 is node 1.</p>
<table>
<thead>
<tr>
<th align="center">Step</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">s|f</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center">s</td>
<td align="center">f</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">f</td>
<td align="center">s</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">s|f</td>
</tr>
</tbody></table>
</li>
<li><p>How can we know the entrance of cycle?</p>
<p><a href="https://postimg.cc/R6MwyMy0"><img src="https://i.postimg.cc/Y9F840xQ/Day04-Linked-List-Part02-01.jpg" alt="Day04-Linked-List-Part02-01.jpg"></a></p>
<p>Suppose x as the distance from start to entrance.</p>
<p>Suppose y as the distance from entrance to the point where both pointers meet, actually it is the distance slow pointer has move after it enters the circle.</p>
<p>Suppose z as the distance from the point met to entrance.</p>
<p>What clues can we get then?</p>
<ol>
<li><p>The whole distance of slow is x + y</p>
</li>
<li><p>The whole distance of cycle is y + z</p>
</li>
<li><p>The fast can have already moved n cycles, so the distance of fast is x + y + n * (y + z)</p>
</li>
<li><p>The speed of slow is 1 and the speed of fast is 2, so there is an equation: </p>
<p>​		2 * (x + y) &#x3D; x + y + n * (y + z)</p>
<p>​		x  &#x3D; n * (y + z) - z</p>
</li>
<li><p>n is always &gt;&#x3D; 1 and is not quite important, so we can just combine it with some (n - 1) factor</p>
<p>​		x  &#x3D; (n - 1) * (y + z) + z</p>
</li>
<li><p>Since n is not important, we can actually suppose it be 1 and what we get is</p>
<p>​		x  &#x3D; z</p>
<p>which means we can conclude that distance from start to entrance &#x3D;&#x3D; the distance from the point met to entrance</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// Since there might be a cycle now, we can not rely on dummy head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123; <span class="comment">// we must make sure that fast.next is also not null because there is no dummy head to simplify the manipulation of the very first head node.</span></span><br><span class="line">        <span class="comment">// If it is the case of [1], we will meet null pointer when we move fast for two steps</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123; <span class="comment">// two pointers have met</span></span><br><span class="line">            <span class="comment">// reset slow to head</span></span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="comment">// and move both pointers one step every time</span></span><br><span class="line">            <span class="comment">// they will meet at entrance</span></span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two_Pointer</tag>
        <tag>Linked_List</tag>
        <tag>Dummy_Head</tag>
      </tags>
  </entry>
  <entry>
    <title>Day06 Hash Table Part01</title>
    <url>/2023/04/24/Day06-Hash-Table-Part01/</url>
    <content><![CDATA[<h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. Valid Anagram</a></h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</p>
<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<span id="more"></span>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table"><a href="#1-Hash-Table" class="headerlink" title="1. Hash_Table"></a>1. Hash_Table</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123; <span class="comment">// If length is different, that will definitely be false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] table = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]; <span class="comment">// We do not need to create an alphabetical table.</span></span><br><span class="line">                               <span class="comment">// A simulation array would be okay.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        table[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++; <span class="comment">// for s add</span></span><br><span class="line">        table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--; <span class="comment">// for t minus</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i] != <span class="number">0</span>) &#123; <span class="comment">// if the value is not 0, it will not be anagram</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// Unlike alphabets, we do not know the exact value in the arrays.</span></span><br><span class="line">    <span class="comment">// So we use set instead of array made by ourselves.</span></span><br><span class="line">    HashSet&lt;Integer&gt; containerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; resultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123; <span class="comment">// get all unique value from nums1</span></span><br><span class="line">        containerSet.add(nums1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123; <span class="comment">// compare nums2 with containerSet and find intersection</span></span><br><span class="line">        <span class="keyword">if</span> (containerSet.contains(nums2[i])) &#123;</span><br><span class="line">            resultSet.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[resultSet.size()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : resultSet) &#123;</span><br><span class="line">        ans[index++] = integer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.cn/problems/happy-number/">202. Happy Number</a></h2><h3 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h3><p>Write an algorithm to determine if a number n is happy.</p>
<p>A happy number is a number defined by the following process:</p>
<ul>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or <strong>it loops endlessly in a cycle</strong> which does not include 1.</li>
<li>Those numbers for which this process ends in 1 are happy.</li>
</ul>
<p>Return true if n is a happy number, and false if not.</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Set-1"><a href="#1-Set-1" class="headerlink" title="1. Set"></a>1. Set</h4><p>The hardest part might be the algorithm to get the next number.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// It says that there will be an endless loop if n is not happy.</span></span><br><span class="line">    <span class="comment">// So we can use a set to store numbers that have appeared.</span></span><br><span class="line">    <span class="comment">// Once repetition occurs, return false.</span></span><br><span class="line">    HashSet&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    record.add(n); <span class="comment">// put n into record</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextNumber</span> <span class="operator">=</span> getNextNumber(n);</span><br><span class="line">    <span class="keyword">while</span> (nextNumber != <span class="number">1</span>) &#123;</span><br><span class="line">        nextNumber = getNextNumber(nextNumber); <span class="comment">// get the next number</span></span><br><span class="line">        <span class="keyword">if</span> (!record.contains(nextNumber)) &#123; <span class="comment">// if the next number is a new number, we continue</span></span><br><span class="line">            record.add(nextNumber);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// if the next number has appeared, we return false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="comment">// always get the rightmost digit</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line">        sum += digit * digit;</span><br><span class="line">        num = num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h2><h3 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro"></a>Intro</h3><p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h4 id="1-Hash-Table-1"><a href="#1-Hash-Table-1" class="headerlink" title="1.Hash_Table"></a>1.Hash_Table</h4><p>We use Hash if there is a requirement to record the element that has appeared. </p>
<p>We use map because we want to both record the number that has already appeared and the index of it.</p>
<p>Set is not sufficient because it cannot do the latter.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash Table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// use map to record target - nums[i]</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// See if there exists a number in the map that equals to nums[i]</span></span><br><span class="line">        <span class="comment">// That is because that we put in the map is target - nums[i]</span></span><br><span class="line">        <span class="keyword">if</span> (map.get(nums[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">            ans[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// What we put is target - nums[i]</span></span><br><span class="line">        <span class="comment">// What we compare in the iteration is target - nums[i] and nums[i]</span></span><br><span class="line">        <span class="comment">// Also sequence is important here to avoid repetition</span></span><br><span class="line">        <span class="comment">//  1.first compare</span></span><br><span class="line">        <span class="comment">//  2.then put</span></span><br><span class="line">        <span class="comment">// if sequence gets wrong, the answer would be [0,0] in the case where nums [3,2,4]</span></span><br><span class="line">        <span class="comment">//  and target = 6 because we failed to avoid repetition</span></span><br><span class="line">        map.put(target - nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash_Table</tag>
        <tag>Set</tag>
      </tags>
  </entry>
</search>
